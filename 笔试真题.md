



# 动态规划


## 2025年8月31日-蚂蚁算法岗-第一题-字符中位符-模拟

好的，作为一名高级软件工程师，我将为你详细解析这道算法题，并提供多种解法及其代码实现。

### 题目及分析

**题目描述**

给定一个长度为 `n`，仅由小写字母组成的字符串 `s`，请输出它的“中位符”。

**中位符定义**

将该字符串按字典序（ASCII码从小到大）排序后，排在第 `⌊n / 2⌋` 个位置的字符（从1开始计数）。

**输入/输出**

*   **输入**：两行。第一行是整数 `n` (1 ≤ n ≤ 2 × 10⁵)，第二行是长度为 `n` 的字符串 `s`。
*   **输出**：一个字符，表示字符串 `s` 的中位符。

**分析**

题目的核心是找到排序后特定位置的字符。我们来解读一下“中位符”的定义：

1.  **排序**：首先，需要将输入的字符串 `s` 按照字符的字典序进行排序。例如，`"cba"` 排序后变成 `"abc"`。
2.  **定位**：排序后，我们需要找到目标位置。题目描述为 “第 `⌊n / 2⌋` 个字符(从1开始计数)”。这里的 `⌊x⌋` 是向下取整符号。
    *   在计算机科学中，数组和字符串的索引通常从0开始。
    *   一个从1开始的第 `k` 个元素，对应的是从0开始的第 `k-1` 个索引。
    *   因此，“第 `⌊n / 2⌋` 个字符(从1开始计数)” 实际上指的是排序后，**索引为 `⌊n / 2⌋ - 1`** 的字符。

    **等等，我们用示例来验证一下这个理解是否正确。**
    *   **输入**: `n = 3`, `s = "cba"`
    *   **排序后**: `"abc"`
    *   **目标位置**: `⌊3 / 2⌋ = 1`。
    *   **如果按 `索引 = ⌊n / 2⌋ - 1` 计算**: 索引为 `1 - 1 = 0`，字符是 `'a'`。但这与示例输出 `'b'` 不符。

    **让我们换一种理解方式。**
    很多编程竞赛题目中的“第k个”实际上是指0-based索引的第k个位置。我们用这个假设再来验证一次。
    *   **输入**: `n = 3`, `s = "cba"`
    *   **排序后**: `"abc"`
    *   **目标位置**: `⌊3 / 2⌋ = 1`。
    *   **如果按 `索引 = ⌊n / 2⌋` 计算**: 索引为 `1`，字符是 `'b'`。这与示例输出 `'b'` 完全吻合。

    **结论**：中位符就是将字符串 `s` 排序后，位于**0-based索引 `⌊n / 2⌋`** 处的字符。

    **数据规模**：`n` 的最大值为 2 × 10⁵，这意味着 O(n²) 的算法会超时，而 O(n log n) 或 O(n) 的算法是可以通过的。

---

### 解法一：直接排序

 讲解

这是最直观的解法，完全按照“中位符”的定义来操作。

1.  **读取输入**：读取字符串的长度 `n` 和字符串 `s`。
2.  **转换并排序**：将字符串 `s` 转换为一个字符数组（或列表），因为字符串本身通常是不可变的。然后使用语言内置的排序函数对这个字符数组进行排序。
3.  **计算索引**：计算中位数的索引 `index = n / 2` （在大多数语言中，整数除法会自动向下取整）。
4.  **获取结果**：从排序后的数组中取出索引为 `index` 的字符，并输出。

这种方法的时间复杂度主要由排序算法决定，通常是 O(n log n)，空间复杂度为 O(n) 用于存储字符数组。对于本题的数据规模，这是完全可以接受的。

 代码

 Java 实现

```java
// 核心模式
class Solution {
    /**
     * 查找字符串的中位符
     * @param n 字符串长度
     * @param s 输入的字符串
     * @return 中位符
     */
    public char findMedianChar(int n, String s) {
        // 1. 将字符串转换为字符数组，以便排序
        char[] chars = s.toCharArray();

        // 2. 使用Java内置的排序函数对数组进行排序
        java.util.Arrays.sort(chars);

        // 3. 计算中位符的索引 (整数除法自动向下取整)
        int medianIndex = n / 2;

        // 4. 返回排序后位于中位索引的字符
        return chars[medianIndex];
    }
}
```

```java
// ACM 模式
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        // 使用 Scanner 来读取标准输入
        Scanner scanner = new Scanner(System.in);

        // 第一行：读取字符串的长度 n
        int n = scanner.nextInt();

        // 第二行：读取字符串 s
        String s = scanner.next();

        // 关闭 scanner
        scanner.close();

        // 1. 将字符串转换为字符数组
        // toCharArray() 方法会创建一个新的字符数组
        char[] chars = s.toCharArray();

        // 2. 对字符数组进行排序
        // Arrays.sort() 使用了高效的排序算法（如快速排序或归并排序）
        // 时间复杂度为 O(n log n)
        Arrays.sort(chars);

        // 3. 计算中位符的索引
        // Java中的整数除法 `n / 2` 结果会自动向下取整，等价于 floor(n / 2)
        int medianIndex = n / 2;

        // 4. 获取并输出中位符
        System.out.println(chars[medianIndex]);
    }
}
```

 Python 实现

```python
# 核心模式
def find_median_char(n: int, s: str) -> str:
    """
    查找字符串的中位符
    :param n: 字符串长度
    :param s: 输入的字符串
    :return: 中位符
    """
    # 1. 对字符串进行排序。sorted()函数会返回一个排序后的字符列表
    sorted_chars = sorted(s)

    # 2. 计算中位符的索引 (整数除法 // 自动向下取整)
    median_index = n // 2

    # 3. 返回排序后位于中位索引的字符
    return sorted_chars[median_index]

```

```python
# ACM 模式
import sys

def main():
    """
    主函数，处理输入和输出
    """
    # 从标准输入读取所有行
    lines = sys.stdin.readlines()

    # 第一行：获取字符串长度 n
    # strip() 用于移除可能的空白字符
    n = int(lines[0].strip())

    # 第二行：获取字符串 s
    s = lines[1].strip()

    # 1. 对字符串s中的字符进行排序
    # sorted() 函数返回一个包含排序后字符的新列表
    # 时间复杂度为 O(n log n)
    sorted_chars = sorted(s)

    # 2. 计算中位符的索引
    # Python中的整数除法 `//` 结果会自动向下取整
    median_index = n // 2

    # 3. 获取并输出中位符
    # sys.stdout.write可以避免print函数默认添加的换行符（如果需要）
    # 这里直接用print更简洁
    print(sorted_chars[median_index])

if __name__ == "__main__":
    main()

```

 示例演示

以输入 `n = 3`, `s = "cba"` 为例：

1.  **读取输入**：程序读入 `n = 3` 和 `s = "cba"`。
2.  **转换与排序**：
    *   Java: `s.toCharArray()` 得到 `['c', 'b', 'a']`。`Arrays.sort()` 后变为 `['a', 'b', 'c']`。
    *   Python: `sorted(s)` 直接得到 `['a', 'b', 'c']`。
3.  **计算索引**：`medianIndex = 3 / 2` (或 `3 // 2`)，结果为 `1`。
4.  **获取结果**：从排序后的数组 `['a', 'b', 'c']` 中取出索引为 `1` 的元素，即 `'b'`。
5.  **输出**：程序打印字符 `'b'`。

---

### 解法二：计数排序

 讲解

考虑到字符串只包含小写字母（'a'-'z'），这是一个有限且固定的字符集（26个字符）。在这种情况下，使用计数排序是更高效的选择。

1.  **创建计数桶**：创建一个大小为26的数组（或哈希表），用于统计每个小写字母出现的次数。例如，`counts[0]` 存 `'a'` 的数量，`counts[1]` 存 `'b'` 的数量，以此类推。
2.  **统计频率**：遍历输入字符串 `s`，填充计数桶。对于每个字符 `c`，将其对应的计数加一（例如 `counts[c - 'a']++`）。
3.  **查找中位符**：
    *   计算目标位置 `target_pos = n / 2`。我们需要找到在排序后的逻辑序列中，第 `target_pos` 个字符（0-based）是什么。
    *   遍历计数桶（从 `'a'` 到 `'z'`）。用 `target_pos` 减去每个字符的数量。
    *   当 `target_pos` 减去某个字符 `c` 的数量后首次变为负数时，说明中位符就是这个字符 `c`。

这种方法的时间复杂度为 O(n + k)，其中 `k` 是字符集的大小（26）。由于 `k` 是一个常数，所以时间复杂度可以看作 O(n)。空间复杂度为 O(k)，即 O(1) 的常数空间。

 代码

 Java 实现

```java
// 核心模式
class Solution {
    /**
     * 使用计数排序思想查找字符串的中位符
     * @param n 字符串长度
     * @param s 输入的字符串
     * @return 中位符
     */
    public char findMedianCharCounting(int n, String s) {
        // 1. 创建一个大小为26的数组作为计数桶
        int[] counts = new int[26];

        // 2. 遍历字符串，统计每个字符的出现次数
        for (char c : s.toCharArray()) {
            counts[c - 'a']++;
        }

        // 3. 计算中位符的目标位置（0-based）
        int targetPos = n / 2;

        // 4. 遍历计数桶，找到中位符
        for (int i = 0; i < 26; i++) {
            // 如果目标位置落在当前字符的计数范围内
            if (targetPos < counts[i]) {
                // 当前字符就是中位符
                // (char)('a' + i) 将索引转换回字符
                return (char)('a' + i);
            }
            // 否则，跳过当前字符的所有实例，更新目标位置
            targetPos -= counts[i];
        }

        // 理论上不会执行到这里，因为中位符肯定存在
        return ' ';
    }
}
```

```java
// ACM 模式
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String s = scanner.next();
        scanner.close();

        // 1. 创建计数桶，大小为26，对应 'a' 到 'z'
        // 数组默认所有元素初始化为0
        int[] counts = new int[26];

        // 2. 遍历输入字符串，填充计数桶
        // 时间复杂度 O(n)
        for (int i = 0; i < n; i++) {
            // s.charAt(i) - 'a' 将字符转换为 0-25 的索引
            counts[s.charAt(i) - 'a']++;
        }

        // 3. 计算中位符的目标位置（0-based index）
        int targetPos = n / 2;
        char medianChar = ' '; // 初始化结果变量

        // 4. 遍历计数桶，查找中位符
        // 这个循环最多执行26次，时间复杂度 O(k), k=26
        for (int i = 0; i < 26; i++) {
            // 检查目标位置是否在当前字符的范围内
            if (targetPos < counts[i]) {
                // 如果是，则当前字符就是我们要找的中位符
                medianChar = (char) ('a' + i);
                // 找到后立即退出循环
                break;
            }
            // 如果不是，说明中位符在后面，
            // 从目标位置中减去当前字符的数量，相当于跳过这些字符
            targetPos -= counts[i];
        }

        // 5. 输出结果
        System.out.println(medianChar);
    }
}
```

 Python 实现

```python
# 核心模式
def find_median_char_counting(n: int, s: str) -> str:
    """
    使用计数排序思想查找字符串的中位符
    :param n: 字符串长度
    :param s: 输入的字符串
    :return: 中位符
    """
    # 1. 创建大小为26的列表作为计数桶
    counts = [0] * 26

    # 2. 遍历字符串，统计字符频率
    for char in s:
        # ord(char) - ord('a') 将字符转换为 0-25 的索引
        counts[ord(char) - ord('a')] += 1

    # 3. 计算中位符的目标位置
    target_pos = n // 2

    # 4. 遍历计数桶，找到中位符
    for i in range(26):
        # 如果目标位置在当前字符的计数范围内
        if target_pos < counts[i]:
            # chr(ord('a') + i) 将索引转换回字符
            return chr(ord('a') + i)
        # 否则，更新目标位置
        target_pos -= counts[i]
    
    # 理论上不会执行到这里
    return ""

```

```python
# ACM 模式
import sys

def main():
    """
    主函数，处理输入和输出
    """
    lines = sys.stdin.readlines()
    n = int(lines[0].strip())
    s = lines[1].strip()

    # 1. 创建计数桶，一个长度为26的列表，全部初始化为0
    counts = [0] * 26

    # 2. 遍历字符串，统计每个字符的出现次数
    # 时间复杂度 O(n)
    for char in s:
        # ord(char) 获取字符的ASCII值
        # ord('a') 是 'a' 的ASCII值
        # 两者相减得到 0-25 的索引
        counts[ord(char) - ord('a')] += 1

    # 3. 计算中位符的目标位置（0-based index）
    target_pos = n // 2

    # 4. 遍历计数桶，找到中位符
    # 时间复杂度 O(k), k=26
    for i in range(26):
        # 获取当前字符（索引i对应的字符）的数量
        count = counts[i]
        
        # 检查目标位置是否在当前字符的范围内
        if target_pos < count:
            # 如果是，则找到了中位符
            # chr(ord('a') + i) 可以将索引i转换回对应的字符
            median_char = chr(ord('a') + i)
            print(median_char)
            # 找到后即可退出程序
            return
        
        # 如果不是，就从目标位置中减去当前字符的数量
        target_pos -= count

if __name__ == "__main__":
    main()
```

 示例演示

以输入 `n = 3`, `s = "cba"` 为例：

1.  **创建计数桶**：`counts = [0, 0, 0, ..., 0]` (长度26)。
2.  **统计频率**：
    *   遍历到 `'c'`：`counts[2]` 变为 `1`。
    *   遍历到 `'b'`：`counts[1]` 变为 `1`。
    *   遍历到 `'a'`：`counts[0]` 变为 `1`。
    *   最终 `counts` 为 `[1, 1, 1, 0, ..., 0]`。
3.  **查找中位符**：
    *   计算目标位置 `target_pos = 3 // 2 = 1`。
    *   开始遍历计数桶：
        *   **i = 0** (对应 `'a'`): `counts[0]` 是 `1`。`target_pos` (1) 不小于 `counts[0]` (1)。更新 `target_pos = 1 - 1 = 0`。
        *   **i = 1** (对应 `'b'`): `counts[1]` 是 `1`。`target_pos` (0) 小于 `counts[1]` (1)。条件成立！
    *   **确定结果**：中位符就是索引 `1` 对应的字符，即 `(char)('a' + 1)` 或 `chr(ord('a') + 1)`，结果是 `'b'`。
4.  **输出**：程序打印字符 `'b'`。















## 2025年8月10日-大疆-第一题-无人机能耗最小化路径规划-线性dp
好的，我们来详细讲解“无人机能耗最小化路径规划”这道算法题。

### 题目及分析

 **题目描述**

在实际的无人机物流配送场景中，无人机需要从仓库（左上角网格点）出发，将货物送达目的地（右下角网格点）。为了优化飞行效率，我们将其飞行区域划分为 `m` 行 `n` 列的网格单元格，每个单元格的数值表示该区域的单位能耗成本（非负整数，包含地形、风阻等因素影响）。由于无人机受限于飞行规则（如避免频繁转向、遵守临时禁飞区管制），每次只能向右或向下移动一个单元格。请为无人机规划一条从起点到终点的飞行路径，使得全程的总能耗成本最小。

 输入描述

第一行为两个整数，代表 `m` 和 `n`，含义同题干描述，接下来一个 `m` 行 `n` 列的二维数组，数组中的每个整数代表对应网格的能耗成本。

 输出描述

输出为正整数

 示例

**样例 1：**
输入：
```
3 3
1 2 3
4 5 6
7 8 9
```
输出：
```
21
```
解释：从左上角 `(0,0)` 到右下角 `(2,2)` 的路径 `1 → 2 → 3 → 6 → 9` 的总能耗为 `1+2+3+6+9 = 21`。
或者路径 `1 → 4 → 7 → 8 → 9` 的总能耗为 `1+4+7+8+9 = 29`。
路径 `1 → 2 → 5 → 8 → 9` 的总能耗为 `1+2+5+8+9 = 25`。
路径 `1 → 4 → 5 → 6 → 9` 的总能耗为 `1+4+5+6+9 = 25`。
其中 `1 → 2 → 3 → 6 → 9` 的能耗 `21` 是最小的。

 



**问题分析**

这道题目是经典的**最小路径和**问题。它要求我们从一个 `m x n` 的网格的左上角 `(0,0)` 出发，每次只能向下或向右移动一步，最终到达右下角 `(m-1, n-1)`，并找到一条路径，使得路径上所有单元格的能耗成本总和最小。

这显然是一个动态规划（Dynamic Programming）问题，因为它具备以下两个核心特征：

1.  **最优子结构 (Optimal Substructure)**：
    要找到到达单元格 `(i, j)` 的最小总能耗，无人机必须从 `(i-1, j)`（上方）或 `(i, j-1)`（左方）中的一个单元格移动过来。因此，到达 `(i, j)` 的最小总能耗，就是 `min(到达(i-1, j)的最小总能耗, 到达(i, j-1)的最小总能耗) + grid[i][j]`。这表明大问题的解可以由小问题的最优解推导出来。

2.  **重叠子问题 (Overlapping Subproblems)**：
    在计算到达不同单元格的最小总能耗时，我们可能会多次需要计算到达同一个中间单元格的最小总能耗。例如，计算 `(i+1, j)` 和 `(i, j+1)` 的最小总能耗时，都可能需要 `(i, j)` 的最小总能耗。动态规划通过存储这些子问题的解来避免重复计算。

基于以上分析，我们可以使用动态规划来解决此问题。

### 解法一：动态规划 (O(m*n) 空间复杂度)

 讲解

我们将创建一个与输入 `grid` 大小相同的 `dp` 数组，其中 `dp[i][j]` 表示从左上角 `(0,0)` 到达单元格 `(i,j)` 的最小总能耗。

1.  **定义 `dp` 数组**：
    `dp[i][j]`：表示从 `(0,0)` 到达 `(i,j)` 的最小总能耗。

2.  **初始化**：
    *   **起始点**：`dp[0][0] = grid[0][0]`。这是无人机路径的起点能耗。
    *   **第一行**：对于 `dp[0][j]` (其中 `j > 0`)，由于无人机只能向右移动，所以到达 `(0,j)` 的最小总能耗就是到达 `(0,j-1)` 的最小总能耗加上 `grid[0][j]` 的能耗。
        `dp[0][j] = dp[0][j-1] + grid[0][j]`。
    *   **第一列**：对于 `dp[i][0]` (其中 `i > 0`)，由于无人机只能向下移动，所以到达 `(i,0)` 的最小总能耗就是到达 `(i-1,0)` 的最小总能耗加上 `grid[i][0]` 的能耗。
        `dp[i][0] = dp[i-1][0] + grid[i][0]`。

3.  **状态转移方程**：
    对于网格中除了第一行和第一列之外的任何单元格 `(i,j)` (其中 `i > 0` 且 `j > 0`)：
    要到达 `(i,j)`，无人机可以从 `(i-1,j)`（上方）向下移动，也可以从 `(i,j-1)`（左方）向右移动。我们选择其中总能耗较小的那一条路径。
    `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`

4.  **最终结果**：
    `dp[m-1][n-1]` 就是从左上角到右下角的最小总能耗。

**时间复杂度**：
*   我们需要填充 `m x n` 个 `dp` 单元格，每个单元格的计算都是常数时间操作。
*   总时间复杂度为 `O(m * n)`。

**空间复杂度**：
*   我们创建了一个 `m x n` 大小的 `dp` 数组。
*   总空间复杂度为 `O(m * n)`。

 代码

 Java 版

**核心模式 (Core Pattern)**

```java
class Solution {
    /**
     * 计算无人机从左上角到右下角的最小能耗路径。
     * 每次只能向下或向右移动一步。
     *
     * @param grid 包含非负整数的 m x n 能耗网格。
     * @return 最小总能耗。
     */
    public int minPathSum(int[][] grid) {
        // 获取网格的行数和列数
        int m = grid.length;
        int n = grid[0].length;

        // 创建一个dp数组，dp[i][j] 表示从 (0,0) 到达 (i,j) 的最小总能耗。
        int[][] dp = new int[m][n];

        // 初始化起始点 (0,0) 的最小能耗
        dp[0][0] = grid[0][0];

        // 初始化第一行：无人机只能向右移动
        // dp[0][j] = dp[0][j-1] + grid[0][j]
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        // 初始化第一列：无人机只能向下移动
        // dp[i][0] = dp[i-1][0] + grid[i][0]
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        // 填充剩余的dp数组：对于每个单元格 (i,j)，
        // 无人机可以从上方 (i-1,j) 或 左方 (i,j-1) 移动过来。
        // 选择能耗较小的路径。
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        // 最终结果是到达右下角 (m-1, n-1) 的最小总能耗
        return dp[m - 1][n - 1];
    }
}
```

**ACM 模式 (ACM Pattern)**

```java
import java.util.Scanner;
import java.util.Arrays; // 引入Arrays用于stream操作，如果需要的话。这里直接用nextInt

public class Main {
    /**
     * 计算无人机从左上角到右下角的最小能耗路径。
     * 每次只能向下或向右移动一步。
     *
     * @param grid 包含非负整数的 m x n 能耗网格。
     * @return 最小总能耗。
     */
    public static int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int[][] dp = new int[m][n];

        dp[0][0] = grid[0][0];

        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        return dp[m - 1][n - 1];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取 m 和 n
        int m = scanner.nextInt();
        int n = scanner.nextInt();

        // 创建网格
        int[][] grid = new int[m][n];

        // 读取网格数据
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = scanner.nextInt();
            }
        }

        scanner.close();

        // 调用方法并打印结果
        System.out.println(minPathSum(grid));
    }
}
```

 Python 版

**核心模式 (Core Pattern)**

```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # 获取网格的行数和列数
        m = len(grid)
        n = len(grid[0])

        # 创建一个dp数组，dp[i][j] 表示从 (0,0) 到达 (i,j) 的最小总能耗。
        dp: List[List[int]] = [[0] * n for _ in range(m)]

        # 初始化起始点 (0,0) 的最小能耗
        dp[0][0] = grid[0][0]

        # 初始化第一行：无人机只能向右移动
        # dp[0][j] = dp[0][j-1] + grid[0][j]
        for j in range(1, n):
            dp[0][j] = dp[0][j - 1] + grid[0][j]

        # 初始化第一列：无人机只能向下移动
        # dp[i][0] = dp[i-1][0] + grid[i][0]
        for i in range(1, m):
            dp[i][0] = dp[i - 1][0] + grid[i][0]

        # 填充剩余的dp数组：对于每个单元格 (i,j)，
        # 无人机可以从上方 (i-1,j) 或 左方 (i,j-1) 移动过来。
        # 选择能耗较小的路径。
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

        # 最终结果是到达右下角 (m-1, n-1) 的最小总能耗
        return dp[m - 1][n - 1]

```

**ACM 模式 (ACM Pattern)**

```python
from typing import List

def min_path_sum(grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    dp: List[List[int]] = [[0] * n for _ in range(m)]

    dp[0][0] = grid[0][0]

    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]

    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]

    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

    return dp[m - 1][n - 1]

if __name__ == '__main__':
    # 读取 m 和 n
    m_n_str = input().split()
    m = int(m_n_str[0])
    n = int(m_n_str[1])

    # 创建网格并读取数据
    grid_input: List[List[int]] = []
    for _ in range(m):
        row_str = input().split()
        row_int = [int(x) for x in row_str]
        grid_input.append(row_int)

    # 调用函数并打印结果
    print(min_path_sum(grid_input))

```

 示例演示

以 `grid = [[1,2,3],[4,5,6],[7,8,9]]` 为例，逐步演示 `dp` 数组的计算过程。

`m = 3`, `n = 3`
初始化 `dp` 数组：
`dp = [[0, 0, 0],`
`      [0, 0, 0],`
`      [0, 0, 0]]`

1.  **初始化 `dp[0][0]`**:
    `dp[0][0] = grid[0][0] = 1`
    `dp = [[1, 0, 0],`
    `      [0, 0, 0],`
    `      [0, 0, 0]]`

2.  **初始化第一行 (`i = 0`)**:
    *   `j = 1`: `dp[0][1] = dp[0][0] + grid[0][1] = 1 + 2 = 3`
    *   `j = 2`: `dp[0][2] = dp[0][1] + grid[0][2] = 3 + 3 = 6`
    `dp = [[1, 3, 6],`
    `      [0, 0, 0],`
    `      [0, 0, 0]]`

3.  **初始化第一列 (`j = 0`)**:
    *   `i = 1`: `dp[1][0] = dp[0][0] + grid[1][0] = 1 + 4 = 5`
    *   `i = 2`: `dp[2][0] = dp[1][0] + grid[2][0] = 5 + 7 = 12`
    `dp = [[1, 3, 6],`
    `      [5, 0, 0],`
    `      [12, 0, 0]]`

4.  **填充剩余部分 (`i > 0`, `j > 0`)**:

    *   **`i = 1, j = 1`**: (单元格 `grid[1][1] = 5`)
        `dp[1][1] = min(dp[0][1], dp[1][0]) + grid[1][1]`
        `dp[1][1] = min(3, 5) + 5 = 3 + 5 = 8`
        `dp = [[1, 3, 6],`
        `      [5, 8, 0],`
        `      [12, 0, 0]]`

    *   **`i = 1, j = 2`**: (单元格 `grid[1][2] = 6`)
        `dp[1][2] = min(dp[0][2], dp[1][1]) + grid[1][2]`
        `dp[1][2] = min(6, 8) + 6 = 6 + 6 = 12`
        `dp = [[1, 3, 6],`
        `      [5, 8, 12],`
        `      [12, 0, 0]]`

    *   **`i = 2, j = 1`**: (单元格 `grid[2][1] = 8`)
        `dp[2][1] = min(dp[1][1], dp[2][0]) + grid[2][1]`
        `dp[2][1] = min(8, 12) + 8 = 8 + 8 = 16`
        `dp = [[1, 3, 6],`
        `      [5, 8, 12],`
        `      [12, 16, 0]]`

    *   **`i = 2, j = 2`**: (单元格 `grid[2][2] = 9`)
        `dp[2][2] = min(dp[1][2], dp[2][1]) + grid[2][2]`
        `dp[2][2] = min(12, 16) + 9 = 12 + 9 = 21`
        `dp = [[1, 3, 6],`
        `      [5, 8, 12],`
        `      [12, 16, 21]]`

最终结果为 `dp[2][2] = 21`，与样例输出一致。

### 解法二：动态规划 (O(min(m,n)) 空间复杂度优化)

 讲解

我们可以对解法一进行空间优化。注意到在计算 `dp[i][j]` 时，我们只依赖于 `dp[i-1][j]`（上方单元格的最小能耗）和 `dp[i][j-1]`（左方单元格的最小能耗）。这意味着我们不需要存储整个 `m x n` 的 `dp` 数组，只需要存储上一行的信息即可。

进一步，我们甚至可以只用一个一维数组来存储。这个一维数组的大小为 `n`（网格的列数）。

1.  **定义 `dp` 数组**：
    我们使用一个一维数组 `dp`，长度为 `n`。
    `dp[j]` 在处理第 `i` 行时，表示从 `(0,0)` 到达 `(i,j)` 的最小总能耗。
    在处理第 `i` 行之前，`dp[j]` 存储的是 `(i-1,j)` 的最小总能耗。

2.  **初始化**：
    *   首先，初始化 `dp` 数组的第一行。
        `dp[0] = grid[0][0]`
        对于 `j` 从 `1` 到 `n-1`：`dp[j] = dp[j-1] + grid[0][j]`。
    *   此时 `dp` 数组存储的是到达 `grid` 第一行所有单元格的最小总能耗。

3.  **状态转移**：
    从第二行开始 (`i` 从 `1` 到 `m-1`) 遍历：
    *   **更新当前行的第一个元素** (`dp[0]`)：
        `dp[0] = dp[0] + grid[i][0]`
        (这里的 `dp[0]` 在 `grid[i][0]` 左侧是上一行的 `dp[0]`，表示从 `(0,0)` 到达 `(i-1,0)` 的路径能耗，加上 `grid[i][0]` 就是到达 `(i,0)` 的路径能耗)。
    *   **更新当前行的其余元素** (`dp[j]`，`j` 从 `1` 到 `n-1`)：
        `dp[j] = min(dp[j], dp[j-1]) + grid[i][j]`
        (这里的 `dp[j]` (等号右侧) 此时是上一行 `(i-1, j)` 的最小总能耗。而 `dp[j-1]` (等号右侧) 已经更新为当前行 `(i, j-1)` 的最小总能耗。我们取两者中的最小值)。

4.  **最终结果**：
    循环结束后，`dp[n-1]`（即一维 `dp` 数组的最后一个元素）就是从左上角到右下角的最小总能耗。

**时间复杂度**：
*   依然是遍历 `m x n` 个单元格，每个单元格的计算是常数时间。
*   总时间复杂度为 `O(m * n)`。

**空间复杂度**：
*   我们只使用了一个长度为 `n` 的一维数组。
*   总空间复杂度为 `O(n)`。
*   为了实现 `O(min(m,n))` 的空间复杂度，我们可以在函数开始时检查 `m` 和 `n` 的大小，并确保 `dp` 数组的长度是较小维度的大小。例如，如果 `m < n`，我们可以将 `grid` 转置或调整循环逻辑，使 `dp` 数组的长度为 `m`。在下面的代码中，我们直接使用 `n` 作为 `dp` 数组的长度，因此空间复杂度为 `O(n)`。

 代码

 Java 版

**核心模式 (Core Pattern)**

```java
import java.util.Arrays;

class Solution {
    /**
     * 计算无人机从左上角到右下角的最小能耗路径 (O(n) 空间优化)。
     * 每次只能向下或向右移动一步。
     *
     * @param grid 包含非负整数的 m x n 能耗网格。
     * @return 最小总能耗。
     */
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        // dp 数组用于存储当前行或上一行的最小能耗信息。
        // dp[j] 表示从 (0,0) 到达当前行 (i,j) 的最小总能耗。
        int[] dp = new int[n];

        // 初始化 dp 数组的第一行 (i = 0)
        // dp[0] 存储 grid[0][0] 的能耗
        dp[0] = grid[0][0];
        // 填充第一行的其余元素，无人机只能从左边移动过来
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j - 1] + grid[0][j];
        }

        // 从第二行开始遍历 (i 从 1 到 m-1)
        for (int i = 1; i < m; i++) {
            // 更新当前行的第一个元素 (grid[i][0])
            // 无人机只能从上方 (i-1, 0) 移动过来
            dp[0] = dp[0] + grid[i][0];

            // 更新当前行的其余元素 (j 从 1 到 n-1)
            // 无人机可以从上方 (i-1, j) 或 左方 (i, j-1) 移动过来
            for (int j = 1; j < n; j++) {
                // dp[j] (在等号右边) 此时是上一行 (i-1, j) 的最小总能耗
                // dp[j-1] (在等号右边) 此时是当前行 (i, j-1) 的最小总能耗 (因为它已更新)
                dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];
            }
        }

        // 最终 dp[n-1] 存储的就是到达右下角 (m-1, n-1) 的最小总能耗
        return dp[n - 1];
    }
}
```

**ACM 模式 (ACM Pattern)**

```java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    /**
     * 计算无人机从左上角到右下角的最小能耗路径 (O(n) 空间优化)。
     * 每次只能向下或向右移动一步。
     *
     * @param grid 包含非负整数的 m x n 能耗网格。
     * @return 最小总能耗。
     */
    public static int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int[] dp = new int[n];

        dp[0] = grid[0][0];
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j - 1] + grid[0][j];
        }

        for (int i = 1; i < m; i++) {
            dp[0] = dp[0] + grid[i][0]; // 更新当前行第一个元素
            for (int j = 1; j < n; j++) {
                dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];
            }
        }

        return dp[n - 1];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int m = scanner.nextInt();
        int n = scanner.nextInt();

        int[][] grid = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = scanner.nextInt();
            }
        }

        scanner.close();

        System.out.println(minPathSum(grid));
    }
}
```

 Python 版

**核心模式 (Core Pattern)**

```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        # dp 列表用于存储当前行或上一行的最小能耗信息。
        # dp[j] 表示从 (0,0) 到达当前行 (i,j) 的最小总能耗。
        dp: List[int] = [0] * n

        # 初始化 dp 列表的第一行 (i = 0)
        # dp[0] 存储 grid[0][0] 的能耗
        dp[0] = grid[0][0]
        # 填充第一行的其余元素，无人机只能从左边移动过来
        for j in range(1, n):
            dp[j] = dp[j - 1] + grid[0][j]

        # 从第二行开始遍历 (i 从 1 到 m-1)
        for i in range(1, m):
            # 更新当前行的第一个元素 (grid[i][0])
            # 无人机只能从上方 (i-1, 0) 移动过来
            dp[0] = dp[0] + grid[i][0]

            # 更新当前行的其余元素 (j 从 1 到 n-1)
            # 无人机可以从上方 (i-1, j) 或 左方 (i, j-1) 移动过来
            for j in range(1, n):
                # dp[j] (在等号右边) 此时是上一行 (i-1, j) 的最小总能耗
                # dp[j-1] (在等号右边) 此时是当前行 (i, j-1) 的最小总能耗 (因为它已更新)
                dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]
        
        # 最终 dp[n-1] 存储的就是到达右下角 (m-1, n-1) 的最小总能耗
        return dp[n - 1]

```

**ACM 模式 (ACM Pattern)**

```python
from typing import List

def min_path_sum(grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    dp: List[int] = [0] * n

    dp[0] = grid[0][0]
    for j in range(1, n):
        dp[j] = dp[j - 1] + grid[0][j]

    for i in range(1, m):
        dp[0] = dp[0] + grid[i][0] # 更新当前行第一个元素
        for j in range(1, n):
            dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]
    
    return dp[n - 1]

if __name__ == '__main__':
    m_n_str = input().split()
    m = int(m_n_str[0])
    n = int(m_n_str[1])

    grid_input: List[List[int]] = []
    for _ in range(m):
        row_str = input().split()
        row_int = [int(x) for x in row_str]
        grid_input.append(row_int)

    print(min_path_sum(grid_input))

```

 示例演示

以 `grid = [[1,2,3],[4,5,6],[7,8,9]]` 为例，逐步演示 `dp` 数组的计算过程。

`m = 3`, `n = 3`
初始化 `dp` 数组（长度为 `n=3`）：`dp = [0, 0, 0]`

1.  **初始化第一行 (`i = 0`)**:
    *   `dp[0] = grid[0][0] = 1`
    *   `j = 1`: `dp[1] = dp[0] + grid[0][1] = 1 + 2 = 3`
    *   `j = 2`: `dp[2] = dp[1] + grid[0][2] = 3 + 3 = 6`
    **当前 `dp = [1, 3, 6]`** (代表到达 `(0,0)`, `(0,1)`, `(0,2)` 的最小总能耗)

2.  **处理第二行 (`i = 1`)**:
    *   **更新 `dp[0]`**: `dp[0] = dp[0] + grid[1][0] = 1 + 4 = 5`
        (此时 `dp[0]` 代表到达 `(1,0)` 的最小总能耗)
    *   **更新 `j = 1` (`grid[1][1] = 5`)**:
        `dp[1] = min(dp[1](旧值), dp[0](新值)) + grid[1][1]`
        `dp[1] = min(3, 5) + 5 = 3 + 5 = 8`
        (此时 `dp[1]` 代表到达 `(1,1)` 的最小总能耗)
    *   **更新 `j = 2` (`grid[1][2] = 6`)**:
        `dp[2] = min(dp[2](旧值), dp[1](新值)) + grid[1][2]`
        `dp[2] = min(6, 8) + 6 = 6 + 6 = 12`
        (此时 `dp[2]` 代表到达 `(1,2)` 的最小总能耗)
    **当前 `dp = [5, 8, 12]`** (代表到达 `(1,0)`, `(1,1)`, `(1,2)` 的最小总能耗)

3.  **处理第三行 (`i = 2`)**:
    *   **更新 `dp[0]`**: `dp[0] = dp[0] + grid[2][0] = 5 + 7 = 12`
        (此时 `dp[0]` 代表到达 `(2,0)` 的最小总能耗)
    *   **更新 `j = 1` (`grid[2][1] = 8`)**:
        `dp[1] = min(dp[1](旧值), dp[0](新值)) + grid[2][1]`
        `dp[1] = min(8, 12) + 8 = 8 + 8 = 16`
        (此时 `dp[1]` 代表到达 `(2,1)` 的最小总能耗)
    *   **更新 `j = 2` (`grid[2][2] = 9`)**:
        `dp[2] = min(dp[2](旧值), dp[1](新值)) + grid[2][2]`
        `dp[2] = min(12, 16) + 9 = 12 + 9 = 21`
        (此时 `dp[2]` 代表到达 `(2,2)` 的最小总能耗)
    **当前 `dp = [12, 16, 21]`** (代表到达 `(2,0)`, `(2,1)`, `(2,2)` 的最小总能耗)

最终结果为 `dp[n-1]`，即 `dp[2] = 21`。

 总结

这道“无人机能耗最小化路径规划”问题是经典的二维网格动态规划问题。
*   **O(m*n) 空间解法**：直观易懂，直接构建二维 `dp` 表来存储每个单元格的最小能耗。
*   **O(min(m,n)) 空间优化解法**：通过观察状态依赖性，将空间复杂度降至一维数组，这在网格维度较大时可以节省内存。在实际面试中，如果能给出空间优化的方案，通常会是加分项。











## 2025年8月26日-滴滴-第二题-寻宝之旅-线性dp 

好的，作为一名高级软件工程师，我将为您详细解析这道算法题，提供多种解法，并附上带有详尽注释的 Java 和 Python 代码。

### 题目及分析






第2题-寻宝之旅

题目内容

有一座巨大的宫殿，可以被视为由 $n$ 行 $n$ 列房间组成，从上到下分别为第 $1, 2, ..., n$ 行，从左到右分别为第 $1, 2, ..., n$ 列。第 $i$ 行第 $j$ 列房间内有价值为 $a_{i,j}$ 的宝藏。

每个房间都有一扇通往下一行同一列的常开的门，即从第 $i$ 行第 $j$ 列房间能移动到第 $i + 1$ 行第 $j$ 列房间，但是如果选择带走房间内的宝藏，则该侧门会关闭。特别地，第 $n$ 行的所有房间的通往下一行同一列的门都通往宫殿外。

除此之外，每个房间都有通往同一行下一列的门，即第 $i$ 行第 $j$ 列房间有一扇通往第 $i$ 行第 $j + 1$ 列房间的门，该门不常开，但是如果选择带走房间内的宝藏，则该侧门会打开。特别地，第 $n$ 列的所有房间的通往同一行下一列的门都通往宫殿外。

小钟从第一行第一列房间出发，他想知道在离开宫殿前他最多能带走多少价值的宝藏。请你帮助计算答案。

输入描述

输入包括多组测试数据。

输入第一行包括一个正整数 $T$ ($1 \le T \le 10$)，表示测试数据的组数。

每组测试数据的第一行有一个整数 $n$ ($1 \le n \le 500$)，表示宫殿由 $n$ 行 $n$ 列房间组成；

接下来 $n$ 行，第 $i$ 行有 $n$ 个整数 $a_{i,1}, a_{i,2}, ..., a_{i,n}$ ($0 \le a_{i,j} \le 10^5$)，依次表示第 $i$ 行 $1, 2, ..., n$ 列房间内宝藏的价值大小。

保证每个测试点的所有测试数据的 $n^2$ 的和不超过 $2.5 \times 10^5$。

输出描述

对于每组测试数据，输出一个正整数表示小钟离开宫殿前最多能带走多少价值的宝藏。

样例1

**输入**
```
2
3
1 2 3
4 5 6
7 8 9
2
0 5
3 1
```

**输出**
```
24
5
```

**说明**

对于第一组测试数据，小钟的移动轨迹可以是这样的：$(1,1) \to (2,1) \to (3,1) \to (3,2) \to (3,3) \to $ 宫殿外，分别在 $(3,1), (3,2), (3,3)$ 处带走宝藏，总价值大小为 $7 + 8 + 9 = 24$。

对于第二组测试数据，小钟的移动轨迹可以是这样的：$(1,1) \to (1,2) \to $ 宫殿外，分别在 $(1,1), (1,2)$ 处带走宝藏，总价值大小为 $0 + 5 = 5$。





**分析**


这是一个典型的二维动态规划问题，背景设定在一个 n x n 的宫殿中寻宝。我们需要找到一条从第一行任意房间出发，到宫殿外结束的最佳路径，使得沿途收集的宝藏总价值最高。

首先，我们必须精确地理解移动和获取宝藏的规则：

1.  **宫殿结构**：一个 `n x n` 的网格，房间坐标为 `(i, j)`，`1 ≤ i, j ≤ n`。
2.  **出发点**：第一行的任意一个房间，即 `(1, j)` 之一。
3.  **移动规则**：在任意一个房间 `(i, j)`，你有两种选择，这两种选择是互斥的：
    *   **选择一：向下移动**
        *   不拿取当前房间 `(i, j)` 的宝藏。
        *   移动到下一行同一列的房间 `(i+1, j)`。
        *   这是默认的移动方式，只要不拿宝藏就可以执行。
    *   **选择二：向右移动**
        *   拿取当前房间 `(i, j)` 的宝藏，价值为 `a[i][j]`。
        *   移动到同一行下一列的房间 `(i, j+1)`。
        *   这个移动的前提是必须拿走宝藏。
4.  **边界与出口规则（特殊情况）**：
    *   **最后一行 (第 n 行)**：当位于 `(n, j)` 且 `j < n` 时，无法再向下移动（因为没有 n+1 行了）。因此，唯一的选择是拿走宝藏并向右移动到 `(n, j+1)`。
    *   **最后一列 (第 n 列)**：当位于 `(i, n)` 且 `i < n` 时，无法再向右移动（因为没有 n+1 列了）。但题目特别说明：“第n列的所有房间通往同一行下一列房间的门都通往宫殿外”。这意味着从第 n 列的任何房间都可以直接向“右”离开宫殿。这给了我们一个新的选择：
        *   在 `(i, n)`，可以选择拿走宝藏 `a[i, n]` 直接离开。
        *   也可以选择不拿宝藏，继续向下移动到 `(i+1, n)`。
    *   **右下角 `(n, n)`**：这是路径的终点。无论从 `(n-1, n)` 还是 `(n, n-1)` 到达，都将拿走 `a[n, n]` 的宝藏并结束。

**核心问题**：对于每个房间，都需要做出决策（向下走还是向右走），这个决策会影响后续的路径和收益。由于当前决策依赖于后续决策能带来的最大收益，这完全符合动态规划“最优子结构”和“重叠子问题”的特征。我们可以从终点（出口）倒推回起点，计算出从每个房间出发能获得的最大收益。

---

### 解法一：动态规划 (Dynamic Programming)

 讲解

这是解决此类问题的标准且最高效的方法。我们采用“自底向上”的思路，从出口倒推计算。

1.  **状态定义**：
    `dp[i][j]` 表示：从房间 `(i, j)` 出发，按照规则移动，一直到离开宫殿所能获得的最大宝藏总价值。

2.  **状态转移方程（递推关系）**：
    我们需要从后向前、从下向上、从右向左地填充 `dp` 表。对于一个房间 `(i, j)`，它的 `dp` 值取决于它下一步能走到的房间的 `dp` 值。

    *   **基础情况 (Base Case)**：
        最右下角的房间 `(n, n)`。从这里出发，只能拿走宝藏 `a[n][n]` 然后离开。
        所以：`dp[n][n] = a[n][n]`

    *   **最后一行 (i = n, j < n)**：
        在第 `n` 行的房间 `(n, j)`，无法向下，只能拿宝藏并向右移动到 `(n, j+1)`。因此，从 `(n, j)` 出发的总收益是当前房间的宝藏加上从 `(n, j+1)` 出发能获得的所有收益。
        所以：`dp[n][j] = a[n][j] + dp[n][j+1]`

    *   **最后一列 (j = n, i < n)**：
        在第 `n` 列的房间 `(i, n)`，有两个选择：
        a. 拿走宝藏 `a[i][n]`，然后从右侧的门直接离开。收益为 `a[i][n]`。
        b. 不拿宝藏，向下移动到 `(i+1, n)`。收益为从 `(i+1, n)` 出发能获得的最大收益，即 `dp[i+1, n]`。
        我们选择收益更大的那一个。
        所以：`dp[i][n] = max(a[i][n], dp[i+1, n])`

    *   **一般情况 (i < n, j < n)**：
        在普通房间 `(i, j)`，也有两个选择：
        a. 拿走宝藏 `a[i][j]`，向右移动到 `(i, j+1)`。总收益为 `a[i][j] + dp[i, j+1]`。
        b. 不拿宝藏，向下移动到 `(i+1, j)`。总收益为 `dp[i+1, j]`。
        我们选择收益更大的那一个。
        所以：`dp[i][j] = max(a[i][j] + dp[i, j+1], dp[i+1, j])`

3.  **最终答案**：
    题目要求从从第一行第一列房间出发，所以我们需要计算出从 `(1, 1)`房间出发的最大收益。
    所以：`Answer = dp[1][1]`

 代码 (Java)

为了方便处理边界，代码中使用了 `n+1` 大小的数组，并采用 1-based 索引，与题目描述保持一致。

**核心模式**
```java
import java.util.Arrays;

class Solution {
    /**
     * 计算可以获得的最大宝藏价值
     * @param n 宫殿的尺寸 n x n
     * @param a 存储宝藏价值的二维数组
     * @return 最大宝藏价值
     */
    public long solve(int n, int[][] a) {
        // dp[i][j] 表示从 (i, j) 出发能获得的最大宝藏价值
        // 使用 long 类型防止中间结果溢出
        long[][] dp = new long[n + 1][n + 1];

        // 1. 基础情况: 从右下角 (n, n) 出发
        dp[n][n] = a[n][n];

        // 2. 填充最后一行 (i=n)
        // 从 (n, j) 只能向右走，所以是累加
        for (int j = n - 1; j >= 1; j--) {
            dp[n][j] = a[n][j] + dp[n][j + 1];
        }

        // 3. 填充最后一列 (j=n)
        // 从 (i, n) 可以选择直接带宝藏退出，或者向下走
        for (int i = n - 1; i >= 1; i--) {
            dp[i][n] = Math.max(a[i][n], dp[i + 1][n]);
        }

        // 4. 填充其余部分
        // 从右下角向左上角遍历
        for (int i = n - 1; i >= 1; i--) {
            for (int j = n - 1; j >= 1; j--) {
                // 在 (i, j)，可以选择：
                // a) 向下走 (不拿宝藏): 收益为 dp[i+1][j]
                // b) 向右走 (拿宝藏): 收益为 a[i][j] + dp[i][j+1]
                dp[i][j] = Math.max(dp[i + 1][j], a[i][j] + dp[i][j + 1]);
            }
        }

        
        return dp[1][1];
    }
}
```

**ACM 模式**
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 读取测试用例的数量 T
        int T = sc.nextInt();
        // 循环处理每个测试用例
        while (T-- > 0) {
            // 读取宫殿的大小 n
            int n = sc.nextInt();
            // 创建一个 (n+1)x(n+1) 的数组来存储宝藏价值，使用 1-based 索引
            // a[i][j] 对应题目中的 α(i,j)
            int[][] a = new int[n + 1][n + 1];
            // 循环读取 n 行 n 列的宝藏价值
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    a[i][j] = sc.nextInt();
                }
            }

            // dp[i][j] 表示从 (i, j) 出发能获得的最大宝藏价值
            // 使用 long 类型防止宝藏价值总和超过 int 的范围
            long[][] dp = new long[n + 1][n + 1];

            // 状态转移计算过程
            // 1. 基础情况: 初始化右下角 (n, n)
            dp[n][n] = a[n][n];

            // 2. 填充最后一行 (i=n)
            // 从 (n, j) 只能向右走，所以价值是当前宝藏加上右边格子的dp值
            for (int j = n - 1; j >= 1; j--) {
                dp[n][j] = a[n][j] + dp[n][j + 1];
            }

            // 3. 填充最后一列 (j=n)
            // 从 (i, n) 可以选择:
            // a) 带上当前宝藏 a[i][n] 直接离开
            // b) 不带宝藏，向下走到 (i+1, n)，获得 dp[i+1][n] 的收益
            // 取两者中的最大值
            for (int i = n - 1; i >= 1; i--) {
                dp[i][n] = Math.max(a[i][n], dp[i + 1][n]);
            }

            // 4. 填充dp表的其余部分
            // 从右下角开始，向上、向左进行计算
            for (int i = n - 1; i >= 1; i--) {
                for (int j = n - 1; j >= 1; j--) {
                    // 在 (i, j) 处，可以选择:
                    // a) 向下走 (不拿宝藏): 收益为从 (i+1, j) 出发的最大收益 dp[i+1][j]
                    // b) 向右走 (拿宝藏): 收益为当前宝藏 a[i][j] 加上从 (i, j+1) 出发的最大收益 dp[i][j+1]
                    // 取两者中的最大值
                    dp[i][j] = Math.max(dp[i + 1][j], a[i][j] + dp[i][j + 1]);
                }
            }

            // 输出当前测试用例的结果
            System.out.println(dp[1][1]);
        }
        sc.close();
    }
}
```

 代码 (Python)

**核心模式**
```python
from typing import List

class Solution:
    """
    计算可以获得的最大宝藏价值
    """
    def solve(self, n: int, a: List[List[int]]) -> int:
        # dp[i][j] 表示从 (i, j) 出发能获得的最大宝藏价值
        # 创建一个 (n+1)x(n+1) 的dp表，并初始化为0，使用 1-based 索引
        # 注意：输入的 a 可能是 0-based，这里假设传入的 a 也是 n+1 x n+1 且 1-based
        dp = [[0] * (n + 1) for _ in range(n + 1)]

        # 1. 基础情况: 从右下角 (n, n) 出发
        dp[n][n] = a[n][n]

        # 2. 填充最后一行 (i=n)
        # 从 (n, j) 只能向右走，所以是累加
        for j in range(n - 1, 0, -1):
            dp[n][j] = a[n][j] + dp[n][j + 1]

        # 3. 填充最后一列 (j=n)
        # 从 (i, n) 可以选择直接带宝藏退出，或者向下走
        for i in range(n - 1, 0, -1):
            dp[i][n] = max(a[i][n], dp[i + 1][n])

        # 4. 填充其余部分
        # 从右下角向左上角遍历
        for i in range(n - 1, 0, -1):
            for j in range(n - 1, 0, -1):
                # 在 (i, j)，可以选择：
                # a) 向下走 (不拿宝藏): 收益为 dp[i+1][j]
                # b) 向右走 (拿宝藏): 收益为 a[i][j] + dp[i][j+1]
                dp[i][j] = max(dp[i + 1][j], a[i][j] + dp[i][j + 1])

        # 5. 寻找最终答案
        # 答案是第一行第一间房的 dp 值
        return dp[1][1]
```

**ACM 模式**
```python
import sys

def main():
    """
    处理多组测试用例的主函数
    """
    # 读取所有输入行
    lines = sys.stdin.readlines()
    # 使用一个指针来追踪当前处理到哪一行
    line_idx = 0
    
    # 读取测试用例的数量 T
    T = int(lines[line_idx].strip())
    line_idx += 1

    # 循环处理每个测试用例
    for _ in range(T):
        # 读取宫殿的大小 n
        n = int(lines[line_idx].strip())
        line_idx += 1
        
        # 创建一个 (n+1)x(n+1) 的数组来存储宝藏价值，使用 1-based 索引
        # a[i][j] 对应题目中的 α(i,j)
        a = [[0] * (n + 1) for _ in range(n + 1)]
        # 循环读取 n 行 n 列的宝藏价值
        for i in range(1, n + 1):
            row_vals = list(map(int, lines[line_idx].strip().split()))
            for j in range(1, n + 1):
                a[i][j] = row_vals[j - 1]
            line_idx += 1

        # dp[i][j] 表示从 (i, j) 出发能获得的最大宝藏价值
        dp = [[0] * (n + 1) for _ in range(n + 1)]

        # 状态转移计算过程
        # 1. 基础情况: 初始化右下角 (n, n)
        dp[n][n] = a[n][n]

        # 2. 填充最后一行 (i=n)
        # 从 (n, j) 只能向右走，所以价值是当前宝藏加上右边格子的dp值
        for j in range(n - 1, 0, -1):
            dp[n][j] = a[n][j] + dp[n][j + 1]

        # 3. 填充最后一列 (j=n)
        # 从 (i, n) 可以选择带上当前宝藏 a[i][n] 直接离开，或者不带宝藏向下走到 (i+1, n)
        for i in range(n - 1, 0, -1):
            dp[i][n] = max(a[i][n], dp[i + 1][n])

        # 4. 填充dp表的其余部分
        # 从右下角开始，向上、向左进行计算
        for i in range(n - 1, 0, -1):
            for j in range(n - 1, 0, -1):
                # 在 (i, j) 处，可以选择向下走(不拿宝藏)或向右走(拿宝藏)
                go_down_val = dp[i + 1][j]
                go_right_val = a[i][j] + dp[i][j + 1]
                dp[i][j] = max(go_down_val, go_right_val)

        # 5. 寻找并打印最终答案
        # 答案是第一行第一间房的 dp 值
        print(dp[1][1])

if __name__ == "__main__":
    main()
```

 示例演示

我们使用第一个样例数据来逐步演示 DP 表的填充过程。

**输入:**
n = 3
宝藏矩阵 `a`:
1 2 3
4 5 6
7 8 9

**DP 计算过程:**

1.  **初始化 DP 表** (3x3，值为0):
    ```
    0 0 0
    0 0 0
    0 0 0
    ```

2.  **计算基础情况 `dp[3][3]`**:
    `dp[3][3] = a[3][3] = 9`
    DP 表:
    ```
    0 0 0
    0 0 0
    0 0 9
    ```

3.  **计算最后一行 (i=3)**:
    
    *   `dp[3][2] = a[3][2] + dp[3][3] = 8 + 9 = 17`
    *   `dp[3][1] = a[3][1] + dp[3][2] = 7 + 17 = 24`
    DP 表:
    ```
    0 0 0
    0 0 0
    24 17 9
    ```
```
    
4.  **计算最后一列 (j=3)**:
    *   `dp[2][3] = max(a[2][3], dp[3][3]) = max(6, 9) = 9`
    *   `dp[1][3] = max(a[1][3], dp[2][3]) = max(3, 9) = 9`
    DP 表:
```
    0 0 9
    0 0 9
    24 17 9
    ```

5.  **计算剩余格子 (从右下到左上)**:
    *   `dp[2][2] = max(dp[3][2], a[2][2] + dp[2][3]) = max(17, 5 + 9) = max(17, 14) = 17`
    *   `dp[2][1] = max(dp[3][1], a[2][1] + dp[2][2]) = max(24, 4 + 17) = max(24, 21) = 24`
    *   `dp[1][2] = max(dp[2][2], a[1][2] + dp[1][3]) = max(17, 2 + 9) = max(17, 11) = 17`
    *   `dp[1][1] = max(dp[2][1], a[1][1] + dp[1][2]) = max(24, 1 + 17) = max(24, 18) = 24`

6.  **最终 DP 表**:
    ```
    24 17 9
    24 17 9
    24 17 9
    ```

7.  **确定答案**:
    答案是第一行第一间房的 dp 值：`dp[1][1] = 24`。
    这与样例输出一致。这个 24 对应的路径就是从 `(1,1)` 出发，一直向下走到 `(3,1)`，然后拿宝藏 `7`，向右到 `(3,2)`，拿宝藏 `8`，向右到 `(3,3)`，拿宝藏 `9`，然后离开。总价值 `7 + 8 + 9 = 24`。















## [2025年9月6日-小米开发岗-第二题-迷宫速通]-
好的，作为一名高级软件工程师，我将为您详细解析这道“迷宫速通”算法题。

### 题目及分析



第2题-迷宫速通

题目内容

这是一个经典的 $N$ 行 $M$ 列的二维迷宫，每个格子有一个整数，代表这个格子的“奖励”或“惩罚”。

玩家从最左上角的格子 $(1,1)$ 出发，目的地是最右下角的格子 $(N,M)$，并且玩家只能向右或向下走。玩家在游戏开始时积分分为 $0$，并且每到一个格子（包括起始位置和终点位置），都需要把当前积分加上这个格子对应的整数（显然，整数为正就是“奖励”，若为负就是“惩罚”）。当玩家在任意时刻积分分为 $0$ 或负数时，就输掉了游戏。

马老师是玩迷宫速通的老玩家，他想到：如果格子 $(1,1)$ 对应的整数是负数，就会在游戏一开始就直接输掉游戏，有辱他的一世英名。幸好，马老师具有高超的编程技巧，一眼就能看出如果他使用黑客技术把玩家初始积分设置为 $x$，就可以通过游戏。

聪明的马老师想考考你，$x$ 最小可以是多少。

输入描述

第一行 $1$ 个整数 $T$ ($1 \le T \le 5$)，代表数据组数。
接下来一共是 $T$ 组数据，对于每组数据：
第一行包含两个整数 $N$ 和 $M$ ($1 \le N, M \le 500$)。
接下来 $N$ 行，每行包含 $M$ 个数字 $a_{ij}$ ($-1000 \le a_{ij} \le 1000$)，代表题目描述的 $N$ 行 $M$ 列的二维迷宫中每个格子对应的整数。

输出描述

输出 $T$ 行，每行 $1$ 个整数，代表 $T$ 组输入数据对应的答案。

样例1

**输入**
```
1
2 3
0 1 -3
1 -2 0
```

**输出**
```
2
```

**说明**
如果玩家初始积分为 $1$，那不管怎么走都会在迷宫中间输掉游戏，所以最少需要 $2$ 个积分。



**分析**


这道题本质上是经典 "Dungeon Game" (地下城游戏) 问题的变体。我们需要在一个 `N x M` 的网格中，从左上角 `(1, 1)` 移动到右下角 `(N, M)`，移动方向只能是向右或向下。每个格子有一个整数，代表得分或扣分。我们的目标是找到一个最小的初始积分 `x`，使得从起点到终点的任意一条路径上，玩家的积分始终大于 0。

**核心挑战分析：**

1.  **不是求路径最大和**：这题和传统的“最大路径和”问题不同。一条路径最终得分很高，但中间可能有一个点的积分降到了 0 或以下，导致游戏失败。例如，初始积分 `x=5`，路径是 `-10, +100`，在第一步积分就变成了 `-5`，游戏失败，即使最终能达到很高的分数。
2.  **“存活”是首要条件**：关键在于路径上的“最低点”。我们需要保证在每一步，`当前积分 + 格子值 > 0`。
3.  **逆向思维**：正向思考（从 `(1,1)` 到 `(N,M)`）会很困难。因为在任意点 `(i, j)`，我们不仅需要知道到达这里的最大积分，还需要知道为了达到这个最大积分，路径上的最低积分是多少，状态定义会变得非常复杂。而如果我们**从终点 `(N, M)` 反向推导回起点 `(1, 1)`**，问题会变得清晰。我们可以思考：“要想到达终点并存活，我在上一个格子 `(N-1, M)` 或 `(N, M-1)` 时，至少需要多少积分？”

---

### 解法一：动态规划 (自底向上)

 讲解

这是解决此类问题的最优且最直接的方法。我们采用逆向思维，从终点 `(N, M)` 向起点 `(1, 1)` 进行动态规划。

1.  **状态定义**：
    `dp[i][j]` 表示：从格子 `(i, j)` 出发，安全到达终点 `(N, M)` 所需要的**最小初始积分**。我们的最终目标就是求 `dp[1][1]`。

2.  **状态转移方程（递推关系）**：
    我们从右下角开始，向左、向上填充 `dp` 表。

    *   **基础情况 (Base Case) - 终点 `(N, M)`**：
        假设我们在终点 `(N, M)` 时，需要的积分为 `dp[N][M]`。进入这个格子后，我们的积分变为 `dp[N][M] + a[N][M]`。为了存活，这个值必须 `≥ 1`。
        所以 `dp[N][M] + a[N][M] ≥ 1`，即 `dp[N][M] ≥ 1 - a[N][M]`。
        因为 `dp[N][M]` 是积分，它本身也必须 `≥ 1`。所以，我们取这两者的最大值。
        `dp[N][M] = max(1, 1 - a[N][M])`

    *   **最后一行 (i = N, j < M)**：
        在 `(N, j)` 这个格子，我们只能向右移动到 `(N, j+1)`。从 `(N, j+1)` 出发到终点，我们至少需要 `dp[N][j+1]` 的积分。
        那么，在进入 `(N, j)` 之前，我们需要的积分 `dp[N][j]` 必须满足：`dp[N][j] + a[N][j] ≥ dp[N][j+1]`。
        即 `dp[N][j] ≥ dp[N][j+1] - a[N][j]`。
        同样，`dp[N][j]` 自身也必须 `≥ 1`。
        `dp[N][j] = max(1, dp[N][j+1] - a[N][j])`

    *   **最后一列 (j = M, i < N)**：
        在 `(i, M)` 这个格子，我们只能向下移动到 `(i+1, M)`。逻辑同上。
        `dp[i][M] = max(1, dp[i+1][M] - a[i][M])`

    *   **一般情况 (i < N, j < M)**：
        在 `(i, j)`，我们可以选择向下走到 `(i+1, j)` 或者向右走到 `(i, j+1)`。为了保证能存活，我们会选择那条**后续所需积分更少**的路径。
        从 `(i+1, j)` 出发需要 `dp[i+1][j]` 的积分。
        从 `(i, j+1)` 出发需要 `dp[i][j+1]` 的积分。
        我们会选择更优的，即 `min(dp[i+1][j], dp[i][j+1])`。
        设 `needed_for_future = min(dp[i+1][j], dp[i][j+1])`。
        那么在进入 `(i, j)` 之前，我们需要的积分 `dp[i][j]` 必须满足：`dp[i][j] + a[i][j] ≥ needed_for_future`。
        即 `dp[i][j] ≥ needed_for_future - a[i][j]`。
        结合 `dp[i][j] ≥ 1` 的条件：
        `dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - a[i][j])`

3.  **最终答案**：
    通过以上递推关系，我们从右下角一直计算到左上角，`dp[1][1]` 就是我们要求的最小初始积分 `x`。

 代码 (Java)

**核心模式**
```java
class Solution {
    /**
     * 计算通关迷宫所需的最小初始积分
     * @param N 迷宫的行数
     * @param M 迷宫的列数
     * @param a 存储迷宫奖励/惩罚值的二维数组 (0-based index)
     * @return 最小初始积分
     */
    public int solve(int N, int M, int[][] a) {
        // dp[i][j] 表示从 (i, j) 出发到达终点所需的最小初始积分
        int[][] dp = new int[N][M];

        // 1. 基础情况: 计算终点 (N-1, M-1) 所需的最小积分
        // 记 a[i][j] 为 grid[i][j]
        // 到达 (N-1, M-1) 后，积分需要 >= 1，即 dp[N-1][M-1] + a[N-1][M-1] >= 1
        // 所以 dp[N-1][M-1] >= 1 - a[N-1][M-1]
        // 同时，初始积分本身不能小于1
        dp[N - 1][M - 1] = Math.max(1, 1 - a[N - 1][M - 1]);

        // 2. 填充最后一行 (从右到左)
        for (int j = M - 2; j >= 0; j--) {
            // 从 (N-1, j) 只能到 (N-1, j+1)
            // 需要的积分 dp[N-1][j] 必须满足 dp[N-1][j] + a[N-1][j] >= dp[N-1][j+1]
            dp[N - 1][j] = Math.max(1, dp[N - 1][j + 1] - a[N - 1][j]);
        }

        // 3. 填充最后一列 (从下到上)
        for (int i = N - 2; i >= 0; i--) {
            // 从 (i, M-1) 只能到 (i+1, M-1)
            // 需要的积分 dp[i][M-1] 必须满足 dp[i][M-1] + a[i][M-1] >= dp[i+1][M-1]
            dp[i][M - 1] = Math.max(1, dp[i + 1][M - 1] - a[i][M - 1]);
        }

        // 4. 填充其余部分 (从右下到左上)
        for (int i = N - 2; i >= 0; i--) {
            for (int j = M - 2; j >= 0; j--) {
                // 从 (i, j) 可以到 (i+1, j) 或 (i, j+1)
                // 选择后续所需积分较小的路径
                int minNeedForFuture = Math.min(dp[i + 1][j], dp[i][j + 1]);
                // 计算当前点所需的最小积分
                dp[i][j] = Math.max(1, minNeedForFuture - a[i][j]);
            }
        }

        // 5. 最终答案在左上角
        return dp[0][0];
    }
}
```

**ACM 模式**
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 读取测试用例的数量 T
        int T = sc.nextInt();
        while (T-- > 0) {
            // 读取迷宫的行数 N 和列数 M
            int N = sc.nextInt();
            int M = sc.nextInt();
            // 创建二维数组存储迷宫数据 (使用 0-based 索引)
            int[][] a = new int[N][M];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    a[i][j] = sc.nextInt();
                }
            }

            // dp[i][j] 表示从 (i, j) 出发安全到达终点所需的最小初始积分
            int[][] dp = new int[N][M];

            // 1. 基础情况: 终点 (N-1, M-1)
            // 在该点存活，需要 dp + a >= 1，所以 dp >= 1 - a
            // 同时 dp 本身必须 >= 1
            dp[N - 1][M - 1] = Math.max(1, 1 - a[N - 1][M - 1]);

            // 2. 填充最后一行 (从右向左)
            for (int j = M - 2; j >= 0; j--) {
                // 从 (N-1, j) 只能向右到 (N-1, j+1)
                // 为了能满足 (N-1, j+1) 的最低积分要求 dp[N-1][j+1]，
                // 在 (N-1, j) 之前需要的积分 dp[N-1][j] 必须满足:
                // dp[N-1][j] + a[N-1][j] >= dp[N-1][j+1]
                dp[N - 1][j] = Math.max(1, dp[N - 1][j + 1] - a[N - 1][j]);
            }

            // 3. 填充最后一列 (从下向上)
            for (int i = N - 2; i >= 0; i--) {
                // 从 (i, M-1) 只能向下到 (i+1, M-1)，逻辑同上
                dp[i][M - 1] = Math.max(1, dp[i + 1][M - 1] - a[i][M - 1]);
            }

            // 4. 填充内部格子 (从右下到左上)
            for (int i = N - 2; i >= 0; i--) {
                for (int j = M - 2; j >= 0; j--) {
                    // 从 (i, j) 出发，可以选择向下或向右
                    // 我们选择后续路径所需积分更少的那一条
                    int minNeedForFuture = Math.min(dp[i + 1][j], dp[i][j + 1]);
                    // 计算当前点 (i, j) 所需的最小积分
                    dp[i][j] = Math.max(1, minNeedForFuture - a[i][j]);
                }
            }
            
            // 最终答案即为从起点 (0,0) 出发所需的最小积分
            System.out.println(dp[0][0]);
        }
        sc.close();
    }
}
```

 代码 (Python)

**核心模式**
```python
from typing import List

class Solution:
    """
    计算通关迷宫所需的最小初始积分
    """
    def solve(self, N: int, M: int, a: List[List[int]]) -> int:
        # dp[i][j] 表示从 (i, j) 出发到达终点所需的最小初始积分
        dp = [[0] * M for _ in range(N)]

        # 1. 基础情况: 计算终点 (N-1, M-1) 所需的最小积分
        # 到达 (N-1, M-1) 后，积分需要 >= 1，即 dp + a >= 1
        # 所以 dp >= 1 - a。同时，初始积分本身不能小于1
        dp[N - 1][M - 1] = max(1, 1 - a[N - 1][M - 1])

        # 2. 填充最后一行 (从右到左)
        for j in range(M - 2, -1, -1):
            # 从 (N-1, j) 只能到 (N-1, j+1)
            # dp[N-1][j] + a[N-1][j] >= dp[N-1][j+1]
            dp[N - 1][j] = max(1, dp[N - 1][j + 1] - a[N - 1][j])

        # 3. 填充最后一列 (从下到上)
        for i in range(N - 2, -1, -1):
            # 从 (i, M-1) 只能到 (i+1, M-1)
            # dp[i][M-1] + a[i][M-1] >= dp[i+1][M-1]
            dp[i][M - 1] = max(1, dp[i + 1][M - 1] - a[i][M - 1])

        # 4. 填充其余部分 (从右下到左上)
        for i in range(N - 2, -1, -1):
            for j in range(M - 2, -1, -1):
                # 从 (i, j) 可以到 (i+1, j) 或 (i, j+1)
                # 选择后续所需积分较小的路径
                min_need_for_future = min(dp[i + 1][j], dp[i][j + 1])
                # 计算当前点所需的最小积分
                dp[i][j] = max(1, min_need_for_future - a[i][j])

        # 5. 最终答案在左上角
        return dp[0][0]

```

**ACM 模式**
```python
import sys

def solve():
    """
    单个测试用例的解决函数
    """
    # 读取行数 N 和列数 M
    try:
        line = sys.stdin.readline()
        if not line: return
        N, M = map(int, line.strip().split())
    except (IOError, ValueError):
        return

    # 读取迷宫数据
    a = []
    for _ in range(N):
        a.append(list(map(int, sys.stdin.readline().strip().split())))

    # dp[i][j] 表示从 (i, j) 出发到达终点所需的最小初始积分
    dp = [[0] * M for _ in range(N)]

    # 1. 基础情况: 终点 (N-1, M-1)
    dp[N - 1][M - 1] = max(1, 1 - a[N - 1][M - 1])

    # 2. 填充最后一行
    for j in range(M - 2, -1, -1):
        dp[N - 1][j] = max(1, dp[N - 1][j + 1] - a[N - 1][j])

    # 3. 填充最后一列
    for i in range(N - 2, -1, -1):
        dp[i][M - 1] = max(1, dp[i + 1][M - 1] - a[i][M - 1])

    # 4. 填充内部格子
    for i in range(N - 2, -1, -1):
        for j in range(M - 2, -1, -1):
            min_need_for_future = min(dp[i + 1][j], dp[i][j + 1])
            dp[i][j] = max(1, min_need_for_future - a[i][j])

    # 打印结果
    print(dp[0][0])

def main():
    """
    主函数，处理多组测试用
    """
    try:
        T_str = sys.stdin.readline()
        if not T_str: return
        T = int(T_str.strip())
        for _ in range(T):
            solve()
    except (IOError, ValueError):
        return

if __name__ == "__main__":
    main()

```

 示例演示

我们使用题目给的样例数据来逐步演示 DP 表的填充过程。

**输入:**
N = 2, M = 3
迷宫矩阵 `a`:
0   1  -3
1  -2   0

**DP 计算过程 (使用 0-based 索引):**

1.  **初始化 DP 表** (2x3，值为0):
    ```
    0 0 0
    0 0 0
    ```

2.  **计算基础情况 `dp[1][2]` (终点)**:
    `a[1][2] = 0`
    `dp[1][2] = max(1, 1 - a[1][2]) = max(1, 1 - 0) = 1`
    DP 表:
    ```
    0 0 0
    0 0 1
    ```

3.  **计算最后一行 (i=1)**:
    *   `dp[1][1]` (从右向左):
        `a[1][1] = -2`
        `dp[1][1] = max(1, dp[1][2] - a[1][1]) = max(1, 1 - (-2)) = max(1, 3) = 3`
    *   `dp[1][0]`:
        `a[1][0] = 1`
        `dp[1][0] = max(1, dp[1][1] - a[1][0]) = max(1, 3 - 1) = max(1, 2) = 2`
    DP 表:
    ```
    0 0 0
    2 3 1
    ```

4.  **计算最后一列 (j=2)**:
    *   `dp[0][2]` (从下向上):
        `a[0][2] = -3`
        `dp[0][2] = max(1, dp[1][2] - a[0][2]) = max(1, 1 - (-3)) = max(1, 4) = 4`
    DP 表:
    ```
    0 0 4
    2 3 1
    ```

5.  **计算剩余格子 (从右下到左上)**:
    *   `dp[0][1]`:
        `a[0][1] = 1`
        `needed_for_future = min(dp[1][1], dp[0][2]) = min(3, 4) = 3`
        `dp[0][1] = max(1, needed_for_future - a[0][1]) = max(1, 3 - 1) = max(1, 2) = 2`
    *   `dp[0][0]` (最终答案):
        `a[0][0] = 0`
        `needed_for_future = min(dp[1][0], dp[0][1]) = min(2, 2) = 2`
        `dp[0][0] = max(1, needed_for_future - a[0][0]) = max(1, 2 - 0) = max(1, 2) = 2`

6.  **最终 DP 表**:
    ```
    2 2 4
    2 3 1
    ```

7.  **确定答案**:
    答案是 `dp[0][0] = 2`。这与样例输出一致。这意味着，我们至少需要 2 个初始积分才能保证安全通关。

---

### 解法二：二分答案 + DP/BFS (可行性检查)

 讲解

这道题的答案具有**单调性**：如果 `x` 点初始积分可以通关，那么 `x+1` 点初始积分一定也可以通关。如果 `x` 点无法通关，那么 `x-1` 点也一定无法通关。这种单调性是使用**二分查找**来解决问题的完美信号。

我们可以二分查找最终的答案 `x`。对于每一个猜测的 `mid` 值，我们去验证 "以 `mid` 作为初始积分，是否能够通关？"。

1.  **二分框架**：
    *   确定答案的范围。下界 `left = 1`。上界 `right` 可以是一个足够大的数，比如所有负数惩罚之和的绝对值再加 1，或者一个保守的 `N*M*1000 + 1`。
    *   在 `[left, right]` 范围内进行二分。
    *   `mid = left + (right - left) / 2`。
    *   调用 `check(mid)` 函数判断可行性。
    *   如果 `check(mid)` 为 `true`，说明 `mid` 可能是一个解，但我们想找最小的，所以尝试更小的值：`ans = mid`, `right = mid - 1`。
    *   如果 `check(mid)` 为 `false`，说明 `mid` 太小了，需要更大的初始积分：`left = mid + 1`。

2.  **`check(x)` 函数实现**：
    这个函数的作用是判断以 `x` 为初始积分是否能通关。这本身就是一个可以用 DP 或 BFS 解决的路径问题。我们这里用 DP 来实现。

    *   **状态定义**: `dp_check[i][j]` 表示以 `x` 为初始积分，到达格子 `(i, j)` 时能获得的**最大积分**。
    *   **状态转移**:
        *   `dp_check[0][0] = x + a[0][0]`。如果此时 `≤ 0`，则 `x` 不可行。
        *   `dp_check[i][j] = max(dp_check[i-1][j], dp_check[i][j-1]) + a[i][j]`。
        *   在计算 `max` 时，我们只能从可达的上边和左边格子转移过来。一个格子 `(r, c)` 是可达的，当且仅当 `dp_check[r][c] > 0`。如果 `dp_check[i-1][j]` 和 `dp_check[i][j-1]` 都 `≤ 0`（或无法到达），那么 `(i, j)` 也无法到达。
    *   **结果**: 如果最终 `dp_check[N-1][M-1] > 0`，说明存在一条路径可以通关，`check(x)` 返回 `true`。

这种方法虽然逻辑上可行，但通常比解法一慢，因为它需要多次执行 `check` 函数，而每次 `check` 都是一次 `O(N*M)` 的 DP。总时间复杂度为 `O(N*M * log(Range))`。对于本题的数据范围，解法一 `O(N*M)` 已经足够快且更简洁。因此，这里不再提供该解法的完整代码，但理解其思想对于拓宽解题思路非常有帮助。

















# 模拟




## 2025年9月28日-网易-第一题-有序序列-基础语法




### 完整题目

**题目内容**
输入一个整数序列，判断是否是有序序列，有序，指序列中的整数从小到大排序或者从大到小排序(相同元素也视为有序)。
数据范围：`3 <= n <= 50` 序列中的值都满足 `1 <= val <= 100`

**输入描述**
第一行输入一个整数N(3 <= N <= 50)。
第二行输入N个整数，用空格分隔 N 个整数。

**输出描述**
输出为一行，如果序列有序输出 `sorted`，否则输出 `unsorted`。

**样例1**
输入
```
5
1 6 9 22 30
```
输出
```
sorted
```

**样例2**
输入
```
5
3 4 7 2 10
```
输出
```
unsorted
```

**样例3**
输入
```
5
1 1 1 1 1
```
输出
```
sorted
```

---

### 分析解读

这个题目要求我们判断一个给定的整数序列是否“有序”。这里的“有序”有两种情况：
1.  **从小到大排序**：也就是我们常说的“升序”。需要注意的是，题目明确说了“相同元素也视为有序”。这意味着 `1 2 2 3` 这样的序列是升序的，因为它满足每个元素都**不小于**前一个元素（即 `arr[i] >= arr[i-1]`）。我们更准确地称之为“非递减序列”。
2.  **从大到小排序**：也就是我们常说的“降序”。同样，`3 2 2 1` 这样的序列是降序的，因为它满足每个元素都**不大于**前一个元素（即 `arr[i] <= arr[i-1]`）。我们更准确地称之为“非递增序列”。

只要序列满足这两种情况中的**任意一种**，我们就认为它是有序的，输出 `sorted`。如果两种情况都不满足，则输出 `unsorted`。

**输入输出格式 (ACM模式)**：
*   第一行是一个整数 `N`，表示序列的长度。
*   第二行是 `N` 个整数，用空格分隔。我们需要读取这两行数据。
*   输出一行字符串 `sorted` 或 `unsorted`。

**数据范围**：
*   `N` 的范围是 `3` 到 `50`，这意味着序列至少有3个元素，最多50个元素。这个范围很小，所以即使是简单的循环遍历，效率也足够高。
*   序列中的值 `val` 范围是 `1` 到 `100`，这不影响我们判断有序性的逻辑，只是告诉你每个数字的大小。

---

### 解法一：分别判断非递减和非递增

**讲解**

这种方法最直观，也最容易理解。我们将问题拆分成两个子问题：
1.  判断序列是否为非递减（升序）。
2.  判断序列是否为非递增（降序）。

我们分别写两个函数来完成这两个判断。如果其中任何一个函数返回 `True`，那么整个序列就是有序的。

**核心思路：**
*   **判断非递减（is_non_decreasing）**：遍历序列，从第二个元素开始（索引 `i` 从 `1` 到 `N-1`）。如果发现任何一个元素 `arr[i]` 小于前一个元素 `arr[i-1]`，那么它就不是非递减的，立即返回 `False`。如果循环结束都没有返回 `False`，说明它是非递减的，返回 `True`。
*   **判断非递增（is_non_increasing）**：同样遍历序列，从第二个元素开始。如果发现任何一个元素 `arr[i]` 大于前一个元素 `arr[i-1]`，那么它就不是非递增的，立即返回 `False`。如果循环结束都没有返回 `False`，说明它是非递增的，返回 `True`。
*   **主逻辑**：调用 `is_non_decreasing`。如果返回 `True`，则输出 `sorted`。否则，再调用 `is_non_increasing`。如果返回 `True`，也输出 `sorted`。如果两个都返回 `False`，则输出 `unsorted`。

**ACM模式注意事项：**
*   需要从标准输入读取 `N` 和序列元素。
*   需要向标准输出打印结果。

---

#### Java 版核心模式与 ACM 模式完整代码

```java
import java.util.Scanner; // 导入Scanner类，用于从标准输入读取数据

public class Main { // 定义一个公共类Main，这是Java程序的入口

    // 方法1：判断一个整数数组是否为非递减序列（即升序，允许相同元素）
    // 例如：1 2 2 3 是非递减；1 3 2 就不是非递减
    public static boolean isNonDecreasing(int[] arr) {
        // 从数组的第二个元素开始遍历，因为我们要比较当前元素和它前面的元素
        // 数组索引从0开始，所以第二个元素的索引是1
        for (int i = 1; i < arr.length; i++) {
            // 如果当前元素 arr[i] 小于它前面的元素 arr[i-1]
            // 这就违反了非递减的规则（要求 arr[i] >= arr[i-1]）
            if (arr[i] < arr[i - 1]) {
                return false; // 发现一个递减的情况，立即返回false，表示不是非递减序列
            }
        }
        // 如果循环结束都没有发现递减的情况，说明整个序列都是非递减的
        return true; // 返回true，表示是非递减序列
    }

    // 方法2：判断一个整数数组是否为非递增序列（即降序，允许相同元素）
    // 例如：3 2 2 1 是非递增；3 1 2 就不是非递增
    public static boolean isNonIncreasing(int[] arr) {
        // 同样从数组的第二个元素开始遍历
        for (int i = 1; i < arr.length; i++) {
            // 如果当前元素 arr[i] 大于它前面的元素 arr[i-1]
            // 这就违反了非递增的规则（要求 arr[i] <= arr[i-1]）
            if (arr[i] > arr[i - 1]) {
                return false; // 发现一个递增的情况，立即返回false，表示不是非递增序列
            }
        }
        // 如果循环结束都没有发现递增的情况，说明整个序列都是非递增的
        return true; // 返回true，表示是非递增序列
    }

    // Java程序的入口方法
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象，用于读取控制台输入

        // 读取第一行的整数N，表示序列的长度
        int N = scanner.nextInt();

        // 创建一个整数数组来存储N个整数
        int[] arr = new int[N];

        // 读取第二行的N个整数，并存储到数组中
        for (int i = 0; i < N; i++) {
            arr[i] = scanner.nextInt();
        }

        scanner.close(); // 关闭Scanner对象，释放资源

        // 判断序列是否为非递减 或者 是否为非递增
        // 只要满足其中一个条件，就认为是有序的
        if (isNonDecreasing(arr) || isNonIncreasing(arr)) {
            System.out.println("sorted"); // 如果是有序的，输出 "sorted"
        } else {
            System.out.println("unsorted"); // 如果无序，输出 "unsorted"
        }
    }
}
```

---

#### Python 版核心模式与 ACM 模式完整代码

```python
import sys # 导入sys模块，用于读取标准输入

# 函数1：判断一个整数列表是否为非递减序列（即升序，允许相同元素）
# 例如：[1, 2, 2, 3] 是非递减；[1, 3, 2] 就不是非递减
def is_non_decreasing(arr):
    # 从列表的第二个元素开始遍历，因为我们要比较当前元素和它前面的元素
    # 列表索引从0开始，所以第二个元素的索引是1
    for i in range(1, len(arr)):
        # 如果当前元素 arr[i] 小于它前面的元素 arr[i-1]
        # 这就违反了非递减的规则（要求 arr[i] >= arr[i-1]）
        if arr[i] < arr[i - 1]:
            return False # 发现一个递减的情况，立即返回False，表示不是非递减序列
    # 如果循环结束都没有发现递减的情况，说明整个序列都是非递减的
    return True # 返回True，表示是非递减序列

# 函数2：判断一个整数列表是否为非递增序列（即降序，允许相同元素）
# 例如：[3, 2, 2, 1] 是非递增；[3, 1, 2] 就不是非递增
def is_non_increasing(arr):
    # 同样从列表的第二个元素开始遍历
    for i in range(1, len(arr)):
        # 如果当前元素 arr[i] 大于它前面的元素 arr[i-1]
        # 这就违反了非递增的规则（要求 arr[i] <= arr[i-1]）
        if arr[i] > arr[i - 1]:
            return False # 发现一个递增的情况，立即返回False，表示不是非递增序列
    # 如果循环结束都没有发现递增的情况，说明整个序列都是非递增的
    return True # 返回True，表示是非递增序列

# ACM 模式主程序入口
if __name__ == "__main__":
    # 读取第一行的整数N，表示序列的长度
    # sys.stdin.readline().strip() 用于读取一行输入并去除末尾的换行符
    # int() 将字符串转换为整数
    N = int(sys.stdin.readline().strip())

    # 读取第二行的N个整数，用空格分隔
    # sys.stdin.readline().strip().split() 将一行字符串按空格分割成字符串列表
    # map(int, ...) 将列表中的每个字符串转换为整数
    # list(...) 将map对象转换为列表
    arr = list(map(int, sys.stdin.readline().strip().split()))

    # 判断序列是否为非递减 或者 是否为非递增
    # 只要满足其中一个条件，就认为是有序的
    if is_non_decreasing(arr) or is_non_increasing(arr):
        print("sorted") # 如果是有序的，输出 "sorted"
    else:
        print("unsorted") # 如果无序，输出 "unsorted"

```

---

#### 示例演示 (以 `3 4 7 2 10` 为例)

我们来手动模拟一下 `N = 5`, `arr = [3, 4, 7, 2, 10]` 这个例子，看看代码是如何运行的。

1.  **输入读取**
    *   `N` 会被读取为 `5`。
    *   `arr` 会被读取为 `[3, 4, 7, 2, 10]`。

2.  **`is_non_decreasing(arr)` 调用：**
    *   `arr = [3, 4, 7, 2, 10]`
    *   `i = 1`: `arr[1]` (4) vs `arr[0]` (3)。`4 < 3` 是 `False`。继续。
    *   `i = 2`: `arr[2]` (7) vs `arr[1]` (4)。`7 < 4` 是 `False`。继续。
    *   `i = 3`: `arr[3]` (2) vs `arr[2]` (7)。`2 < 7` 是 `True`！
        *   发现递减情况，`is_non_decreasing` 函数立即返回 `False`。

3.  **主程序判断：`is_non_decreasing(arr)` 返回 `False`。**
    *   现在会继续判断 `is_non_increasing(arr)`。

4.  **`is_non_increasing(arr)` 调用：**
    *   `arr = [3, 4, 7, 2, 10]`
    *   `i = 1`: `arr[1]` (4) vs `arr[0]` (3)。`4 > 3` 是 `True`！
        *   发现递增情况，`is_non_increasing` 函数立即返回 `False`。

5.  **主程序判断：`is_non_decreasing(arr)` 返回 `False`，`is_non_increasing(arr)` 也返回 `False`。**
    *   `False || False` 的结果是 `False`。
    *   程序会执行 `else` 分支。
    *   最终输出 `unsorted`。

这个结果与题目中的样例2完全一致！

---

### 解法二：一次遍历同时判断非递减和非递增

**讲解**

解法一虽然清晰，但它可能会对序列进行最多两次完整的遍历。虽然对于 `N` 较小的情况影响不大，但如果 `N` 很大，效率就会有所降低。解法二的目标是在一次遍历中完成所有判断。

**核心思路：**
我们维护两个布尔变量：
*   `is_ascending_sorted`：初始化为 `True`，表示我们**假设**序列目前是非递减的。
*   `is_descending_sorted`：初始化为 `True`，表示我们**假设**序列目前是非递增的。

然后我们遍历序列，从第二个元素开始：
*   在每次比较 `arr[i]` 和 `arr[i-1]` 时：
    *   如果 `arr[i] < arr[i-1]` (当前元素比前一个元素小)，说明它不可能再是非递减的了，所以将 `is_ascending_sorted` 设置为 `False`。
    *   如果 `arr[i] > arr[i-1]` (当前元素比前一个元素大)，说明它不可能再是非递增的了，所以将 `is_descending_sorted` 设置为 `False`。

循环结束后，我们检查 `is_ascending_sorted` 或 `is_descending_sorted` 是否有一个为 `True`。如果是，则输出 `sorted`；否则输出 `unsorted`。

这种方法只遍历一次数组，相比解法一在最坏情况下（比如序列无序，需要两次遍历）会更高效。

**ACM模式注意事项：**
*   同解法一，需要从标准输入读取 `N` 和序列元素，并向标准输出打印结果。

---

#### Java 版核心模式与 ACM 模式完整代码

```java
import java.util.Scanner; // 导入Scanner类，用于从标准输入读取数据

public class Main { // 定义一个公共类Main，这是Java程序的入口

    // Java程序的入口方法
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象，用于读取控制台输入

        // 读取第一行的整数N，表示序列的长度
        int N = scanner.nextInt();

        // 创建一个整数数组来存储N个整数
        int[] arr = new int[N];

        // 读取第二行的N个整数，并存储到数组中
        for (int i = 0; i < N; i++) {
            arr[i] = scanner.nextInt();
        }

        scanner.close(); // 关闭Scanner对象，释放资源

        // 定义两个布尔变量，分别表示序列是否可能为非递减和非递增
        // 初始时，我们假设它可能两种都有序
        boolean isAscendingSorted = true;  // 假设序列是非递减的（升序）
        boolean isDescendingSorted = true; // 假设序列是非递增的（降序）

        // 从数组的第二个元素开始遍历，因为我们要比较当前元素和它前面的元素
        // 数组索引从0开始，所以第二个元素的索引是1
        for (int i = 1; i < N; i++) {
            // 检查非递减（升序）的可能性
            // 如果当前元素 arr[i] 小于它前面的元素 arr[i-1]
            // 这就违反了非递减的规则，所以它不可能是非递减序列了
            if (arr[i] < arr[i - 1]) {
                isAscendingSorted = false; // 将非递减标志设置为 false
            }

            // 检查非递增（降序）的可能性
            // 如果当前元素 arr[i] 大于它前面的元素 arr[i-1]
            // 这就违反了非递增的规则，所以它不可能是非递增序列了
            if (arr[i] > arr[i - 1]) {
                isDescendingSorted = false; // 将非递增标志设置为 false
            }

            // 优化：如果两个标志都变为false，说明序列既不是非递减也不是非递增
            // 那么它肯定不是有序的，可以直接提前结束循环，提高效率。
            if (!isAscendingSorted && !isDescendingSorted) {
                break; // 提前跳出循环
            }
        }

        // 判断最终结果：只要其中一个标志仍为true，就说明序列是有序的
        if (isAscendingSorted || isDescendingSorted) {
            System.out.println("sorted"); // 如果是有序的，输出 "sorted"
        } else {
            System.out.println("unsorted"); // 如果无序，输出 "unsorted"
        }
    }
}
```

---

#### Python 版核心模式与 ACM 模式完整代码

```python
import sys # 导入sys模块，用于读取标准输入

# ACM 模式主程序入口
if __name__ == "__main__":
    # 读取第一行的整数N，表示序列的长度
    # sys.stdin.readline().strip() 用于读取一行输入并去除末尾的换行符
    # int() 将字符串转换为整数
    N = int(sys.stdin.readline().strip())

    # 读取第二行的N个整数，用空格分隔
    # sys.stdin.readline().strip().split() 将一行字符串按空格分割成字符串列表
    # map(int, ...) 将列表中的每个字符串转换为整数
    # list(...) 将map对象转换为列表
    arr = list(map(int, sys.stdin.readline().strip().split()))

    # 定义两个布尔变量，分别表示序列是否可能为非递减和非递增
    # 初始时，我们假设它可能两种都有序
    is_ascending_sorted = True  # 假设序列是非递减的（升序）
    is_descending_sorted = True # 假设序列是非递增的（降序）

    # 从列表的第二个元素开始遍历，因为我们要比较当前元素和它前面的元素
    # 列表索引从0开始，所以第二个元素的索引是1
    for i in range(1, N):
        # 检查非递减（升序）的可能性
        # 如果当前元素 arr[i] 小于它前面的元素 arr[i-1]
        # 这就违反了非递减的规则，所以它不可能是非递减序列了
        if arr[i] < arr[i - 1]:
            is_ascending_sorted = False # 将非递减标志设置为 False

        # 检查非递增（降序）的可能性
        # 如果当前元素 arr[i] 大于它前面的元素 arr[i-1]
        # 这就违反了非递增的规则，所以它不可能是非递增序列了
        if arr[i] > arr[i - 1]:
            is_descending_sorted = False # 将非递增标志设置为 False

        # 优化：如果两个标志都变为 False，说明序列既不是非递减也不是非递增
        # 那么它肯定不是有序的，可以直接提前结束循环，提高效率。
        if not is_ascending_sorted and not is_descending_sorted:
            break # 提前跳出循环

    # 判断最终结果：只要其中一个标志仍为 True，就说明序列是有序的
    if is_ascending_sorted or is_descending_sorted:
        print("sorted") # 如果是有序的，输出 "sorted"
    else:
        print("unsorted") # 如果无序，输出 "unsorted"

```

---

#### 示例演示 (以 `3 4 7 2 10` 为例)

我们来手动模拟一下 `N = 5`, `arr = [3, 4, 7, 2, 10]` 这个例子，看看解法二的代码是如何运行的。

1.  **输入读取**
    *   `N` 会被读取为 `5`。
    *   `arr` 会被读取为 `[3, 4, 7, 2, 10]`。

2.  **初始化布尔变量**
    *   `is_ascending_sorted = True`
    *   `is_descending_sorted = True`

3.  **循环遍历 `arr` (从 `i = 1` 到 `N-1`)**
    *   **`i = 1` (比较 `arr[1]` (4) 和 `arr[0]` (3))**
        *   `arr[1] < arr[0]` (即 `4 < 3`) 是 `False`。`is_ascending_sorted` 保持 `True`。
        *   `arr[1] > arr[0]` (即 `4 > 3`) 是 `True`。`is_descending_sorted` 变为 `False`。
        *   检查提前退出条件：`!is_ascending_sorted` (`False`) 和 `!is_descending_sorted` (`True`)。`False && True` 是 `False`。不退出。
        *   当前状态：`is_ascending_sorted = True`, `is_descending_sorted = False`。

    *   **`i = 2` (比较 `arr[2]` (7) 和 `arr[1]` (4))**
        *   `arr[2] < arr[1]` (即 `7 < 4`) 是 `False`。`is_ascending_sorted` 保持 `True`。
        *   `arr[2] > arr[1]` (即 `7 > 4`) 是 `True`。`is_descending_sorted` 已经为 `False`，保持 `False`。
        *   检查提前退出条件：`!is_ascending_sorted` (`False`) 和 `!is_descending_sorted` (`True`)。`False && True` 是 `False`。不退出。
        *   当前状态：`is_ascending_sorted = True`, `is_descending_sorted = False`。

    *   **`i = 3` (比较 `arr[3]` (2) 和 `arr[2]` (7))**
        *   `arr[3] < arr[2]` (即 `2 < 7`) 是 `True`。`is_ascending_sorted` 变为 `False`。
        *   `arr[3] > arr[2]` (即 `2 > 7`) 是 `False`。`is_descending_sorted` 保持 `False`。
        *   检查提前退出条件：`!is_ascending_sorted` (`True`) 和 `!is_descending_sorted` (`True`)。`True && True` 是 `True`！
        *   **提前退出循环 (break)。**

4.  **循环结束，判断最终结果**
    *   `is_ascending_sorted` 是 `False`。
    *   `is_descending_sorted` 是 `False`。
    *   `is_ascending_sorted || is_descending_sorted` (即 `False || False`) 的结果是 `False`。
    *   程序会执行 `else` 分支。
    *   最终输出 `unsorted`。

这个结果也与题目中的样例2完全一致！并且通过提前退出，我们避免了对整个数组的无谓遍历，提高了效率。

---

希望这个详细的讲解、代码和示例演示能让你彻底理解这个题目！如果你有任何疑问，或者想尝试其他解法，随时可以提问！








## 2025年9月27日-科大讯飞-第一题-小红的红色数组-基础语法






### 完整题目

**题目内容**

小红拿到了一个长度为 $n$ 的整数数组 $a_1, a_2, \ldots, a_n$ (下标从 1 开始)。她将其中 $k$ 个元素染成了红色，染红元素的下标依次为 $b_1, b_2, \ldots, b_k$，保证两两不同。

小红想知道：**所有未被染成红色的元素之和** 等于多少？

**输入描述**

在第一行输入两个整数 $n, k$ ($1 \le k \le n \le 2 \times 10^5$)，分别表示数组长度与被染红的元素个数。
在第二行输入 $n$ 个整数 $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^9$)，表示数组元素。
在第三行输入 $k$ 个互不相同的 $b_1, b_2, \ldots, b_k$ ($1 \le b_i \le n$)，表示被染红元素的下标。

**输出描述**

输出一个整数，表示所有未被染红元素的和。

**样例1**

输入
```
3 1
1 2 3
1
```
输出
```
5
```
说明：在该样例中，第 1 个元素被染红，未染红元素为 $a_2 = 2, a_3 = 3$，因此答案为 $2 + 3 = 5$。

**样例2**

输入
```
5 3
6 5 5 3 6
1 4 2
```
输出
```
11
```
说明：在此样例中，未染红元素为 $a_3 = 5, a_5 = 6$，其和为 $5 + 6 = 11$。

---

### 分析解读

这道题目的核心是计算一个数组中，除了指定下标的元素之外，其余所有元素的和。

**关键信息提取：**
1.  **数组长度 $n$ 和红色元素个数 $k$**：`1 <= k <= n <= 2 * 10^5`。这个范围告诉我们，数组可能会很大，达到 20 万个元素。因此，我们需要考虑效率。
2.  **数组元素 $a_i$**：`1 <= a_i <= 10^9`。元素的值可能很大，所以它们的和也可能很大。在 Java 中，需要使用 `long` 类型来存储总和，以避免整数溢出。Python 则没有这个问题，因为它会自动处理大整数。
3.  **红色元素的下标 $b_i$**：`1 <= b_i <= n`，并且两两不同。下标是从 1 开始的，这一点在编程时需要特别注意，因为大多数编程语言（如 Java 和 Python）的数组/列表索引是从 0 开始的。这意味着如果题目给出的下标是 `b_i`，那么在代码中对应的索引是 `b_i - 1`。

**解题思路**

最直接的思路是：
1.  计算数组中所有元素的总和（设为 `total_sum`）。
2.  遍历所有被染红的元素的下标 `b_i`。
3.  将被染红的元素的值从 `total_sum` 中减去。
4.  最终得到的 `total_sum` 就是所有未被染红元素的和。

这种方法的好处是思路简单，不容易出错。

**效率分析**
*   计算所有元素的总和：需要遍历一次数组，时间复杂度为 $O(N)$。
*   减去红色元素的值：需要遍历 $k$ 个红色元素的下标，然后根据下标访问数组元素。时间复杂度为 $O(K)$。
*   总时间复杂度为 $O(N + K)$。由于 $K \le N$，所以可以简化为 $O(N)$。
*   空间复杂度：存储数组 `a` 需要 $O(N)$ 空间；存储红色下标 `b` 需要 $O(K)$ 空间。总空间复杂度为 $O(N + K)$。

考虑到 $N$ 最大是 $2 \times 10^5$， $O(N)$ 的时间复杂度是完全可以接受的。

**ACM模式注意事项：**
*   需要从标准输入读取 `n`, `k`。
*   需要读取 `n` 个整数作为数组元素。
*   需要读取 `k` 个整数作为红色元素的下标。
*   需要向标准输出打印最终结果。
*   **注意下标转换**：题目给的下标是 1-based，代码中通常是 0-based。
*   **注意数据类型**：数组元素值可能很大，求和时可能需要 `long` 类型。

---

### 解法一：先求总和，再减去红色元素

**讲解**

这种方法是基于我们上面分析的最直观的思路。

**核心步骤：**
1.  读取 `n` 和 `k`。
2.  读取 `n` 个数组元素，并将它们存储在一个数组（或列表）中。在读取的同时，累加所有元素的和，得到 `total_sum`。
3.  读取 `k` 个红色元素的下标。对于每个下标 `b_i`：
    *   将 `b_i` 转换为 0-based 索引，即 `index = b_i - 1`。
    *   从 `total_sum` 中减去 `arr[index]` 的值。
4.  打印最终的 `total_sum`。

---

#### Java 版核心模式与 ACM 模式完整代码

```java
import java.util.Scanner; // 导入Scanner类，用于从标准输入读取数据

public class Main { // 定义一个公共类Main，这是Java程序的入口

    // Java程序的入口方法
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象，用于读取控制台输入

        // 1. 读取第一行的两个整数 n 和 k
        // n 表示数组的长度
        // k 表示被染红的元素个数
        int n = scanner.nextInt();
        int k = scanner.nextInt();

        // 2. 读取第二行的 n 个整数，表示数组元素
        // 由于数组元素的值 a_i 可能高达 10^9，且 n 可能高达 2*10^5
        // 它们的和可能会超过 int 类型的最大值 (约 2*10^9)
        // 所以我们需要使用 long 类型来存储所有元素的总和，以避免整数溢出
        long totalSum = 0; // 初始化所有元素的总和为0

        // 创建一个整数数组来存储 n 个元素
        // 数组的索引是从 0 到 n-1
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt(); // 读取当前元素
            totalSum += arr[i];         // 将当前元素累加到总和中
        }

        // 3. 读取第三行的 k 个整数，表示被染红元素的下标
        // 题目中下标是从 1 开始的，但在Java数组中索引是从 0 开始
        // 所以需要将读取到的下标 b_i 转换为 b_i - 1
        for (int i = 0; i < k; i++) {
            int redIndex = scanner.nextInt(); // 读取被染红的元素的 1-based 下标
            // 将 1-based 下标转换为 0-based 索引
            // 然后从总和中减去对应元素的值
            totalSum -= arr[redIndex - 1];
        }

        scanner.close(); // 关闭Scanner对象，释放资源

        // 4. 输出所有未被染红元素的和
        System.out.println(totalSum);
    }
}
```

---

#### Python 版核心模式与 ACM 模式完整代码

```python
import sys # 导入sys模块，用于读取标准输入

# ACM 模式主程序入口
if __name__ == "__main__":
    # 1. 读取第一行的两个整数 n 和 k
    # sys.stdin.readline().strip() 用于读取一行输入并去除末尾的换行符
    # .split() 将一行字符串按空格分割成字符串列表
    # map(int, ...) 将列表中的每个字符串转换为整数
    # list(...) 将map对象转换为列表 (这里直接用map即可，因为不需要存储列表)
    n, k = map(int, sys.stdin.readline().strip().split())

    # 2. 读取第二行的 n 个整数，表示数组元素
    # Python 的整数类型可以自动处理大整数，所以不需要像 Java 那样特别声明 long 类型
    arr = list(map(int, sys.stdin.readline().strip().split()))

    # 计算所有元素的总和
    total_sum = sum(arr) # Python 内置的 sum() 函数可以直接计算列表所有元素的和

    # 3. 读取第三行的 k 个整数，表示被染红元素的下标
    # 题目中下标是从 1 开始的，但在 Python 列表中索引是从 0 开始
    # 所以需要将读取到的下标 b_i 转换为 b_i - 1
    red_indices_1_based = list(map(int, sys.stdin.readline().strip().split()))

    for index_1_based in red_indices_1_based:
        # 将 1-based 下标转换为 0-based 索引
        # 然后从总和中减去对应元素的值
        total_sum -= arr[index_1_based - 1]

    # 4. 输出所有未被染红元素的和
    print(total_sum)

```

---

#### 示例演示 (以样例2为例)

我们来手动模拟一下 `N = 5`, `K = 3`, `arr = [6, 5, 5, 3, 6]`, `red_indices = [1, 4, 2]` 这个例子，看看代码是如何运行的。

**输入：**
```
5 3
6 5 5 3 6
1 4 2
```

**Python 代码执行过程：**

1.  **读取 `n` 和 `k`：**
    *   `n` = 5
    *   `k` = 3

2.  **读取 `arr` 并计算 `total_sum`：**
    *   `arr` = `[6, 5, 5, 3, 6]`
    *   `total_sum = sum(arr)`
    *   `total_sum = 6 + 5 + 5 + 3 + 6 = 25`

3.  **读取 `red_indices_1_based`：**
    *   `red_indices_1_based` = `[1, 4, 2]`

4.  **遍历 `red_indices_1_based` 减去对应元素：**
    *   **第一次循环 (`index_1_based = 1`)：**
        *   对应的 0-based 索引是 `1 - 1 = 0`。
        *   `arr[0]` 的值是 `6`。
        *   `total_sum = total_sum - arr[0] = 25 - 6 = 19`。
    *   **第二次循环 (`index_1_based = 4`)：**
        *   对应的 0-based 索引是 `4 - 1 = 3`。
        *   `arr[3]` 的值是 `3`。
        *   `total_sum = total_sum - arr[3] = 19 - 3 = 16`。
    *   **第三次循环 (`index_1_based = 2`)：**
        *   对应的 0-based 索引是 `2 - 1 = 1`。
        *   `arr[1]` 的值是 `5`。
        *   `total_sum = total_sum - arr[1] = 16 - 5 = 11`。

5.  **循环结束，打印 `total_sum`：**
    *   `print(11)`

最终输出 `11`，与样例2的输出完全一致！

---

### 解法二：使用布尔标记数组（或哈希集合）

**讲解**

如果不想先计算总和再减去，或者觉得维护一个 `total_sum` 变量容易出错（虽然这里它非常简单），我们可以使用一个额外的布尔数组（或哈希集合/Set）来标记哪些元素是红色的。

**核心思路：**
1.  创建一个与原数组长度相同的布尔数组 `is_red` (或者 `is_colored`)，并全部初始化为 `False`。
2.  读取 `k` 个红色元素的下标 `b_i`。对于每个 `b_i`，将其转换为 0-based 索引 `index = b_i - 1`，然后将 `is_red[index]` 设置为 `True`。
3.  遍历原始数组 `arr`。如果 `is_red[i]` 是 `False` (表示这个元素没有被染红)，则将其值累加到 `result_sum` 中。
4.  打印 `result_sum`。

**效率分析**
*   初始化布尔数组：$O(N)$ 空间和时间。
*   标记红色元素：遍历 $k$ 个下标，每次 $O(1)$ 操作。总时间 $O(K)$。
*   遍历原数组并求和：遍历 $N$ 个元素，每次 $O(1)$ 操作。总时间 $O(N)$。
*   总时间复杂度为 $O(N + K)$，简化为 $O(N)$。
*   总空间复杂度为 $O(N)$（用于存储 `arr` 和 `is_red`）。

这种方法与解法一在渐近时间复杂度上是相同的，但在实际操作中可能因为多了一次数组遍历和布尔数组的创建而略慢一些，但差异不大。对于本题的数据规模，两种方法都非常高效。

**使用哈希集合 (Set) 的变种：**
如果 `N` 很大，但 `K` 相对较小，或者数组元素的值非常大（不适合用布尔数组映射），可以使用哈希集合来存储所有红色元素的 0-based 索引。
1.  创建一个空的哈希集合 `red_indices_set`。
2.  读取 `k` 个红色元素的下标 `b_i`，将其转换为 0-based 索引 `index = b_i - 1`，然后将 `index` 添加到 `red_indices_set` 中。
3.  遍历原始数组 `arr`。如果当前元素的索引 `i` 不在 `red_indices_set` 中，则将其值累加到 `result_sum` 中。
4.  打印 `result_sum`。

哈希集合的查找、插入和删除操作平均时间复杂度是 $O(1)$。所以这种方法的总时间复杂度也是 $O(N + K)$。空间复杂度是 $O(K)$（用于存储哈希集合）。对于本题，$N$ 和 $K$ 的范围相同，所以布尔数组和哈希集合在空间上都是 `O(N)` 量级（因为 `K` 最多可以等于 `N`）。这里我们优先选择布尔数组，因为它访问速度快，且内存开销固定。

---

#### Java 版核心模式与 ACM 模式完整代码

```java
import java.util.Scanner; // 导入Scanner类，用于从标准输入读取数据
// import java.util.HashSet; // 如果选择使用HashSet，需要导入这个

public class Main { // 定义一个公共类Main，这是Java程序的入口

    // Java程序的入口方法
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象，用于读取控制台输入

        // 1. 读取第一行的两个整数 n 和 k
        int n = scanner.nextInt();
        int k = scanner.nextInt();

        // 2. 读取第二行的 n 个整数，表示数组元素
        // 创建一个整数数组来存储 n 个元素
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt(); // 读取当前元素
        }

        // 3. 创建一个布尔数组 isRed 来标记哪些元素被染红
        // 数组长度为 n，初始时所有元素都为 false (表示未被染红)
        boolean[] isRed = new boolean[n];

        // 读取第三行的 k 个整数，表示被染红元素的下标
        // 题目中下标是从 1 开始的，转换为 0-based 索引后，将对应位置标记为 true
        for (int i = 0; i < k; i++) {
            int redIndex_1_based = scanner.nextInt(); // 读取 1-based 下标
            // 将 1-based 下标转换为 0-based 索引
            isRed[redIndex_1_based - 1] = true; // 将对应位置标记为 true
        }

        scanner.close(); // 关闭Scanner对象，释放资源

        // 4. 遍历原始数组 arr，累加所有未被染红的元素的值
        // 同样，总和可能很大，使用 long 类型
        long resultSum = 0; // 初始化未被染红元素的总和为0
        for (int i = 0; i < n; i++) {
            // 如果 isRed[i] 为 false，说明 arr[i] 没有被染红
            if (!isRed[i]) {
                resultSum += arr[i]; // 将其值累加到结果总和中
            }
        }

        // 5. 输出所有未被染红元素的和
        System.out.println(resultSum);
    }
}
```

---

#### Python 版核心模式与 ACM 模式完整代码

```python
import sys # 导入sys模块，用于读取标准输入

# ACM 模式主程序入口
if __name__ == "__main__":
    # 1. 读取第一行的两个整数 n 和 k
    n, k = map(int, sys.stdin.readline().strip().split())

    # 2. 读取第二行的 n 个整数，表示数组元素
    arr = list(map(int, sys.stdin.readline().strip().split()))

    # 3. 创建一个布尔列表 is_red 来标记哪些元素被染红
    # 列表长度为 n，初始时所有元素都为 False (表示未被染红)
    # [False] * n 创建一个包含 n 个 False 的列表
    is_red = [False] * n

    # 读取第三行的 k 个整数，表示被染红元素的下标
    # 题目中下标是从 1 开始的，转换为 0-based 索引后，将对应位置标记为 True
    red_indices_1_based = list(map(int, sys.stdin.readline().strip().split()))

    for index_1_based in red_indices_1_based:
        # 将 1-based 下标转换为 0-based 索引
        is_red[index_1_based - 1] = True # 将对应位置标记为 True

    # 4. 遍历原始数组 arr，累加所有未被染红的元素的值
    # Python 的整数类型可以自动处理大整数
    result_sum = 0 # 初始化未被染红元素的总和为0
    for i in range(n):
        # 如果 is_red[i] 为 False，说明 arr[i] 没有被染红
        if not is_red[i]:
            result_sum += arr[i] # 将其值累加到结果总和中

    # 5. 输出所有未被染红元素的和
    print(result_sum)

```

---

#### 示例演示 (以样例2为例)

我们来手动模拟一下 `N = 5`, `K = 3`, `arr = [6, 5, 5, 3, 6]`, `red_indices = [1, 4, 2]` 这个例子，看看解法二的代码是如何运行的。

**输入：**
```
5 3
6 5 5 3 6
1 4 2
```

**Python 代码执行过程：**

1.  **读取 `n` 和 `k`：**
    *   `n` = 5
    *   `k` = 3

2.  **读取 `arr`：**
    *   `arr` = `[6, 5, 5, 3, 6]`

3.  **初始化 `is_red` 列表：**
    *   `is_red` = `[False, False, False, False, False]`

4.  **读取 `red_indices_1_based` 并标记 `is_red`：**
    *   `red_indices_1_based` = `[1, 4, 2]`
    *   **处理 `1`：** `index = 1 - 1 = 0`。`is_red[0] = True`。
        *   `is_red` 变为 `[True, False, False, False, False]`。
    *   **处理 `4`：** `index = 4 - 1 = 3`。`is_red[3] = True`。
        *   `is_red` 变为 `[True, False, False, True, False]`。
    *   **处理 `2`：** `index = 2 - 1 = 1`。`is_red[1] = True`。
        *   `is_red` 变为 `[True, True, False, True, False]`。

5.  **遍历 `arr` 并累加未被染红的元素：**
    *   `result_sum = 0`
    *   **`i = 0`：** `is_red[0]` 是 `True`。跳过。
    *   **`i = 1`：** `is_red[1]` 是 `True`。跳过。
    *   **`i = 2`：** `is_red[2]` 是 `False`。
        *   `result_sum = result_sum + arr[2] = 0 + 5 = 5`。
    *   **`i = 3`：** `is_red[3]` 是 `True`。跳过。
    *   **`i = 4`：** `is_red[4]` 是 `False`。
        *   `result_sum = result_sum + arr[4] = 5 + 6 = 11`。

6.  **循环结束，打印 `result_sum`：**
    *   `print(11)`

最终输出 `11`，与样例2的输出完全一致！

---

**总结对比：**

*   **解法一 (先求总和再减去)**：
    *   优点：思路最直接，代码简洁。只需要一个 `total_sum` 变量。
    *   缺点：无。对于这种问题，它是非常优秀的解法。
*   **解法二 (使用布尔标记数组)**：
    *   优点：逻辑清晰，将“标记”和“求和”分离。
    *   缺点：需要额外的 $O(N)$ 空间来存储 `is_red` 数组。
    *   使用哈希集合变种时，如果 $K$ 远小于 $N$，空间复杂度可以优化到 $O(K)$，但通常布尔数组在访问效率上更有优势。

对于这道题，两种解法的时间复杂度和空间复杂度都符合要求，都可以通过。解法一在代码量和内存使用上略优，通常是首选。

希望这个详细的讲解、代码和示例演示能让你彻底理解这个题目！如果你有任何疑问，或者想尝试其他解法，随时可以提问！



