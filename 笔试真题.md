



# 动态规划


## 2025年8月31日-蚂蚁算法岗-第一题-字符中位符-模拟

好的，作为一名高级软件工程师，我将为你详细解析这道算法题，并提供多种解法及其代码实现。

### 题目及分析

**题目描述**

给定一个长度为 `n`，仅由小写字母组成的字符串 `s`，请输出它的“中位符”。

**中位符定义**

将该字符串按字典序（ASCII码从小到大）排序后，排在第 `⌊n / 2⌋` 个位置的字符（从1开始计数）。

**输入/输出**

*   **输入**：两行。第一行是整数 `n` (1 ≤ n ≤ 2 × 10⁵)，第二行是长度为 `n` 的字符串 `s`。
*   **输出**：一个字符，表示字符串 `s` 的中位符。

**分析**

题目的核心是找到排序后特定位置的字符。我们来解读一下“中位符”的定义：

1.  **排序**：首先，需要将输入的字符串 `s` 按照字符的字典序进行排序。例如，`"cba"` 排序后变成 `"abc"`。
2.  **定位**：排序后，我们需要找到目标位置。题目描述为 “第 `⌊n / 2⌋` 个字符(从1开始计数)”。这里的 `⌊x⌋` 是向下取整符号。
    *   在计算机科学中，数组和字符串的索引通常从0开始。
    *   一个从1开始的第 `k` 个元素，对应的是从0开始的第 `k-1` 个索引。
    *   因此，“第 `⌊n / 2⌋` 个字符(从1开始计数)” 实际上指的是排序后，**索引为 `⌊n / 2⌋ - 1`** 的字符。

    **等等，我们用示例来验证一下这个理解是否正确。**
    *   **输入**: `n = 3`, `s = "cba"`
    *   **排序后**: `"abc"`
    *   **目标位置**: `⌊3 / 2⌋ = 1`。
    *   **如果按 `索引 = ⌊n / 2⌋ - 1` 计算**: 索引为 `1 - 1 = 0`，字符是 `'a'`。但这与示例输出 `'b'` 不符。

    **让我们换一种理解方式。**
    很多编程竞赛题目中的“第k个”实际上是指0-based索引的第k个位置。我们用这个假设再来验证一次。
    *   **输入**: `n = 3`, `s = "cba"`
    *   **排序后**: `"abc"`
    *   **目标位置**: `⌊3 / 2⌋ = 1`。
    *   **如果按 `索引 = ⌊n / 2⌋` 计算**: 索引为 `1`，字符是 `'b'`。这与示例输出 `'b'` 完全吻合。

    **结论**：中位符就是将字符串 `s` 排序后，位于**0-based索引 `⌊n / 2⌋`** 处的字符。

    **数据规模**：`n` 的最大值为 2 × 10⁵，这意味着 O(n²) 的算法会超时，而 O(n log n) 或 O(n) 的算法是可以通过的。

---

### 解法一：直接排序

 讲解

这是最直观的解法，完全按照“中位符”的定义来操作。

1.  **读取输入**：读取字符串的长度 `n` 和字符串 `s`。
2.  **转换并排序**：将字符串 `s` 转换为一个字符数组（或列表），因为字符串本身通常是不可变的。然后使用语言内置的排序函数对这个字符数组进行排序。
3.  **计算索引**：计算中位数的索引 `index = n / 2` （在大多数语言中，整数除法会自动向下取整）。
4.  **获取结果**：从排序后的数组中取出索引为 `index` 的字符，并输出。

这种方法的时间复杂度主要由排序算法决定，通常是 O(n log n)，空间复杂度为 O(n) 用于存储字符数组。对于本题的数据规模，这是完全可以接受的。

 代码

 Java 实现

```java
// 核心模式
class Solution {
    /**
     * 查找字符串的中位符
     * @param n 字符串长度
     * @param s 输入的字符串
     * @return 中位符
     */
    public char findMedianChar(int n, String s) {
        // 1. 将字符串转换为字符数组，以便排序
        char[] chars = s.toCharArray();

        // 2. 使用Java内置的排序函数对数组进行排序
        java.util.Arrays.sort(chars);

        // 3. 计算中位符的索引 (整数除法自动向下取整)
        int medianIndex = n / 2;

        // 4. 返回排序后位于中位索引的字符
        return chars[medianIndex];
    }
}
```

```java
// ACM 模式
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        // 使用 Scanner 来读取标准输入
        Scanner scanner = new Scanner(System.in);

        // 第一行：读取字符串的长度 n
        int n = scanner.nextInt();

        // 第二行：读取字符串 s
        String s = scanner.next();

        // 关闭 scanner
        scanner.close();

        // 1. 将字符串转换为字符数组
        // toCharArray() 方法会创建一个新的字符数组
        char[] chars = s.toCharArray();

        // 2. 对字符数组进行排序
        // Arrays.sort() 使用了高效的排序算法（如快速排序或归并排序）
        // 时间复杂度为 O(n log n)
        Arrays.sort(chars);

        // 3. 计算中位符的索引
        // Java中的整数除法 `n / 2` 结果会自动向下取整，等价于 floor(n / 2)
        int medianIndex = n / 2;

        // 4. 获取并输出中位符
        System.out.println(chars[medianIndex]);
    }
}
```

 Python 实现

```python
# 核心模式
def find_median_char(n: int, s: str) -> str:
    """
    查找字符串的中位符
    :param n: 字符串长度
    :param s: 输入的字符串
    :return: 中位符
    """
    # 1. 对字符串进行排序。sorted()函数会返回一个排序后的字符列表
    sorted_chars = sorted(s)

    # 2. 计算中位符的索引 (整数除法 // 自动向下取整)
    median_index = n // 2

    # 3. 返回排序后位于中位索引的字符
    return sorted_chars[median_index]

```

```python
# ACM 模式
import sys

def main():
    """
    主函数，处理输入和输出
    """
    # 从标准输入读取所有行
    lines = sys.stdin.readlines()

    # 第一行：获取字符串长度 n
    # strip() 用于移除可能的空白字符
    n = int(lines[0].strip())

    # 第二行：获取字符串 s
    s = lines[1].strip()

    # 1. 对字符串s中的字符进行排序
    # sorted() 函数返回一个包含排序后字符的新列表
    # 时间复杂度为 O(n log n)
    sorted_chars = sorted(s)

    # 2. 计算中位符的索引
    # Python中的整数除法 `//` 结果会自动向下取整
    median_index = n // 2

    # 3. 获取并输出中位符
    # sys.stdout.write可以避免print函数默认添加的换行符（如果需要）
    # 这里直接用print更简洁
    print(sorted_chars[median_index])

if __name__ == "__main__":
    main()

```

 示例演示

以输入 `n = 3`, `s = "cba"` 为例：

1.  **读取输入**：程序读入 `n = 3` 和 `s = "cba"`。
2.  **转换与排序**：
    *   Java: `s.toCharArray()` 得到 `['c', 'b', 'a']`。`Arrays.sort()` 后变为 `['a', 'b', 'c']`。
    *   Python: `sorted(s)` 直接得到 `['a', 'b', 'c']`。
3.  **计算索引**：`medianIndex = 3 / 2` (或 `3 // 2`)，结果为 `1`。
4.  **获取结果**：从排序后的数组 `['a', 'b', 'c']` 中取出索引为 `1` 的元素，即 `'b'`。
5.  **输出**：程序打印字符 `'b'`。

---

### 解法二：计数排序

 讲解

考虑到字符串只包含小写字母（'a'-'z'），这是一个有限且固定的字符集（26个字符）。在这种情况下，使用计数排序是更高效的选择。

1.  **创建计数桶**：创建一个大小为26的数组（或哈希表），用于统计每个小写字母出现的次数。例如，`counts[0]` 存 `'a'` 的数量，`counts[1]` 存 `'b'` 的数量，以此类推。
2.  **统计频率**：遍历输入字符串 `s`，填充计数桶。对于每个字符 `c`，将其对应的计数加一（例如 `counts[c - 'a']++`）。
3.  **查找中位符**：
    *   计算目标位置 `target_pos = n / 2`。我们需要找到在排序后的逻辑序列中，第 `target_pos` 个字符（0-based）是什么。
    *   遍历计数桶（从 `'a'` 到 `'z'`）。用 `target_pos` 减去每个字符的数量。
    *   当 `target_pos` 减去某个字符 `c` 的数量后首次变为负数时，说明中位符就是这个字符 `c`。

这种方法的时间复杂度为 O(n + k)，其中 `k` 是字符集的大小（26）。由于 `k` 是一个常数，所以时间复杂度可以看作 O(n)。空间复杂度为 O(k)，即 O(1) 的常数空间。

 代码

 Java 实现

```java
// 核心模式
class Solution {
    /**
     * 使用计数排序思想查找字符串的中位符
     * @param n 字符串长度
     * @param s 输入的字符串
     * @return 中位符
     */
    public char findMedianCharCounting(int n, String s) {
        // 1. 创建一个大小为26的数组作为计数桶
        int[] counts = new int[26];

        // 2. 遍历字符串，统计每个字符的出现次数
        for (char c : s.toCharArray()) {
            counts[c - 'a']++;
        }

        // 3. 计算中位符的目标位置（0-based）
        int targetPos = n / 2;

        // 4. 遍历计数桶，找到中位符
        for (int i = 0; i < 26; i++) {
            // 如果目标位置落在当前字符的计数范围内
            if (targetPos < counts[i]) {
                // 当前字符就是中位符
                // (char)('a' + i) 将索引转换回字符
                return (char)('a' + i);
            }
            // 否则，跳过当前字符的所有实例，更新目标位置
            targetPos -= counts[i];
        }

        // 理论上不会执行到这里，因为中位符肯定存在
        return ' ';
    }
}
```

```java
// ACM 模式
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String s = scanner.next();
        scanner.close();

        // 1. 创建计数桶，大小为26，对应 'a' 到 'z'
        // 数组默认所有元素初始化为0
        int[] counts = new int[26];

        // 2. 遍历输入字符串，填充计数桶
        // 时间复杂度 O(n)
        for (int i = 0; i < n; i++) {
            // s.charAt(i) - 'a' 将字符转换为 0-25 的索引
            counts[s.charAt(i) - 'a']++;
        }

        // 3. 计算中位符的目标位置（0-based index）
        int targetPos = n / 2;
        char medianChar = ' '; // 初始化结果变量

        // 4. 遍历计数桶，查找中位符
        // 这个循环最多执行26次，时间复杂度 O(k), k=26
        for (int i = 0; i < 26; i++) {
            // 检查目标位置是否在当前字符的范围内
            if (targetPos < counts[i]) {
                // 如果是，则当前字符就是我们要找的中位符
                medianChar = (char) ('a' + i);
                // 找到后立即退出循环
                break;
            }
            // 如果不是，说明中位符在后面，
            // 从目标位置中减去当前字符的数量，相当于跳过这些字符
            targetPos -= counts[i];
        }

        // 5. 输出结果
        System.out.println(medianChar);
    }
}
```

 Python 实现

```python
# 核心模式
def find_median_char_counting(n: int, s: str) -> str:
    """
    使用计数排序思想查找字符串的中位符
    :param n: 字符串长度
    :param s: 输入的字符串
    :return: 中位符
    """
    # 1. 创建大小为26的列表作为计数桶
    counts = [0] * 26

    # 2. 遍历字符串，统计字符频率
    for char in s:
        # ord(char) - ord('a') 将字符转换为 0-25 的索引
        counts[ord(char) - ord('a')] += 1

    # 3. 计算中位符的目标位置
    target_pos = n // 2

    # 4. 遍历计数桶，找到中位符
    for i in range(26):
        # 如果目标位置在当前字符的计数范围内
        if target_pos < counts[i]:
            # chr(ord('a') + i) 将索引转换回字符
            return chr(ord('a') + i)
        # 否则，更新目标位置
        target_pos -= counts[i]
    
    # 理论上不会执行到这里
    return ""

```

```python
# ACM 模式
import sys

def main():
    """
    主函数，处理输入和输出
    """
    lines = sys.stdin.readlines()
    n = int(lines[0].strip())
    s = lines[1].strip()

    # 1. 创建计数桶，一个长度为26的列表，全部初始化为0
    counts = [0] * 26

    # 2. 遍历字符串，统计每个字符的出现次数
    # 时间复杂度 O(n)
    for char in s:
        # ord(char) 获取字符的ASCII值
        # ord('a') 是 'a' 的ASCII值
        # 两者相减得到 0-25 的索引
        counts[ord(char) - ord('a')] += 1

    # 3. 计算中位符的目标位置（0-based index）
    target_pos = n // 2

    # 4. 遍历计数桶，找到中位符
    # 时间复杂度 O(k), k=26
    for i in range(26):
        # 获取当前字符（索引i对应的字符）的数量
        count = counts[i]
        
        # 检查目标位置是否在当前字符的范围内
        if target_pos < count:
            # 如果是，则找到了中位符
            # chr(ord('a') + i) 可以将索引i转换回对应的字符
            median_char = chr(ord('a') + i)
            print(median_char)
            # 找到后即可退出程序
            return
        
        # 如果不是，就从目标位置中减去当前字符的数量
        target_pos -= count

if __name__ == "__main__":
    main()
```

 示例演示

以输入 `n = 3`, `s = "cba"` 为例：

1.  **创建计数桶**：`counts = [0, 0, 0, ..., 0]` (长度26)。
2.  **统计频率**：
    *   遍历到 `'c'`：`counts[2]` 变为 `1`。
    *   遍历到 `'b'`：`counts[1]` 变为 `1`。
    *   遍历到 `'a'`：`counts[0]` 变为 `1`。
    *   最终 `counts` 为 `[1, 1, 1, 0, ..., 0]`。
3.  **查找中位符**：
    *   计算目标位置 `target_pos = 3 // 2 = 1`。
    *   开始遍历计数桶：
        *   **i = 0** (对应 `'a'`): `counts[0]` 是 `1`。`target_pos` (1) 不小于 `counts[0]` (1)。更新 `target_pos = 1 - 1 = 0`。
        *   **i = 1** (对应 `'b'`): `counts[1]` 是 `1`。`target_pos` (0) 小于 `counts[1]` (1)。条件成立！
    *   **确定结果**：中位符就是索引 `1` 对应的字符，即 `(char)('a' + 1)` 或 `chr(ord('a') + 1)`，结果是 `'b'`。
4.  **输出**：程序打印字符 `'b'`。















## 2025年8月10日-大疆-第一题-无人机能耗最小化路径规划-线性dp
好的，我们来详细讲解“无人机能耗最小化路径规划”这道算法题。

### 题目及分析

 **题目描述**

在实际的无人机物流配送场景中，无人机需要从仓库（左上角网格点）出发，将货物送达目的地（右下角网格点）。为了优化飞行效率，我们将其飞行区域划分为 `m` 行 `n` 列的网格单元格，每个单元格的数值表示该区域的单位能耗成本（非负整数，包含地形、风阻等因素影响）。由于无人机受限于飞行规则（如避免频繁转向、遵守临时禁飞区管制），每次只能向右或向下移动一个单元格。请为无人机规划一条从起点到终点的飞行路径，使得全程的总能耗成本最小。

 输入描述

第一行为两个整数，代表 `m` 和 `n`，含义同题干描述，接下来一个 `m` 行 `n` 列的二维数组，数组中的每个整数代表对应网格的能耗成本。

 输出描述

输出为正整数

 示例

**样例 1：**
输入：
```
3 3
1 2 3
4 5 6
7 8 9
```
输出：
```
21
```
解释：从左上角 `(0,0)` 到右下角 `(2,2)` 的路径 `1 → 2 → 3 → 6 → 9` 的总能耗为 `1+2+3+6+9 = 21`。
或者路径 `1 → 4 → 7 → 8 → 9` 的总能耗为 `1+4+7+8+9 = 29`。
路径 `1 → 2 → 5 → 8 → 9` 的总能耗为 `1+2+5+8+9 = 25`。
路径 `1 → 4 → 5 → 6 → 9` 的总能耗为 `1+4+5+6+9 = 25`。
其中 `1 → 2 → 3 → 6 → 9` 的能耗 `21` 是最小的。

 



**问题分析**

这道题目是经典的**最小路径和**问题。它要求我们从一个 `m x n` 的网格的左上角 `(0,0)` 出发，每次只能向下或向右移动一步，最终到达右下角 `(m-1, n-1)`，并找到一条路径，使得路径上所有单元格的能耗成本总和最小。

这显然是一个动态规划（Dynamic Programming）问题，因为它具备以下两个核心特征：

1.  **最优子结构 (Optimal Substructure)**：
    要找到到达单元格 `(i, j)` 的最小总能耗，无人机必须从 `(i-1, j)`（上方）或 `(i, j-1)`（左方）中的一个单元格移动过来。因此，到达 `(i, j)` 的最小总能耗，就是 `min(到达(i-1, j)的最小总能耗, 到达(i, j-1)的最小总能耗) + grid[i][j]`。这表明大问题的解可以由小问题的最优解推导出来。

2.  **重叠子问题 (Overlapping Subproblems)**：
    在计算到达不同单元格的最小总能耗时，我们可能会多次需要计算到达同一个中间单元格的最小总能耗。例如，计算 `(i+1, j)` 和 `(i, j+1)` 的最小总能耗时，都可能需要 `(i, j)` 的最小总能耗。动态规划通过存储这些子问题的解来避免重复计算。

基于以上分析，我们可以使用动态规划来解决此问题。

### 解法一：动态规划 (O(m*n) 空间复杂度)

 讲解

我们将创建一个与输入 `grid` 大小相同的 `dp` 数组，其中 `dp[i][j]` 表示从左上角 `(0,0)` 到达单元格 `(i,j)` 的最小总能耗。

1.  **定义 `dp` 数组**：
    `dp[i][j]`：表示从 `(0,0)` 到达 `(i,j)` 的最小总能耗。

2.  **初始化**：
    *   **起始点**：`dp[0][0] = grid[0][0]`。这是无人机路径的起点能耗。
    *   **第一行**：对于 `dp[0][j]` (其中 `j > 0`)，由于无人机只能向右移动，所以到达 `(0,j)` 的最小总能耗就是到达 `(0,j-1)` 的最小总能耗加上 `grid[0][j]` 的能耗。
        `dp[0][j] = dp[0][j-1] + grid[0][j]`。
    *   **第一列**：对于 `dp[i][0]` (其中 `i > 0`)，由于无人机只能向下移动，所以到达 `(i,0)` 的最小总能耗就是到达 `(i-1,0)` 的最小总能耗加上 `grid[i][0]` 的能耗。
        `dp[i][0] = dp[i-1][0] + grid[i][0]`。

3.  **状态转移方程**：
    对于网格中除了第一行和第一列之外的任何单元格 `(i,j)` (其中 `i > 0` 且 `j > 0`)：
    要到达 `(i,j)`，无人机可以从 `(i-1,j)`（上方）向下移动，也可以从 `(i,j-1)`（左方）向右移动。我们选择其中总能耗较小的那一条路径。
    `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`

4.  **最终结果**：
    `dp[m-1][n-1]` 就是从左上角到右下角的最小总能耗。

**时间复杂度**：
*   我们需要填充 `m x n` 个 `dp` 单元格，每个单元格的计算都是常数时间操作。
*   总时间复杂度为 `O(m * n)`。

**空间复杂度**：
*   我们创建了一个 `m x n` 大小的 `dp` 数组。
*   总空间复杂度为 `O(m * n)`。

 代码

 Java 版

**核心模式 (Core Pattern)**

```java
class Solution {
    /**
     * 计算无人机从左上角到右下角的最小能耗路径。
     * 每次只能向下或向右移动一步。
     *
     * @param grid 包含非负整数的 m x n 能耗网格。
     * @return 最小总能耗。
     */
    public int minPathSum(int[][] grid) {
        // 获取网格的行数和列数
        int m = grid.length;
        int n = grid[0].length;

        // 创建一个dp数组，dp[i][j] 表示从 (0,0) 到达 (i,j) 的最小总能耗。
        int[][] dp = new int[m][n];

        // 初始化起始点 (0,0) 的最小能耗
        dp[0][0] = grid[0][0];

        // 初始化第一行：无人机只能向右移动
        // dp[0][j] = dp[0][j-1] + grid[0][j]
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        // 初始化第一列：无人机只能向下移动
        // dp[i][0] = dp[i-1][0] + grid[i][0]
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        // 填充剩余的dp数组：对于每个单元格 (i,j)，
        // 无人机可以从上方 (i-1,j) 或 左方 (i,j-1) 移动过来。
        // 选择能耗较小的路径。
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        // 最终结果是到达右下角 (m-1, n-1) 的最小总能耗
        return dp[m - 1][n - 1];
    }
}
```

**ACM 模式 (ACM Pattern)**

```java
import java.util.Scanner;
import java.util.Arrays; // 引入Arrays用于stream操作，如果需要的话。这里直接用nextInt

public class Main {
    /**
     * 计算无人机从左上角到右下角的最小能耗路径。
     * 每次只能向下或向右移动一步。
     *
     * @param grid 包含非负整数的 m x n 能耗网格。
     * @return 最小总能耗。
     */
    public static int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int[][] dp = new int[m][n];

        dp[0][0] = grid[0][0];

        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        return dp[m - 1][n - 1];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取 m 和 n
        int m = scanner.nextInt();
        int n = scanner.nextInt();

        // 创建网格
        int[][] grid = new int[m][n];

        // 读取网格数据
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = scanner.nextInt();
            }
        }

        scanner.close();

        // 调用方法并打印结果
        System.out.println(minPathSum(grid));
    }
}
```

 Python 版

**核心模式 (Core Pattern)**

```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # 获取网格的行数和列数
        m = len(grid)
        n = len(grid[0])

        # 创建一个dp数组，dp[i][j] 表示从 (0,0) 到达 (i,j) 的最小总能耗。
        dp: List[List[int]] = [[0] * n for _ in range(m)]

        # 初始化起始点 (0,0) 的最小能耗
        dp[0][0] = grid[0][0]

        # 初始化第一行：无人机只能向右移动
        # dp[0][j] = dp[0][j-1] + grid[0][j]
        for j in range(1, n):
            dp[0][j] = dp[0][j - 1] + grid[0][j]

        # 初始化第一列：无人机只能向下移动
        # dp[i][0] = dp[i-1][0] + grid[i][0]
        for i in range(1, m):
            dp[i][0] = dp[i - 1][0] + grid[i][0]

        # 填充剩余的dp数组：对于每个单元格 (i,j)，
        # 无人机可以从上方 (i-1,j) 或 左方 (i,j-1) 移动过来。
        # 选择能耗较小的路径。
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

        # 最终结果是到达右下角 (m-1, n-1) 的最小总能耗
        return dp[m - 1][n - 1]

```

**ACM 模式 (ACM Pattern)**

```python
from typing import List

def min_path_sum(grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    dp: List[List[int]] = [[0] * n for _ in range(m)]

    dp[0][0] = grid[0][0]

    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]

    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]

    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

    return dp[m - 1][n - 1]

if __name__ == '__main__':
    # 读取 m 和 n
    m_n_str = input().split()
    m = int(m_n_str[0])
    n = int(m_n_str[1])

    # 创建网格并读取数据
    grid_input: List[List[int]] = []
    for _ in range(m):
        row_str = input().split()
        row_int = [int(x) for x in row_str]
        grid_input.append(row_int)

    # 调用函数并打印结果
    print(min_path_sum(grid_input))

```

 示例演示

以 `grid = [[1,2,3],[4,5,6],[7,8,9]]` 为例，逐步演示 `dp` 数组的计算过程。

`m = 3`, `n = 3`
初始化 `dp` 数组：
`dp = [[0, 0, 0],`
`      [0, 0, 0],`
`      [0, 0, 0]]`

1.  **初始化 `dp[0][0]`**:
    `dp[0][0] = grid[0][0] = 1`
    `dp = [[1, 0, 0],`
    `      [0, 0, 0],`
    `      [0, 0, 0]]`

2.  **初始化第一行 (`i = 0`)**:
    *   `j = 1`: `dp[0][1] = dp[0][0] + grid[0][1] = 1 + 2 = 3`
    *   `j = 2`: `dp[0][2] = dp[0][1] + grid[0][2] = 3 + 3 = 6`
    `dp = [[1, 3, 6],`
    `      [0, 0, 0],`
    `      [0, 0, 0]]`

3.  **初始化第一列 (`j = 0`)**:
    *   `i = 1`: `dp[1][0] = dp[0][0] + grid[1][0] = 1 + 4 = 5`
    *   `i = 2`: `dp[2][0] = dp[1][0] + grid[2][0] = 5 + 7 = 12`
    `dp = [[1, 3, 6],`
    `      [5, 0, 0],`
    `      [12, 0, 0]]`

4.  **填充剩余部分 (`i > 0`, `j > 0`)**:

    *   **`i = 1, j = 1`**: (单元格 `grid[1][1] = 5`)
        `dp[1][1] = min(dp[0][1], dp[1][0]) + grid[1][1]`
        `dp[1][1] = min(3, 5) + 5 = 3 + 5 = 8`
        `dp = [[1, 3, 6],`
        `      [5, 8, 0],`
        `      [12, 0, 0]]`

    *   **`i = 1, j = 2`**: (单元格 `grid[1][2] = 6`)
        `dp[1][2] = min(dp[0][2], dp[1][1]) + grid[1][2]`
        `dp[1][2] = min(6, 8) + 6 = 6 + 6 = 12`
        `dp = [[1, 3, 6],`
        `      [5, 8, 12],`
        `      [12, 0, 0]]`

    *   **`i = 2, j = 1`**: (单元格 `grid[2][1] = 8`)
        `dp[2][1] = min(dp[1][1], dp[2][0]) + grid[2][1]`
        `dp[2][1] = min(8, 12) + 8 = 8 + 8 = 16`
        `dp = [[1, 3, 6],`
        `      [5, 8, 12],`
        `      [12, 16, 0]]`

    *   **`i = 2, j = 2`**: (单元格 `grid[2][2] = 9`)
        `dp[2][2] = min(dp[1][2], dp[2][1]) + grid[2][2]`
        `dp[2][2] = min(12, 16) + 9 = 12 + 9 = 21`
        `dp = [[1, 3, 6],`
        `      [5, 8, 12],`
        `      [12, 16, 21]]`

最终结果为 `dp[2][2] = 21`，与样例输出一致。

### 解法二：动态规划 (O(min(m,n)) 空间复杂度优化)

 讲解

我们可以对解法一进行空间优化。注意到在计算 `dp[i][j]` 时，我们只依赖于 `dp[i-1][j]`（上方单元格的最小能耗）和 `dp[i][j-1]`（左方单元格的最小能耗）。这意味着我们不需要存储整个 `m x n` 的 `dp` 数组，只需要存储上一行的信息即可。

进一步，我们甚至可以只用一个一维数组来存储。这个一维数组的大小为 `n`（网格的列数）。

1.  **定义 `dp` 数组**：
    我们使用一个一维数组 `dp`，长度为 `n`。
    `dp[j]` 在处理第 `i` 行时，表示从 `(0,0)` 到达 `(i,j)` 的最小总能耗。
    在处理第 `i` 行之前，`dp[j]` 存储的是 `(i-1,j)` 的最小总能耗。

2.  **初始化**：
    *   首先，初始化 `dp` 数组的第一行。
        `dp[0] = grid[0][0]`
        对于 `j` 从 `1` 到 `n-1`：`dp[j] = dp[j-1] + grid[0][j]`。
    *   此时 `dp` 数组存储的是到达 `grid` 第一行所有单元格的最小总能耗。

3.  **状态转移**：
    从第二行开始 (`i` 从 `1` 到 `m-1`) 遍历：
    *   **更新当前行的第一个元素** (`dp[0]`)：
        `dp[0] = dp[0] + grid[i][0]`
        (这里的 `dp[0]` 在 `grid[i][0]` 左侧是上一行的 `dp[0]`，表示从 `(0,0)` 到达 `(i-1,0)` 的路径能耗，加上 `grid[i][0]` 就是到达 `(i,0)` 的路径能耗)。
    *   **更新当前行的其余元素** (`dp[j]`，`j` 从 `1` 到 `n-1`)：
        `dp[j] = min(dp[j], dp[j-1]) + grid[i][j]`
        (这里的 `dp[j]` (等号右侧) 此时是上一行 `(i-1, j)` 的最小总能耗。而 `dp[j-1]` (等号右侧) 已经更新为当前行 `(i, j-1)` 的最小总能耗。我们取两者中的最小值)。

4.  **最终结果**：
    循环结束后，`dp[n-1]`（即一维 `dp` 数组的最后一个元素）就是从左上角到右下角的最小总能耗。

**时间复杂度**：
*   依然是遍历 `m x n` 个单元格，每个单元格的计算是常数时间。
*   总时间复杂度为 `O(m * n)`。

**空间复杂度**：
*   我们只使用了一个长度为 `n` 的一维数组。
*   总空间复杂度为 `O(n)`。
*   为了实现 `O(min(m,n))` 的空间复杂度，我们可以在函数开始时检查 `m` 和 `n` 的大小，并确保 `dp` 数组的长度是较小维度的大小。例如，如果 `m < n`，我们可以将 `grid` 转置或调整循环逻辑，使 `dp` 数组的长度为 `m`。在下面的代码中，我们直接使用 `n` 作为 `dp` 数组的长度，因此空间复杂度为 `O(n)`。

 代码

 Java 版

**核心模式 (Core Pattern)**

```java
import java.util.Arrays;

class Solution {
    /**
     * 计算无人机从左上角到右下角的最小能耗路径 (O(n) 空间优化)。
     * 每次只能向下或向右移动一步。
     *
     * @param grid 包含非负整数的 m x n 能耗网格。
     * @return 最小总能耗。
     */
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        // dp 数组用于存储当前行或上一行的最小能耗信息。
        // dp[j] 表示从 (0,0) 到达当前行 (i,j) 的最小总能耗。
        int[] dp = new int[n];

        // 初始化 dp 数组的第一行 (i = 0)
        // dp[0] 存储 grid[0][0] 的能耗
        dp[0] = grid[0][0];
        // 填充第一行的其余元素，无人机只能从左边移动过来
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j - 1] + grid[0][j];
        }

        // 从第二行开始遍历 (i 从 1 到 m-1)
        for (int i = 1; i < m; i++) {
            // 更新当前行的第一个元素 (grid[i][0])
            // 无人机只能从上方 (i-1, 0) 移动过来
            dp[0] = dp[0] + grid[i][0];

            // 更新当前行的其余元素 (j 从 1 到 n-1)
            // 无人机可以从上方 (i-1, j) 或 左方 (i, j-1) 移动过来
            for (int j = 1; j < n; j++) {
                // dp[j] (在等号右边) 此时是上一行 (i-1, j) 的最小总能耗
                // dp[j-1] (在等号右边) 此时是当前行 (i, j-1) 的最小总能耗 (因为它已更新)
                dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];
            }
        }

        // 最终 dp[n-1] 存储的就是到达右下角 (m-1, n-1) 的最小总能耗
        return dp[n - 1];
    }
}
```

**ACM 模式 (ACM Pattern)**

```java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    /**
     * 计算无人机从左上角到右下角的最小能耗路径 (O(n) 空间优化)。
     * 每次只能向下或向右移动一步。
     *
     * @param grid 包含非负整数的 m x n 能耗网格。
     * @return 最小总能耗。
     */
    public static int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int[] dp = new int[n];

        dp[0] = grid[0][0];
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j - 1] + grid[0][j];
        }

        for (int i = 1; i < m; i++) {
            dp[0] = dp[0] + grid[i][0]; // 更新当前行第一个元素
            for (int j = 1; j < n; j++) {
                dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];
            }
        }

        return dp[n - 1];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int m = scanner.nextInt();
        int n = scanner.nextInt();

        int[][] grid = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = scanner.nextInt();
            }
        }

        scanner.close();

        System.out.println(minPathSum(grid));
    }
}
```

 Python 版

**核心模式 (Core Pattern)**

```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        # dp 列表用于存储当前行或上一行的最小能耗信息。
        # dp[j] 表示从 (0,0) 到达当前行 (i,j) 的最小总能耗。
        dp: List[int] = [0] * n

        # 初始化 dp 列表的第一行 (i = 0)
        # dp[0] 存储 grid[0][0] 的能耗
        dp[0] = grid[0][0]
        # 填充第一行的其余元素，无人机只能从左边移动过来
        for j in range(1, n):
            dp[j] = dp[j - 1] + grid[0][j]

        # 从第二行开始遍历 (i 从 1 到 m-1)
        for i in range(1, m):
            # 更新当前行的第一个元素 (grid[i][0])
            # 无人机只能从上方 (i-1, 0) 移动过来
            dp[0] = dp[0] + grid[i][0]

            # 更新当前行的其余元素 (j 从 1 到 n-1)
            # 无人机可以从上方 (i-1, j) 或 左方 (i, j-1) 移动过来
            for j in range(1, n):
                # dp[j] (在等号右边) 此时是上一行 (i-1, j) 的最小总能耗
                # dp[j-1] (在等号右边) 此时是当前行 (i, j-1) 的最小总能耗 (因为它已更新)
                dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]
        
        # 最终 dp[n-1] 存储的就是到达右下角 (m-1, n-1) 的最小总能耗
        return dp[n - 1]

```

**ACM 模式 (ACM Pattern)**

```python
from typing import List

def min_path_sum(grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    dp: List[int] = [0] * n

    dp[0] = grid[0][0]
    for j in range(1, n):
        dp[j] = dp[j - 1] + grid[0][j]

    for i in range(1, m):
        dp[0] = dp[0] + grid[i][0] # 更新当前行第一个元素
        for j in range(1, n):
            dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]
    
    return dp[n - 1]

if __name__ == '__main__':
    m_n_str = input().split()
    m = int(m_n_str[0])
    n = int(m_n_str[1])

    grid_input: List[List[int]] = []
    for _ in range(m):
        row_str = input().split()
        row_int = [int(x) for x in row_str]
        grid_input.append(row_int)

    print(min_path_sum(grid_input))

```

 示例演示

以 `grid = [[1,2,3],[4,5,6],[7,8,9]]` 为例，逐步演示 `dp` 数组的计算过程。

`m = 3`, `n = 3`
初始化 `dp` 数组（长度为 `n=3`）：`dp = [0, 0, 0]`

1.  **初始化第一行 (`i = 0`)**:
    *   `dp[0] = grid[0][0] = 1`
    *   `j = 1`: `dp[1] = dp[0] + grid[0][1] = 1 + 2 = 3`
    *   `j = 2`: `dp[2] = dp[1] + grid[0][2] = 3 + 3 = 6`
    **当前 `dp = [1, 3, 6]`** (代表到达 `(0,0)`, `(0,1)`, `(0,2)` 的最小总能耗)

2.  **处理第二行 (`i = 1`)**:
    *   **更新 `dp[0]`**: `dp[0] = dp[0] + grid[1][0] = 1 + 4 = 5`
        (此时 `dp[0]` 代表到达 `(1,0)` 的最小总能耗)
    *   **更新 `j = 1` (`grid[1][1] = 5`)**:
        `dp[1] = min(dp[1](旧值), dp[0](新值)) + grid[1][1]`
        `dp[1] = min(3, 5) + 5 = 3 + 5 = 8`
        (此时 `dp[1]` 代表到达 `(1,1)` 的最小总能耗)
    *   **更新 `j = 2` (`grid[1][2] = 6`)**:
        `dp[2] = min(dp[2](旧值), dp[1](新值)) + grid[1][2]`
        `dp[2] = min(6, 8) + 6 = 6 + 6 = 12`
        (此时 `dp[2]` 代表到达 `(1,2)` 的最小总能耗)
    **当前 `dp = [5, 8, 12]`** (代表到达 `(1,0)`, `(1,1)`, `(1,2)` 的最小总能耗)

3.  **处理第三行 (`i = 2`)**:
    *   **更新 `dp[0]`**: `dp[0] = dp[0] + grid[2][0] = 5 + 7 = 12`
        (此时 `dp[0]` 代表到达 `(2,0)` 的最小总能耗)
    *   **更新 `j = 1` (`grid[2][1] = 8`)**:
        `dp[1] = min(dp[1](旧值), dp[0](新值)) + grid[2][1]`
        `dp[1] = min(8, 12) + 8 = 8 + 8 = 16`
        (此时 `dp[1]` 代表到达 `(2,1)` 的最小总能耗)
    *   **更新 `j = 2` (`grid[2][2] = 9`)**:
        `dp[2] = min(dp[2](旧值), dp[1](新值)) + grid[2][2]`
        `dp[2] = min(12, 16) + 9 = 12 + 9 = 21`
        (此时 `dp[2]` 代表到达 `(2,2)` 的最小总能耗)
    **当前 `dp = [12, 16, 21]`** (代表到达 `(2,0)`, `(2,1)`, `(2,2)` 的最小总能耗)

最终结果为 `dp[n-1]`，即 `dp[2] = 21`。

 总结

这道“无人机能耗最小化路径规划”问题是经典的二维网格动态规划问题。
*   **O(m*n) 空间解法**：直观易懂，直接构建二维 `dp` 表来存储每个单元格的最小能耗。
*   **O(min(m,n)) 空间优化解法**：通过观察状态依赖性，将空间复杂度降至一维数组，这在网格维度较大时可以节省内存。在实际面试中，如果能给出空间优化的方案，通常会是加分项。











## 2025年8月26日-滴滴-第二题-寻宝之旅-线性dp 

好的，作为一名高级软件工程师，我将为您详细解析这道算法题，提供多种解法，并附上带有详尽注释的 Java 和 Python 代码。

### 题目及分析






第2题-寻宝之旅

题目内容

有一座巨大的宫殿，可以被视为由 $n$ 行 $n$ 列房间组成，从上到下分别为第 $1, 2, ..., n$ 行，从左到右分别为第 $1, 2, ..., n$ 列。第 $i$ 行第 $j$ 列房间内有价值为 $a_{i,j}$ 的宝藏。

每个房间都有一扇通往下一行同一列的常开的门，即从第 $i$ 行第 $j$ 列房间能移动到第 $i + 1$ 行第 $j$ 列房间，但是如果选择带走房间内的宝藏，则该侧门会关闭。特别地，第 $n$ 行的所有房间的通往下一行同一列的门都通往宫殿外。

除此之外，每个房间都有通往同一行下一列的门，即第 $i$ 行第 $j$ 列房间有一扇通往第 $i$ 行第 $j + 1$ 列房间的门，该门不常开，但是如果选择带走房间内的宝藏，则该侧门会打开。特别地，第 $n$ 列的所有房间的通往同一行下一列的门都通往宫殿外。

小钟从第一行第一列房间出发，他想知道在离开宫殿前他最多能带走多少价值的宝藏。请你帮助计算答案。

输入描述

输入包括多组测试数据。

输入第一行包括一个正整数 $T$ ($1 \le T \le 10$)，表示测试数据的组数。

每组测试数据的第一行有一个整数 $n$ ($1 \le n \le 500$)，表示宫殿由 $n$ 行 $n$ 列房间组成；

接下来 $n$ 行，第 $i$ 行有 $n$ 个整数 $a_{i,1}, a_{i,2}, ..., a_{i,n}$ ($0 \le a_{i,j} \le 10^5$)，依次表示第 $i$ 行 $1, 2, ..., n$ 列房间内宝藏的价值大小。

保证每个测试点的所有测试数据的 $n^2$ 的和不超过 $2.5 \times 10^5$。

输出描述

对于每组测试数据，输出一个正整数表示小钟离开宫殿前最多能带走多少价值的宝藏。

样例1

**输入**
```
2
3
1 2 3
4 5 6
7 8 9
2
0 5
3 1
```

**输出**
```
24
5
```

**说明**

对于第一组测试数据，小钟的移动轨迹可以是这样的：$(1,1) \to (2,1) \to (3,1) \to (3,2) \to (3,3) \to $ 宫殿外，分别在 $(3,1), (3,2), (3,3)$ 处带走宝藏，总价值大小为 $7 + 8 + 9 = 24$。

对于第二组测试数据，小钟的移动轨迹可以是这样的：$(1,1) \to (1,2) \to $ 宫殿外，分别在 $(1,1), (1,2)$ 处带走宝藏，总价值大小为 $0 + 5 = 5$。





**分析**


这是一个典型的二维动态规划问题，背景设定在一个 n x n 的宫殿中寻宝。我们需要找到一条从第一行任意房间出发，到宫殿外结束的最佳路径，使得沿途收集的宝藏总价值最高。

首先，我们必须精确地理解移动和获取宝藏的规则：

1.  **宫殿结构**：一个 `n x n` 的网格，房间坐标为 `(i, j)`，`1 ≤ i, j ≤ n`。
2.  **出发点**：第一行的任意一个房间，即 `(1, j)` 之一。
3.  **移动规则**：在任意一个房间 `(i, j)`，你有两种选择，这两种选择是互斥的：
    *   **选择一：向下移动**
        *   不拿取当前房间 `(i, j)` 的宝藏。
        *   移动到下一行同一列的房间 `(i+1, j)`。
        *   这是默认的移动方式，只要不拿宝藏就可以执行。
    *   **选择二：向右移动**
        *   拿取当前房间 `(i, j)` 的宝藏，价值为 `a[i][j]`。
        *   移动到同一行下一列的房间 `(i, j+1)`。
        *   这个移动的前提是必须拿走宝藏。
4.  **边界与出口规则（特殊情况）**：
    *   **最后一行 (第 n 行)**：当位于 `(n, j)` 且 `j < n` 时，无法再向下移动（因为没有 n+1 行了）。因此，唯一的选择是拿走宝藏并向右移动到 `(n, j+1)`。
    *   **最后一列 (第 n 列)**：当位于 `(i, n)` 且 `i < n` 时，无法再向右移动（因为没有 n+1 列了）。但题目特别说明：“第n列的所有房间通往同一行下一列房间的门都通往宫殿外”。这意味着从第 n 列的任何房间都可以直接向“右”离开宫殿。这给了我们一个新的选择：
        *   在 `(i, n)`，可以选择拿走宝藏 `a[i, n]` 直接离开。
        *   也可以选择不拿宝藏，继续向下移动到 `(i+1, n)`。
    *   **右下角 `(n, n)`**：这是路径的终点。无论从 `(n-1, n)` 还是 `(n, n-1)` 到达，都将拿走 `a[n, n]` 的宝藏并结束。

**核心问题**：对于每个房间，都需要做出决策（向下走还是向右走），这个决策会影响后续的路径和收益。由于当前决策依赖于后续决策能带来的最大收益，这完全符合动态规划“最优子结构”和“重叠子问题”的特征。我们可以从终点（出口）倒推回起点，计算出从每个房间出发能获得的最大收益。

---

### 解法一：动态规划 (Dynamic Programming)

 讲解

这是解决此类问题的标准且最高效的方法。我们采用“自底向上”的思路，从出口倒推计算。

1.  **状态定义**：
    `dp[i][j]` 表示：从房间 `(i, j)` 出发，按照规则移动，一直到离开宫殿所能获得的最大宝藏总价值。

2.  **状态转移方程（递推关系）**：
    我们需要从后向前、从下向上、从右向左地填充 `dp` 表。对于一个房间 `(i, j)`，它的 `dp` 值取决于它下一步能走到的房间的 `dp` 值。

    *   **基础情况 (Base Case)**：
        最右下角的房间 `(n, n)`。从这里出发，只能拿走宝藏 `a[n][n]` 然后离开。
        所以：`dp[n][n] = a[n][n]`

    *   **最后一行 (i = n, j < n)**：
        在第 `n` 行的房间 `(n, j)`，无法向下，只能拿宝藏并向右移动到 `(n, j+1)`。因此，从 `(n, j)` 出发的总收益是当前房间的宝藏加上从 `(n, j+1)` 出发能获得的所有收益。
        所以：`dp[n][j] = a[n][j] + dp[n][j+1]`

    *   **最后一列 (j = n, i < n)**：
        在第 `n` 列的房间 `(i, n)`，有两个选择：
        a. 拿走宝藏 `a[i][n]`，然后从右侧的门直接离开。收益为 `a[i][n]`。
        b. 不拿宝藏，向下移动到 `(i+1, n)`。收益为从 `(i+1, n)` 出发能获得的最大收益，即 `dp[i+1, n]`。
        我们选择收益更大的那一个。
        所以：`dp[i][n] = max(a[i][n], dp[i+1, n])`

    *   **一般情况 (i < n, j < n)**：
        在普通房间 `(i, j)`，也有两个选择：
        a. 拿走宝藏 `a[i][j]`，向右移动到 `(i, j+1)`。总收益为 `a[i][j] + dp[i, j+1]`。
        b. 不拿宝藏，向下移动到 `(i+1, j)`。总收益为 `dp[i+1, j]`。
        我们选择收益更大的那一个。
        所以：`dp[i][j] = max(a[i][j] + dp[i, j+1], dp[i+1, j])`

3.  **最终答案**：
    题目要求从从第一行第一列房间出发，所以我们需要计算出从 `(1, 1)`房间出发的最大收益。
    所以：`Answer = dp[1][1]`

 代码 (Java)

为了方便处理边界，代码中使用了 `n+1` 大小的数组，并采用 1-based 索引，与题目描述保持一致。

**核心模式**
```java
import java.util.Arrays;

class Solution {
    /**
     * 计算可以获得的最大宝藏价值
     * @param n 宫殿的尺寸 n x n
     * @param a 存储宝藏价值的二维数组
     * @return 最大宝藏价值
     */
    public long solve(int n, int[][] a) {
        // dp[i][j] 表示从 (i, j) 出发能获得的最大宝藏价值
        // 使用 long 类型防止中间结果溢出
        long[][] dp = new long[n + 1][n + 1];

        // 1. 基础情况: 从右下角 (n, n) 出发
        dp[n][n] = a[n][n];

        // 2. 填充最后一行 (i=n)
        // 从 (n, j) 只能向右走，所以是累加
        for (int j = n - 1; j >= 1; j--) {
            dp[n][j] = a[n][j] + dp[n][j + 1];
        }

        // 3. 填充最后一列 (j=n)
        // 从 (i, n) 可以选择直接带宝藏退出，或者向下走
        for (int i = n - 1; i >= 1; i--) {
            dp[i][n] = Math.max(a[i][n], dp[i + 1][n]);
        }

        // 4. 填充其余部分
        // 从右下角向左上角遍历
        for (int i = n - 1; i >= 1; i--) {
            for (int j = n - 1; j >= 1; j--) {
                // 在 (i, j)，可以选择：
                // a) 向下走 (不拿宝藏): 收益为 dp[i+1][j]
                // b) 向右走 (拿宝藏): 收益为 a[i][j] + dp[i][j+1]
                dp[i][j] = Math.max(dp[i + 1][j], a[i][j] + dp[i][j + 1]);
            }
        }

        
        return dp[1][1];
    }
}
```

**ACM 模式**
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 读取测试用例的数量 T
        int T = sc.nextInt();
        // 循环处理每个测试用例
        while (T-- > 0) {
            // 读取宫殿的大小 n
            int n = sc.nextInt();
            // 创建一个 (n+1)x(n+1) 的数组来存储宝藏价值，使用 1-based 索引
            // a[i][j] 对应题目中的 α(i,j)
            int[][] a = new int[n + 1][n + 1];
            // 循环读取 n 行 n 列的宝藏价值
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    a[i][j] = sc.nextInt();
                }
            }

            // dp[i][j] 表示从 (i, j) 出发能获得的最大宝藏价值
            // 使用 long 类型防止宝藏价值总和超过 int 的范围
            long[][] dp = new long[n + 1][n + 1];

            // 状态转移计算过程
            // 1. 基础情况: 初始化右下角 (n, n)
            dp[n][n] = a[n][n];

            // 2. 填充最后一行 (i=n)
            // 从 (n, j) 只能向右走，所以价值是当前宝藏加上右边格子的dp值
            for (int j = n - 1; j >= 1; j--) {
                dp[n][j] = a[n][j] + dp[n][j + 1];
            }

            // 3. 填充最后一列 (j=n)
            // 从 (i, n) 可以选择:
            // a) 带上当前宝藏 a[i][n] 直接离开
            // b) 不带宝藏，向下走到 (i+1, n)，获得 dp[i+1][n] 的收益
            // 取两者中的最大值
            for (int i = n - 1; i >= 1; i--) {
                dp[i][n] = Math.max(a[i][n], dp[i + 1][n]);
            }

            // 4. 填充dp表的其余部分
            // 从右下角开始，向上、向左进行计算
            for (int i = n - 1; i >= 1; i--) {
                for (int j = n - 1; j >= 1; j--) {
                    // 在 (i, j) 处，可以选择:
                    // a) 向下走 (不拿宝藏): 收益为从 (i+1, j) 出发的最大收益 dp[i+1][j]
                    // b) 向右走 (拿宝藏): 收益为当前宝藏 a[i][j] 加上从 (i, j+1) 出发的最大收益 dp[i][j+1]
                    // 取两者中的最大值
                    dp[i][j] = Math.max(dp[i + 1][j], a[i][j] + dp[i][j + 1]);
                }
            }

            // 输出当前测试用例的结果
            System.out.println(dp[1][1]);
        }
        sc.close();
    }
}
```

 代码 (Python)

**核心模式**
```python
from typing import List

class Solution:
    """
    计算可以获得的最大宝藏价值
    """
    def solve(self, n: int, a: List[List[int]]) -> int:
        # dp[i][j] 表示从 (i, j) 出发能获得的最大宝藏价值
        # 创建一个 (n+1)x(n+1) 的dp表，并初始化为0，使用 1-based 索引
        # 注意：输入的 a 可能是 0-based，这里假设传入的 a 也是 n+1 x n+1 且 1-based
        dp = [[0] * (n + 1) for _ in range(n + 1)]

        # 1. 基础情况: 从右下角 (n, n) 出发
        dp[n][n] = a[n][n]

        # 2. 填充最后一行 (i=n)
        # 从 (n, j) 只能向右走，所以是累加
        for j in range(n - 1, 0, -1):
            dp[n][j] = a[n][j] + dp[n][j + 1]

        # 3. 填充最后一列 (j=n)
        # 从 (i, n) 可以选择直接带宝藏退出，或者向下走
        for i in range(n - 1, 0, -1):
            dp[i][n] = max(a[i][n], dp[i + 1][n])

        # 4. 填充其余部分
        # 从右下角向左上角遍历
        for i in range(n - 1, 0, -1):
            for j in range(n - 1, 0, -1):
                # 在 (i, j)，可以选择：
                # a) 向下走 (不拿宝藏): 收益为 dp[i+1][j]
                # b) 向右走 (拿宝藏): 收益为 a[i][j] + dp[i][j+1]
                dp[i][j] = max(dp[i + 1][j], a[i][j] + dp[i][j + 1])

        # 5. 寻找最终答案
        # 答案是第一行第一间房的 dp 值
        return dp[1][1]
```

**ACM 模式**
```python
import sys

def main():
    """
    处理多组测试用例的主函数
    """
    # 读取所有输入行
    lines = sys.stdin.readlines()
    # 使用一个指针来追踪当前处理到哪一行
    line_idx = 0
    
    # 读取测试用例的数量 T
    T = int(lines[line_idx].strip())
    line_idx += 1

    # 循环处理每个测试用例
    for _ in range(T):
        # 读取宫殿的大小 n
        n = int(lines[line_idx].strip())
        line_idx += 1
        
        # 创建一个 (n+1)x(n+1) 的数组来存储宝藏价值，使用 1-based 索引
        # a[i][j] 对应题目中的 α(i,j)
        a = [[0] * (n + 1) for _ in range(n + 1)]
        # 循环读取 n 行 n 列的宝藏价值
        for i in range(1, n + 1):
            row_vals = list(map(int, lines[line_idx].strip().split()))
            for j in range(1, n + 1):
                a[i][j] = row_vals[j - 1]
            line_idx += 1

        # dp[i][j] 表示从 (i, j) 出发能获得的最大宝藏价值
        dp = [[0] * (n + 1) for _ in range(n + 1)]

        # 状态转移计算过程
        # 1. 基础情况: 初始化右下角 (n, n)
        dp[n][n] = a[n][n]

        # 2. 填充最后一行 (i=n)
        # 从 (n, j) 只能向右走，所以价值是当前宝藏加上右边格子的dp值
        for j in range(n - 1, 0, -1):
            dp[n][j] = a[n][j] + dp[n][j + 1]

        # 3. 填充最后一列 (j=n)
        # 从 (i, n) 可以选择带上当前宝藏 a[i][n] 直接离开，或者不带宝藏向下走到 (i+1, n)
        for i in range(n - 1, 0, -1):
            dp[i][n] = max(a[i][n], dp[i + 1][n])

        # 4. 填充dp表的其余部分
        # 从右下角开始，向上、向左进行计算
        for i in range(n - 1, 0, -1):
            for j in range(n - 1, 0, -1):
                # 在 (i, j) 处，可以选择向下走(不拿宝藏)或向右走(拿宝藏)
                go_down_val = dp[i + 1][j]
                go_right_val = a[i][j] + dp[i][j + 1]
                dp[i][j] = max(go_down_val, go_right_val)

        # 5. 寻找并打印最终答案
        # 答案是第一行第一间房的 dp 值
        print(dp[1][1])

if __name__ == "__main__":
    main()
```

 示例演示

我们使用第一个样例数据来逐步演示 DP 表的填充过程。

**输入:**
n = 3
宝藏矩阵 `a`:
1 2 3
4 5 6
7 8 9

**DP 计算过程:**

1.  **初始化 DP 表** (3x3，值为0):
    ```
    0 0 0
    0 0 0
    0 0 0
    ```

2.  **计算基础情况 `dp[3][3]`**:
    `dp[3][3] = a[3][3] = 9`
    DP 表:
    ```
    0 0 0
    0 0 0
    0 0 9
    ```

3.  **计算最后一行 (i=3)**:
    
    *   `dp[3][2] = a[3][2] + dp[3][3] = 8 + 9 = 17`
    *   `dp[3][1] = a[3][1] + dp[3][2] = 7 + 17 = 24`
    DP 表:
    ```
    0 0 0
    0 0 0
    24 17 9
    ```
```
    
4.  **计算最后一列 (j=3)**:
    *   `dp[2][3] = max(a[2][3], dp[3][3]) = max(6, 9) = 9`
    *   `dp[1][3] = max(a[1][3], dp[2][3]) = max(3, 9) = 9`
    DP 表:
```
    0 0 9
    0 0 9
    24 17 9
    ```

5.  **计算剩余格子 (从右下到左上)**:
    *   `dp[2][2] = max(dp[3][2], a[2][2] + dp[2][3]) = max(17, 5 + 9) = max(17, 14) = 17`
    *   `dp[2][1] = max(dp[3][1], a[2][1] + dp[2][2]) = max(24, 4 + 17) = max(24, 21) = 24`
    *   `dp[1][2] = max(dp[2][2], a[1][2] + dp[1][3]) = max(17, 2 + 9) = max(17, 11) = 17`
    *   `dp[1][1] = max(dp[2][1], a[1][1] + dp[1][2]) = max(24, 1 + 17) = max(24, 18) = 24`

6.  **最终 DP 表**:
    ```
    24 17 9
    24 17 9
    24 17 9
    ```

7.  **确定答案**:
    答案是第一行第一间房的 dp 值：`dp[1][1] = 24`。
    这与样例输出一致。这个 24 对应的路径就是从 `(1,1)` 出发，一直向下走到 `(3,1)`，然后拿宝藏 `7`，向右到 `(3,2)`，拿宝藏 `8`，向右到 `(3,3)`，拿宝藏 `9`，然后离开。总价值 `7 + 8 + 9 = 24`。















## [2025年9月6日-小米开发岗-第二题-迷宫速通]-
好的，作为一名高级软件工程师，我将为您详细解析这道“迷宫速通”算法题。

### 题目及分析



第2题-迷宫速通

题目内容

这是一个经典的 $N$ 行 $M$ 列的二维迷宫，每个格子有一个整数，代表这个格子的“奖励”或“惩罚”。

玩家从最左上角的格子 $(1,1)$ 出发，目的地是最右下角的格子 $(N,M)$，并且玩家只能向右或向下走。玩家在游戏开始时积分分为 $0$，并且每到一个格子（包括起始位置和终点位置），都需要把当前积分加上这个格子对应的整数（显然，整数为正就是“奖励”，若为负就是“惩罚”）。当玩家在任意时刻积分分为 $0$ 或负数时，就输掉了游戏。

马老师是玩迷宫速通的老玩家，他想到：如果格子 $(1,1)$ 对应的整数是负数，就会在游戏一开始就直接输掉游戏，有辱他的一世英名。幸好，马老师具有高超的编程技巧，一眼就能看出如果他使用黑客技术把玩家初始积分设置为 $x$，就可以通过游戏。

聪明的马老师想考考你，$x$ 最小可以是多少。

输入描述

第一行 $1$ 个整数 $T$ ($1 \le T \le 5$)，代表数据组数。
接下来一共是 $T$ 组数据，对于每组数据：
第一行包含两个整数 $N$ 和 $M$ ($1 \le N, M \le 500$)。
接下来 $N$ 行，每行包含 $M$ 个数字 $a_{ij}$ ($-1000 \le a_{ij} \le 1000$)，代表题目描述的 $N$ 行 $M$ 列的二维迷宫中每个格子对应的整数。

输出描述

输出 $T$ 行，每行 $1$ 个整数，代表 $T$ 组输入数据对应的答案。

样例1

**输入**
```
1
2 3
0 1 -3
1 -2 0
```

**输出**
```
2
```

**说明**
如果玩家初始积分为 $1$，那不管怎么走都会在迷宫中间输掉游戏，所以最少需要 $2$ 个积分。



**分析**


这道题本质上是经典 "Dungeon Game" (地下城游戏) 问题的变体。我们需要在一个 `N x M` 的网格中，从左上角 `(1, 1)` 移动到右下角 `(N, M)`，移动方向只能是向右或向下。每个格子有一个整数，代表得分或扣分。我们的目标是找到一个最小的初始积分 `x`，使得从起点到终点的任意一条路径上，玩家的积分始终大于 0。

**核心挑战分析：**

1.  **不是求路径最大和**：这题和传统的“最大路径和”问题不同。一条路径最终得分很高，但中间可能有一个点的积分降到了 0 或以下，导致游戏失败。例如，初始积分 `x=5`，路径是 `-10, +100`，在第一步积分就变成了 `-5`，游戏失败，即使最终能达到很高的分数。
2.  **“存活”是首要条件**：关键在于路径上的“最低点”。我们需要保证在每一步，`当前积分 + 格子值 > 0`。
3.  **逆向思维**：正向思考（从 `(1,1)` 到 `(N,M)`）会很困难。因为在任意点 `(i, j)`，我们不仅需要知道到达这里的最大积分，还需要知道为了达到这个最大积分，路径上的最低积分是多少，状态定义会变得非常复杂。而如果我们**从终点 `(N, M)` 反向推导回起点 `(1, 1)`**，问题会变得清晰。我们可以思考：“要想到达终点并存活，我在上一个格子 `(N-1, M)` 或 `(N, M-1)` 时，至少需要多少积分？”

---

### 解法一：动态规划 (自底向上)

 讲解

这是解决此类问题的最优且最直接的方法。我们采用逆向思维，从终点 `(N, M)` 向起点 `(1, 1)` 进行动态规划。

1.  **状态定义**：
    `dp[i][j]` 表示：从格子 `(i, j)` 出发，安全到达终点 `(N, M)` 所需要的**最小初始积分**。我们的最终目标就是求 `dp[1][1]`。

2.  **状态转移方程（递推关系）**：
    我们从右下角开始，向左、向上填充 `dp` 表。

    *   **基础情况 (Base Case) - 终点 `(N, M)`**：
        假设我们在终点 `(N, M)` 时，需要的积分为 `dp[N][M]`。进入这个格子后，我们的积分变为 `dp[N][M] + a[N][M]`。为了存活，这个值必须 `≥ 1`。
        所以 `dp[N][M] + a[N][M] ≥ 1`，即 `dp[N][M] ≥ 1 - a[N][M]`。
        因为 `dp[N][M]` 是积分，它本身也必须 `≥ 1`。所以，我们取这两者的最大值。
        `dp[N][M] = max(1, 1 - a[N][M])`

    *   **最后一行 (i = N, j < M)**：
        在 `(N, j)` 这个格子，我们只能向右移动到 `(N, j+1)`。从 `(N, j+1)` 出发到终点，我们至少需要 `dp[N][j+1]` 的积分。
        那么，在进入 `(N, j)` 之前，我们需要的积分 `dp[N][j]` 必须满足：`dp[N][j] + a[N][j] ≥ dp[N][j+1]`。
        即 `dp[N][j] ≥ dp[N][j+1] - a[N][j]`。
        同样，`dp[N][j]` 自身也必须 `≥ 1`。
        `dp[N][j] = max(1, dp[N][j+1] - a[N][j])`

    *   **最后一列 (j = M, i < N)**：
        在 `(i, M)` 这个格子，我们只能向下移动到 `(i+1, M)`。逻辑同上。
        `dp[i][M] = max(1, dp[i+1][M] - a[i][M])`

    *   **一般情况 (i < N, j < M)**：
        在 `(i, j)`，我们可以选择向下走到 `(i+1, j)` 或者向右走到 `(i, j+1)`。为了保证能存活，我们会选择那条**后续所需积分更少**的路径。
        从 `(i+1, j)` 出发需要 `dp[i+1][j]` 的积分。
        从 `(i, j+1)` 出发需要 `dp[i][j+1]` 的积分。
        我们会选择更优的，即 `min(dp[i+1][j], dp[i][j+1])`。
        设 `needed_for_future = min(dp[i+1][j], dp[i][j+1])`。
        那么在进入 `(i, j)` 之前，我们需要的积分 `dp[i][j]` 必须满足：`dp[i][j] + a[i][j] ≥ needed_for_future`。
        即 `dp[i][j] ≥ needed_for_future - a[i][j]`。
        结合 `dp[i][j] ≥ 1` 的条件：
        `dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - a[i][j])`

3.  **最终答案**：
    通过以上递推关系，我们从右下角一直计算到左上角，`dp[1][1]` 就是我们要求的最小初始积分 `x`。

 代码 (Java)

**核心模式**
```java
class Solution {
    /**
     * 计算通关迷宫所需的最小初始积分
     * @param N 迷宫的行数
     * @param M 迷宫的列数
     * @param a 存储迷宫奖励/惩罚值的二维数组 (0-based index)
     * @return 最小初始积分
     */
    public int solve(int N, int M, int[][] a) {
        // dp[i][j] 表示从 (i, j) 出发到达终点所需的最小初始积分
        int[][] dp = new int[N][M];

        // 1. 基础情况: 计算终点 (N-1, M-1) 所需的最小积分
        // 记 a[i][j] 为 grid[i][j]
        // 到达 (N-1, M-1) 后，积分需要 >= 1，即 dp[N-1][M-1] + a[N-1][M-1] >= 1
        // 所以 dp[N-1][M-1] >= 1 - a[N-1][M-1]
        // 同时，初始积分本身不能小于1
        dp[N - 1][M - 1] = Math.max(1, 1 - a[N - 1][M - 1]);

        // 2. 填充最后一行 (从右到左)
        for (int j = M - 2; j >= 0; j--) {
            // 从 (N-1, j) 只能到 (N-1, j+1)
            // 需要的积分 dp[N-1][j] 必须满足 dp[N-1][j] + a[N-1][j] >= dp[N-1][j+1]
            dp[N - 1][j] = Math.max(1, dp[N - 1][j + 1] - a[N - 1][j]);
        }

        // 3. 填充最后一列 (从下到上)
        for (int i = N - 2; i >= 0; i--) {
            // 从 (i, M-1) 只能到 (i+1, M-1)
            // 需要的积分 dp[i][M-1] 必须满足 dp[i][M-1] + a[i][M-1] >= dp[i+1][M-1]
            dp[i][M - 1] = Math.max(1, dp[i + 1][M - 1] - a[i][M - 1]);
        }

        // 4. 填充其余部分 (从右下到左上)
        for (int i = N - 2; i >= 0; i--) {
            for (int j = M - 2; j >= 0; j--) {
                // 从 (i, j) 可以到 (i+1, j) 或 (i, j+1)
                // 选择后续所需积分较小的路径
                int minNeedForFuture = Math.min(dp[i + 1][j], dp[i][j + 1]);
                // 计算当前点所需的最小积分
                dp[i][j] = Math.max(1, minNeedForFuture - a[i][j]);
            }
        }

        // 5. 最终答案在左上角
        return dp[0][0];
    }
}
```

**ACM 模式**
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 读取测试用例的数量 T
        int T = sc.nextInt();
        while (T-- > 0) {
            // 读取迷宫的行数 N 和列数 M
            int N = sc.nextInt();
            int M = sc.nextInt();
            // 创建二维数组存储迷宫数据 (使用 0-based 索引)
            int[][] a = new int[N][M];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    a[i][j] = sc.nextInt();
                }
            }

            // dp[i][j] 表示从 (i, j) 出发安全到达终点所需的最小初始积分
            int[][] dp = new int[N][M];

            // 1. 基础情况: 终点 (N-1, M-1)
            // 在该点存活，需要 dp + a >= 1，所以 dp >= 1 - a
            // 同时 dp 本身必须 >= 1
            dp[N - 1][M - 1] = Math.max(1, 1 - a[N - 1][M - 1]);

            // 2. 填充最后一行 (从右向左)
            for (int j = M - 2; j >= 0; j--) {
                // 从 (N-1, j) 只能向右到 (N-1, j+1)
                // 为了能满足 (N-1, j+1) 的最低积分要求 dp[N-1][j+1]，
                // 在 (N-1, j) 之前需要的积分 dp[N-1][j] 必须满足:
                // dp[N-1][j] + a[N-1][j] >= dp[N-1][j+1]
                dp[N - 1][j] = Math.max(1, dp[N - 1][j + 1] - a[N - 1][j]);
            }

            // 3. 填充最后一列 (从下向上)
            for (int i = N - 2; i >= 0; i--) {
                // 从 (i, M-1) 只能向下到 (i+1, M-1)，逻辑同上
                dp[i][M - 1] = Math.max(1, dp[i + 1][M - 1] - a[i][M - 1]);
            }

            // 4. 填充内部格子 (从右下到左上)
            for (int i = N - 2; i >= 0; i--) {
                for (int j = M - 2; j >= 0; j--) {
                    // 从 (i, j) 出发，可以选择向下或向右
                    // 我们选择后续路径所需积分更少的那一条
                    int minNeedForFuture = Math.min(dp[i + 1][j], dp[i][j + 1]);
                    // 计算当前点 (i, j) 所需的最小积分
                    dp[i][j] = Math.max(1, minNeedForFuture - a[i][j]);
                }
            }
            
            // 最终答案即为从起点 (0,0) 出发所需的最小积分
            System.out.println(dp[0][0]);
        }
        sc.close();
    }
}
```

 代码 (Python)

**核心模式**
```python
from typing import List

class Solution:
    """
    计算通关迷宫所需的最小初始积分
    """
    def solve(self, N: int, M: int, a: List[List[int]]) -> int:
        # dp[i][j] 表示从 (i, j) 出发到达终点所需的最小初始积分
        dp = [[0] * M for _ in range(N)]

        # 1. 基础情况: 计算终点 (N-1, M-1) 所需的最小积分
        # 到达 (N-1, M-1) 后，积分需要 >= 1，即 dp + a >= 1
        # 所以 dp >= 1 - a。同时，初始积分本身不能小于1
        dp[N - 1][M - 1] = max(1, 1 - a[N - 1][M - 1])

        # 2. 填充最后一行 (从右到左)
        for j in range(M - 2, -1, -1):
            # 从 (N-1, j) 只能到 (N-1, j+1)
            # dp[N-1][j] + a[N-1][j] >= dp[N-1][j+1]
            dp[N - 1][j] = max(1, dp[N - 1][j + 1] - a[N - 1][j])

        # 3. 填充最后一列 (从下到上)
        for i in range(N - 2, -1, -1):
            # 从 (i, M-1) 只能到 (i+1, M-1)
            # dp[i][M-1] + a[i][M-1] >= dp[i+1][M-1]
            dp[i][M - 1] = max(1, dp[i + 1][M - 1] - a[i][M - 1])

        # 4. 填充其余部分 (从右下到左上)
        for i in range(N - 2, -1, -1):
            for j in range(M - 2, -1, -1):
                # 从 (i, j) 可以到 (i+1, j) 或 (i, j+1)
                # 选择后续所需积分较小的路径
                min_need_for_future = min(dp[i + 1][j], dp[i][j + 1])
                # 计算当前点所需的最小积分
                dp[i][j] = max(1, min_need_for_future - a[i][j])

        # 5. 最终答案在左上角
        return dp[0][0]

```

**ACM 模式**
```python
import sys

def solve():
    """
    单个测试用例的解决函数
    """
    # 读取行数 N 和列数 M
    try:
        line = sys.stdin.readline()
        if not line: return
        N, M = map(int, line.strip().split())
    except (IOError, ValueError):
        return

    # 读取迷宫数据
    a = []
    for _ in range(N):
        a.append(list(map(int, sys.stdin.readline().strip().split())))

    # dp[i][j] 表示从 (i, j) 出发到达终点所需的最小初始积分
    dp = [[0] * M for _ in range(N)]

    # 1. 基础情况: 终点 (N-1, M-1)
    dp[N - 1][M - 1] = max(1, 1 - a[N - 1][M - 1])

    # 2. 填充最后一行
    for j in range(M - 2, -1, -1):
        dp[N - 1][j] = max(1, dp[N - 1][j + 1] - a[N - 1][j])

    # 3. 填充最后一列
    for i in range(N - 2, -1, -1):
        dp[i][M - 1] = max(1, dp[i + 1][M - 1] - a[i][M - 1])

    # 4. 填充内部格子
    for i in range(N - 2, -1, -1):
        for j in range(M - 2, -1, -1):
            min_need_for_future = min(dp[i + 1][j], dp[i][j + 1])
            dp[i][j] = max(1, min_need_for_future - a[i][j])

    # 打印结果
    print(dp[0][0])

def main():
    """
    主函数，处理多组测试用
    """
    try:
        T_str = sys.stdin.readline()
        if not T_str: return
        T = int(T_str.strip())
        for _ in range(T):
            solve()
    except (IOError, ValueError):
        return

if __name__ == "__main__":
    main()

```

 示例演示

我们使用题目给的样例数据来逐步演示 DP 表的填充过程。

**输入:**
N = 2, M = 3
迷宫矩阵 `a`:
0   1  -3
1  -2   0

**DP 计算过程 (使用 0-based 索引):**

1.  **初始化 DP 表** (2x3，值为0):
    ```
    0 0 0
    0 0 0
    ```

2.  **计算基础情况 `dp[1][2]` (终点)**:
    `a[1][2] = 0`
    `dp[1][2] = max(1, 1 - a[1][2]) = max(1, 1 - 0) = 1`
    DP 表:
    ```
    0 0 0
    0 0 1
    ```

3.  **计算最后一行 (i=1)**:
    *   `dp[1][1]` (从右向左):
        `a[1][1] = -2`
        `dp[1][1] = max(1, dp[1][2] - a[1][1]) = max(1, 1 - (-2)) = max(1, 3) = 3`
    *   `dp[1][0]`:
        `a[1][0] = 1`
        `dp[1][0] = max(1, dp[1][1] - a[1][0]) = max(1, 3 - 1) = max(1, 2) = 2`
    DP 表:
    ```
    0 0 0
    2 3 1
    ```

4.  **计算最后一列 (j=2)**:
    *   `dp[0][2]` (从下向上):
        `a[0][2] = -3`
        `dp[0][2] = max(1, dp[1][2] - a[0][2]) = max(1, 1 - (-3)) = max(1, 4) = 4`
    DP 表:
    ```
    0 0 4
    2 3 1
    ```

5.  **计算剩余格子 (从右下到左上)**:
    *   `dp[0][1]`:
        `a[0][1] = 1`
        `needed_for_future = min(dp[1][1], dp[0][2]) = min(3, 4) = 3`
        `dp[0][1] = max(1, needed_for_future - a[0][1]) = max(1, 3 - 1) = max(1, 2) = 2`
    *   `dp[0][0]` (最终答案):
        `a[0][0] = 0`
        `needed_for_future = min(dp[1][0], dp[0][1]) = min(2, 2) = 2`
        `dp[0][0] = max(1, needed_for_future - a[0][0]) = max(1, 2 - 0) = max(1, 2) = 2`

6.  **最终 DP 表**:
    ```
    2 2 4
    2 3 1
    ```

7.  **确定答案**:
    答案是 `dp[0][0] = 2`。这与样例输出一致。这意味着，我们至少需要 2 个初始积分才能保证安全通关。

---

### 解法二：二分答案 + DP/BFS (可行性检查)

 讲解

这道题的答案具有**单调性**：如果 `x` 点初始积分可以通关，那么 `x+1` 点初始积分一定也可以通关。如果 `x` 点无法通关，那么 `x-1` 点也一定无法通关。这种单调性是使用**二分查找**来解决问题的完美信号。

我们可以二分查找最终的答案 `x`。对于每一个猜测的 `mid` 值，我们去验证 "以 `mid` 作为初始积分，是否能够通关？"。

1.  **二分框架**：
    *   确定答案的范围。下界 `left = 1`。上界 `right` 可以是一个足够大的数，比如所有负数惩罚之和的绝对值再加 1，或者一个保守的 `N*M*1000 + 1`。
    *   在 `[left, right]` 范围内进行二分。
    *   `mid = left + (right - left) / 2`。
    *   调用 `check(mid)` 函数判断可行性。
    *   如果 `check(mid)` 为 `true`，说明 `mid` 可能是一个解，但我们想找最小的，所以尝试更小的值：`ans = mid`, `right = mid - 1`。
    *   如果 `check(mid)` 为 `false`，说明 `mid` 太小了，需要更大的初始积分：`left = mid + 1`。

2.  **`check(x)` 函数实现**：
    这个函数的作用是判断以 `x` 为初始积分是否能通关。这本身就是一个可以用 DP 或 BFS 解决的路径问题。我们这里用 DP 来实现。

    *   **状态定义**: `dp_check[i][j]` 表示以 `x` 为初始积分，到达格子 `(i, j)` 时能获得的**最大积分**。
    *   **状态转移**:
        *   `dp_check[0][0] = x + a[0][0]`。如果此时 `≤ 0`，则 `x` 不可行。
        *   `dp_check[i][j] = max(dp_check[i-1][j], dp_check[i][j-1]) + a[i][j]`。
        *   在计算 `max` 时，我们只能从可达的上边和左边格子转移过来。一个格子 `(r, c)` 是可达的，当且仅当 `dp_check[r][c] > 0`。如果 `dp_check[i-1][j]` 和 `dp_check[i][j-1]` 都 `≤ 0`（或无法到达），那么 `(i, j)` 也无法到达。
    *   **结果**: 如果最终 `dp_check[N-1][M-1] > 0`，说明存在一条路径可以通关，`check(x)` 返回 `true`。

这种方法虽然逻辑上可行，但通常比解法一慢，因为它需要多次执行 `check` 函数，而每次 `check` 都是一次 `O(N*M)` 的 DP。总时间复杂度为 `O(N*M * log(Range))`。对于本题的数据范围，解法一 `O(N*M)` 已经足够快且更简洁。因此，这里不再提供该解法的完整代码，但理解其思想对于拓宽解题思路非常有帮助。









