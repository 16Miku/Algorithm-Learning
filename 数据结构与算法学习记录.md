

# 基础知识


## 详细讲解acm模式



好的，我们来详细讲解一下 "ACM 模式"，这通常指的是在在线判题系统 (Online Judge, OJ) 和算法竞赛（特别是 ACM/ICPC 风格的竞赛）中使用的一种特定的输入输出处理模式。理解 ACM 模式对于参加算法竞赛和在 OJ 上进行编程练习至关重要。

**1. 什么是 ACM 模式？它与核心模式 (Core Mode) 的区别**

在在线判题系统中，通常有两种主要的输入输出模式：**ACM 模式** 和 **核心模式 (Core Mode)**。

*   **核心模式 (Core Mode)**：

    *   你只需要编写一个函数（通常是 `solution` 或题目要求的函数名），这个函数会接收题目给出的输入参数，并返回计算结果。
    *   OJ 平台会负责处理所有的输入和输出。平台会读取测试用例的输入数据，调用你编写的函数，然后将函数返回的结果按照规定的格式输出。
    *   你无需关心输入数据的读取、解析，以及输出结果的格式化。你只需要专注于实现核心的算法逻辑。
    *   **优点：** 更加专注于算法本身，简化了输入输出处理的复杂度，降低了初学者的门槛。
    *   **缺点：**  缺乏对输入输出的控制，不利于提高处理复杂输入输出场景的能力。在实际工程中，通常需要自己处理输入输出。

*   **ACM 模式**：

    *   你需要编写**完整的程序代码**，包括程序入口（如 `main` 函数），**负责处理所有的输入和输出**。
    *   程序需要从标准输入 (Standard Input, `stdin`) 读取数据，并按照题目要求的格式将结果输出到标准输出 (Standard Output, `stdout`)。
    *   OJ 平台只负责运行你的程序，并检查你的程序输出是否与标准答案一致。平台**不**会提供任何输入输出的框架代码。
    *   **优点：**  更接近实际的软件开发模式，需要掌握完整的程序编写能力，包括输入输出处理、错误处理等。能够锻炼处理各种复杂输入输出场景的能力。
    *   **缺点：**  对初学者来说，需要额外学习输入输出处理，增加了学习曲线的陡峭程度。

**总结：**

| 特性         | 核心模式 (Core Mode)                               | ACM 模式                                         |
| ------------ | -------------------------------------------------- | ------------------------------------------------ |
| 程序结构     | 只需实现核心函数                                     | 需要编写完整的程序 (包含 `main` 函数)             |
| 输入处理     | OJ 平台负责读取和解析输入                           | 程序需要自行从标准输入读取和解析数据               |
| 输出处理     | OJ 平台负责格式化和输出结果                         | 程序需要自行按照规定格式输出到标准输出             |
| 关注点       | 算法逻辑                                           | 完整的程序编写，包括输入输出、算法逻辑             |
| 难度         | 相对简单，更适合初学者快速上手算法                  | 相对复杂，需要更全面的编程技能                     |
| 实际应用     | 算法学习的入门练习                                 | 更接近实际软件开发，算法竞赛的常见模式             |

**2. ACM 模式的输入输出格式**

在 ACM 模式下，你需要严格按照题目描述的输入输出格式来编写程序。常见的输入输出格式特点包括：

*   **标准输入 (stdin)：** 程序从标准输入流读取数据。在大多数编程语言中，都有相应的库函数来读取标准输入。例如：
    *   **C/C++:** `scanf`, `cin`, `fgets`, `getchar` 等
    *   **Java:** `Scanner`, `BufferedReader` 等
    *   **Python:** `input()`, `sys.stdin.readline()` 等
    *   **JavaScript (Node.js):** `process.stdin`
    *   **Go:** `bufio.NewReader(os.Stdin)`
*   **标准输出 (stdout)：** 程序将结果输出到标准输出流。例如：
    *   **C/C++:** `printf`, `cout`, `fputs`, `putchar` 等
    *   **Java:** `System.out.print`, `System.out.println`, `PrintWriter` 等
    *   **Python:** `print()` , `sys.stdout.write()` 等
    *   **JavaScript (Node.js):** `console.log`
    *   **Go:** `fmt.Print`, `fmt.Println`, `bufio.NewWriter(os.Stdout)`
*   **多组测试用例：** 很多 ACM 题目会包含多组测试用例。你的程序需要能够**循环读取**多组输入数据，并对每组数据都输出正确的结果。通常题目会明确说明测试用例的数量或者使用某种方式来指示输入结束（如输入 `0` 表示结束，或者读到文件末尾 EOF）。
*   **特定格式要求：** 题目会详细描述输入数据的格式（例如，每行几个数字，数字的范围，字符串的格式等）和输出结果的格式（例如，每行输出一个数字，数字之间用空格分隔，字符串的格式等）。**务必严格按照题目要求格式化输出，包括空格、换行符等，否则可能会判为 "Presentation Error" (格式错误)。**
*   **时间限制和内存限制：**  OJ 平台会对程序的运行时间和内存使用进行限制。你的程序需要在限制内完成计算并输出结果，否则会判为 "Time Limit Exceeded" (超时) 或 "Memory Limit Exceeded" (内存超限)。因此，算法效率和内存优化也是 ACM 模式编程中需要考虑的重要因素。

**3. 常用编程语言和库**

在 ACM 竞赛中，常见的编程语言包括：

*   **C++:**  速度快，库丰富（STL 标准模板库），是竞赛中最流行的语言。
*   **Java:**  面向对象，库强大，适合处理复杂数据结构和算法，但运行速度相对 C++ 稍慢。
*   **Python:**  语法简洁，易于学习，适合快速实现算法原型，但运行速度较慢，在对时间要求严格的题目中可能不适用。
*   **Go:**  新兴语言，并发性能好，运行速度较快，越来越受到竞赛选手的关注。

针对 ACM 模式的输入输出，各语言都有一些常用的库和技巧：

*   **C++:**
    *   `iostream` 库 (`cin`, `cout`) 用于基本的输入输出。
    *   `cstdio` 库 (`scanf`, `printf`) 在某些情况下可能比 `cin`, `cout` 更快，尤其是在大量数据输入输出时。
    *   `string` 类用于字符串处理。
    *   STL (Standard Template Library) 提供了丰富的数据结构（如 `vector`, `list`, `deque`, `set`, `map`, `stack`, `queue`, `priority_queue` 等）和算法，极大地提高了编程效率。
*   **Java:**
    *   `Scanner` 类用于方便地读取各种类型的输入。
    *   `BufferedReader` 和 `PrintWriter` 通常用于更高效的大量数据输入输出。
    *   `String` 类用于字符串处理。
    *   Java 集合框架 (Collections Framework) 提供了丰富的数据结构（如 `ArrayList`, `LinkedList`, `HashSet`, `HashMap`, `Stack`, `Queue`, `PriorityQueue` 等）。
*   **Python:**
    *   `input()` 函数用于读取一行输入（作为字符串）。
    *   `sys.stdin.readline()` 可以更快地读取一行输入，尤其是在大量输入时。
    *   `print()` 函数用于输出。
    *   Python 的内置数据结构（如 `list`, `tuple`, `dict`, `set`）非常强大和灵活。
*   **Go:**
    *   `fmt` 包 (`fmt.Scan`, `fmt.Printf`, `fmt.Println`) 用于基本的格式化输入输出。
    *   `bufio` 包 (`bufio.NewReader`, `bufio.NewWriter`) 用于缓冲输入输出，提高效率。
    *   Go 的内置数据结构（如 `slice`, `map`）和强大的标准库也十分有用。

**4. 错误处理和调试**

在 ACM 模式下，常见的错误类型包括：

*   **Wrong Answer (WA)：**  程序输出的结果与标准答案不一致，说明算法逻辑或实现有错误。
*   **Time Limit Exceeded (TLE)：** 程序运行时间超过了题目限制，说明算法效率不够高，需要优化算法或数据结构。
*   **Memory Limit Exceeded (MLE)：** 程序使用的内存超过了题目限制，说明程序使用了过多的内存，需要优化内存使用。
*   **Runtime Error (RE)：** 程序在运行时发生错误，例如数组越界、除零错误、空指针访问等。
*   **Presentation Error (PE)：** 程序输出的结果内容正确，但格式不符合题目要求（例如，多余或缺少空格、换行符等）。
*   **Compilation Error (CE)：** 程序代码无法通过编译，通常是语法错误或使用了未包含的库。

**调试技巧：**

*   **本地调试：**  在本地 IDE (如 VS Code, CLion, Eclipse, IntelliJ IDEA) 上编写和调试代码。可以使用本地的输入文件进行测试，并使用断点、单步执行等调试工具来定位错误。
*   **输出中间结果：**  在代码中添加临时的 `print` 或 `cout` 语句，输出中间计算结果，帮助理解程序的执行流程和变量的值，从而发现错误。
*   **特殊用例测试：**  构造一些特殊的测试用例，例如边界情况、极端情况、小规模数据、大规模数据等，来测试程序的健壮性和正确性。
*   **对比输出：**  将程序的输出与标准答案或预期输出进行对比，找出差异，分析错误原因。
*   **使用 OJ 平台的调试工具 (如果提供)：** 有些 OJ 平台提供在线调试功能，可以帮助你更方便地在 OJ 环境下调试代码。

**5. 示例输入和输出**

假设题目描述如下：

**题目：A+B Problem**

输入两个整数 A 和 B，计算它们的和并输出。

**输入格式：**

输入包含多组测试用例。
每组测试用例占一行，包含两个整数 A 和 B，用空格分隔。
当输入 `0 0` 时表示输入结束，不需要处理。

**输出格式：**

对于每组测试用例，输出 A+B 的结果，每组结果占一行。

**样例输入：**

```
1 2
3 4
5 6
0 0
```

**样例输出：**

```
3
7
11
```

**C++ 代码示例 (ACM 模式):**

```cpp
#include <iostream>

int main() {
    int a, b;
    while (std::cin >> a >> b && (a != 0 || b != 0)) { // 循环读取输入，直到输入 0 0 结束
        int sum = a + b;
        std::cout << sum << std::endl; // 输出结果并换行
    }
    return 0;
}
```

**Java 代码示例 (ACM 模式):**

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNextInt()) { // 循环读取输入，直到没有更多整数输入
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            if (a == 0 && b == 0) { // 判断输入是否为 0 0，如果是则结束循环
                break;
            }
            int sum = a + b;
            System.out.println(sum); // 输出结果并换行
        }
        scanner.close();
    }
}
```

**Python 代码示例 (ACM 模式):**

```python
import sys

for line in sys.stdin:
    a, b = map(int, line.split())
    if a == 0 and b == 0:
        break
    sum_val = a + b
    print(sum_val)
```

**6. 练习平台**

有很多在线判题平台支持 ACM 模式，你可以通过这些平台进行练习：

*   **LeetCode:** (虽然 LeetCode 主要使用核心模式，但在 "Contest" 竞赛模式中也常有 ACM 模式的题目)
*   **Codeforces:**  著名的算法竞赛平台，题目质量高，比赛频繁，完全是 ACM 模式。
*   **AtCoder:**  日本的算法竞赛平台，题目难度分级清晰，适合不同水平的选手，也是 ACM 模式。
*   **牛客网:**  中国的算法竞赛和求职平台，有大量的 ACM 模式练习题和比赛。
*   **POJ (Peking University Online Judge):**  老牌的 OJ 平台，有很多经典的 ACM 题目。
*   **洛谷:**  中国的 OJ 平台，适合初学者和进阶选手，也支持 ACM 模式。
*   **HDU (Hangzhou Dianzi University Online Judge):**  中国的 OJ 平台，题目数量多，适合练习。
*   **VJ (Virtual Judge):**  一个聚合了多个 OJ 平台的虚拟 OJ，可以在 VJ 上练习来自不同平台的题目。

**7. ACM 模式的优势和劣势**

**优势：**

*   **更贴近实际开发：**  ACM 模式的编程方式更接近实际软件开发，需要考虑完整的程序结构、输入输出处理、错误处理等，锻炼更全面的编程能力。
*   **提高解决复杂问题的能力：**  ACM 模式的题目通常更综合、更复杂，需要综合运用算法、数据结构、编程技巧来解决，有助于提高解决复杂问题的能力。
*   **为算法竞赛做准备：**  ACM 模式是 ACM/ICPC 等算法竞赛的标配模式，熟悉 ACM 模式是参加这类竞赛的基础。

**劣势：**

*   **学习曲线较陡峭：**  对初学者来说，需要额外学习输入输出处理，增加了学习难度。
*   **容易因输入输出错误失分：**  ACM 模式对输入输出格式要求严格，容易因为格式错误（如多余空格、换行符）导致 "Presentation Error"，需要仔细处理。
*   **调试难度可能较高：**  相比核心模式，ACM 模式的程序结构更复杂，调试时需要考虑输入输出的环节，可能增加调试难度。

**8. 成功应对 ACM 模式的关键技能**

*   **扎实的编程基础：**  熟练掌握至少一种编程语言 (C++, Java, Python, Go)，包括语法、常用库、数据结构和算法。
*   **快速输入输出能力：**  掌握高效的输入输出方法，避免因输入输出效率低下导致超时。
*   **细致的格式控制：**  严格按照题目要求格式化输出，避免 "Presentation Error"。
*   **良好的调试习惯：**  学会本地调试、输出中间结果、构造测试用例等调试技巧，快速定位和解决错误。
*   **算法和数据结构知识：**  掌握常见的算法（如排序、搜索、动态规划、图论算法等）和数据结构（如数组、链表、栈、队列、树、图、哈希表等），能够根据题目选择合适的算法和数据结构。
*   **练习和积累：**  通过大量的练习，熟悉 ACM 模式的题型和解题方法，积累经验，提高解题速度和准确率。

总而言之，ACM 模式是一种更具挑战性但也更贴近实际、更锻炼能力的编程模式。通过学习和练习 ACM 模式，可以有效地提高你的编程技能和算法水平，为你参加算法竞赛和未来的软件开发打下坚实的基础。




---




















## 极尽详细的为我讲解java中的关于输入输出的所有相关知识，并给出具体使用示例







好的，非常乐意为您极尽详细地讲解 Java 中的输入/输出 (I/O) 相关知识，并提供具体的使用示例。Java 的 I/O 系统是一个庞大且重要的组成部分，理解它对于编写各种类型的 Java 应用程序至关重要。

**1. Java I/O 的基本概念：流 (Streams)**

在 Java I/O 中，**流 (Stream)** 是一个核心概念。你可以把流想象成数据在源和目标之间流动的管道。Java 的 I/O 操作都是围绕着流进行的。

*   **数据源和目的地:**  流连接着数据源和目的地。数据源可以是文件、内存、网络连接、控制台等；目的地同样可以是文件、内存、网络连接、控制台等。
*   **数据流动方向:**  流分为**输入流 (Input Stream)** 和 **输出流 (Output Stream)**。
    *   **输入流 (Input Stream):** 用于从数据源读取数据到程序中（例如，从文件读取数据到内存）。
    *   **输出流 (Output Stream):** 用于将程序中的数据写入到目的地（例如，将内存中的数据写入到文件）。
*   **数据类型:** 流又可以根据处理的数据类型分为两类：
    *   **字节流 (Byte Streams):**  处理 8 位字节数据。主要用于处理二进制数据，例如图片、音频、视频文件等。字节流的抽象基类是 `InputStream` 和 `OutputStream`。
    *   **字符流 (Character Streams):**  处理 16 位 Unicode 字符数据。主要用于处理文本数据，例如文本文件、字符数据等。字符流的抽象基类是 `Reader` 和 `Writer`。字符流在字节流的基础上进行了封装，考虑了字符编码问题，更方便处理文本数据。

**2. Java I/O 类层次结构**

Java I/O 库提供了丰富的类来处理各种输入输出操作。这些类主要位于 `java.io` 包中。了解其层次结构有助于理解和使用这些类。

*   **字节流 (Byte Streams)**

    ```
    InputStream (抽象类 - 所有字节输入流的基类)
        |-- FileInputStream (文件输入流)
        |-- ByteArrayInputStream (字节数组输入流)
        |-- ObjectInputStream (对象输入流 - 用于反序列化)
        |-- FilterInputStream (过滤输入流 - 抽象类)
            |-- BufferedInputStream (缓冲输入流 - 提高效率)
            |-- DataInputStream (数据输入流 - 读取基本数据类型)
            |-- PrintStream (打印输出流 - System.out/System.err 的类型, 也可作为输入流使用，但不常见)

    OutputStream (抽象类 - 所有字节输出流的基类)
        |-- FileOutputStream (文件输出流)
        |-- ByteArrayOutputStream (字节数组输出流)
        |-- ObjectOutputStream (对象输出流 - 用于序列化)
        |-- FilterOutputStream (过滤输出流 - 抽象类)
            |-- BufferedOutputStream (缓冲输出流 - 提高效率)
            |-- DataOutputStream (数据输出流 - 写入基本数据类型)
            |-- PrintStream (打印输出流 - System.out/System.err 的类型)
    ```

*   **字符流 (Character Streams)**

    ```
    Reader (抽象类 - 所有字符输入流的基类)
        |-- FileReader (文件字符输入流 - 方便读取文本文件)
        |-- CharArrayReader (字符数组输入流)
        |-- BufferedReader (缓冲字符输入流 - 提高效率，提供按行读取等功能)
            |-- LineNumberReader (带行号的缓冲字符输入流)
        |-- InputStreamReader (转换流 - 将字节输入流转换为字符输入流，需要指定字符编码)

    Writer (抽象类 - 所有字符输出流的基类)
        |-- FileWriter (文件字符输出流 - 方便写入文本文件)
        |-- CharArrayWriter (字符数组输出流)
        |-- BufferedWriter (缓冲字符输出流 - 提高效率)
        |-- PrintWriter (打印字符输出流 - 功能更丰富的字符输出流，常用)
        |-- OutputStreamWriter (转换流 - 将字节输出流转换为字符输出流，需要指定字符编码)
    ```

**3. 标准输入/输出流 (System.in, System.out, System.err)**

Java 提供了三个静态的、预定义的流对象，它们是 `System` 类的成员：

*   `System.in`: **标准输入流 (InputStream)**。通常连接到键盘输入，用于从控制台读取用户输入。
*   `System.out`: **标准输出流 (PrintStream)**。通常连接到控制台输出，用于向控制台打印输出信息（普通输出）。
*   `System.err`: **标准错误输出流 (PrintStream)**。通常也连接到控制台输出，用于向控制台打印错误或警告信息（错误输出，通常会以不同颜色或方式显示）。

**4. 字节流 (Byte Streams) 的详细讲解和示例**

字节流主要处理原始的字节数据。

*   **`InputStream` 和 `OutputStream` 抽象类:**  它们是所有字节输入流和输出流的基类，定义了字节流的基本操作，如 `read()` (读取字节) 和 `write()` (写入字节)。

*   **常用字节流实现类:**

    *   **`FileInputStream` / `FileOutputStream`:** 用于读写文件中的字节数据。

        ```java
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;

        public class FileByteStreamExample {
            public static void main(String[] args) {
                String inputFile = "input.txt";
                String outputFile = "output.txt";

                // 写入字节到文件
                try (FileOutputStream fos = new FileOutputStream(outputFile)) { // try-with-resources 自动关闭流
                    String data = "Hello, Byte Stream!";
                    byte[] bytes = data.getBytes(); // 将字符串转换为字节数组
                    fos.write(bytes);
                    System.out.println("Data written to " + outputFile);
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 从文件读取字节
                try (FileInputStream fis = new FileInputStream(inputFile)) {
                    int byteData;
                    System.out.print("Data read from " + inputFile + ": ");
                    while ((byteData = fis.read()) != -1) { // read() 返回 -1 表示文件末尾
                        System.out.print((char) byteData); // 将字节转换为字符并打印
                    }
                    System.out.println();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```

        **示例说明:**
        1.  **写入文件:**  创建 `FileOutputStream` 对象，关联输出文件 "output.txt"。将字符串 "Hello, Byte Stream!" 转换为字节数组 `bytes`，使用 `fos.write(bytes)` 将字节数组写入文件。
        2.  **读取文件:** 创建 `FileInputStream` 对象，关联输入文件 "input.txt"。 使用 `fis.read()` 逐字节读取文件内容，直到返回 -1 (文件结束)。将读取的字节转换为字符并打印到控制台。
        3.  **`try-with-resources`:**  使用了 Java 7 引入的 `try-with-resources` 语句，确保 `FileOutputStream` 和 `FileInputStream` 在使用完毕后会被自动关闭，即使发生异常也能保证资源释放，避免资源泄露。

    *   **`ByteArrayInputStream` / `ByteArrayOutputStream`:**  用于在内存中的字节数组上进行 I/O 操作。常用于数据缓冲或临时数据处理。

        ```java
        import java.io.ByteArrayInputStream;
        import java.io.ByteArrayOutputStream;
        import java.io.IOException;

        public class ByteArrayStreamExample {
            public static void main(String[] args) {
                String data = "Memory Byte Stream";
                byte[] originalBytes = data.getBytes();

                // 使用 ByteArrayOutputStream 将数据写入到字节数组
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                try {
                    baos.write(originalBytes);
                } catch (IOException e) {
                    e.printStackTrace(); // 字节数组输出流的 write() 很少会抛出 IOException，但为了完整性，还是捕获一下
                }
                byte[] byteArray = baos.toByteArray(); // 获取写入的字节数组
                System.out.println("Bytes written to ByteArrayOutputStream: " + byteArray.length);


                // 使用 ByteArrayInputStream 从字节数组读取数据
                ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);
                try {
                    int byteData;
                    System.out.print("Data read from ByteArrayInputStream: ");
                    while ((byteData = bais.read()) != -1) {
                        System.out.print((char) byteData);
                    }
                    System.out.println();
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    try {
                        baos.close(); // 关闭流，释放资源
                        bais.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        ```

        **示例说明:**
        1.  **写入字节数组:** 创建 `ByteArrayOutputStream` 对象。 使用 `baos.write(originalBytes)` 将字节数组写入到 `ByteArrayOutputStream` 内部的缓冲区。 使用 `baos.toByteArray()` 获取缓冲区中的字节数组。
        2.  **从字节数组读取:** 创建 `ByteArrayInputStream` 对象，构造函数传入要读取的字节数组 `byteArray`。 使用 `bais.read()` 逐字节读取字节数组中的数据。

    *   **`BufferedInputStream` / `BufferedOutputStream`:**  提供缓冲功能，减少实际的 I/O 操作次数，提高效率。通常包装在其他字节流之上使用。

        ```java
        import java.io.*;

        public class BufferedByteStreamExample {
            public static void main(String[] args) {
                String inputFile = "large_input.txt"; // 假设这是一个大文件
                String outputFile = "large_output.txt";

                // 使用 BufferedOutputStream 写入缓冲数据到文件
                try (FileOutputStream fos = new FileOutputStream(outputFile);
                     BufferedOutputStream bos = new BufferedOutputStream(fos)) { // 包装 FileOutputStream
                    String data = "This is a large amount of text to write to a file.";
                    byte[] bytes = data.getBytes();
                    for (int i = 0; i < 100000; i++) { // 写入大量重复数据
                        bos.write(bytes);
                    }
                    System.out.println("Buffered data written to " + outputFile);
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 使用 BufferedInputStream 缓冲读取文件数据
                try (FileInputStream fis = new FileInputStream(inputFile);
                     BufferedInputStream bis = new BufferedInputStream(fis)) { // 包装 FileInputStream
                    int byteData;
                    long startTime = System.currentTimeMillis();
                    while ((byteData = bis.read()) != -1) {
                        // 处理读取的字节 (这里只是简单读取，不做任何处理)
                    }
                    long endTime = System.currentTimeMillis();
                    System.out.println("Buffered reading from " + inputFile + " took " + (endTime - startTime) + "ms");

                    // 对比：不使用缓冲流的读取时间 (仅作演示，实际应用中不推荐同时打开同一个文件进行读写)
                    FileInputStream fisUnbuffered = new FileInputStream(inputFile);
                    long startTimeUnbuffered = System.currentTimeMillis();
                    while ((byteData = fisUnbuffered.read()) != -1) {
                        // 处理读取的字节
                    }
                    long endTimeUnbuffered = System.currentTimeMillis();
                    System.out.println("Unbuffered reading from " + inputFile + " took " + (endTimeUnbuffered - startTimeUnbuffered) + "ms");
                    fisUnbuffered.close();

                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```

        **示例说明:**
        1.  **缓冲写入:**  创建 `FileOutputStream`，然后用 `BufferedOutputStream` 包装它。 使用 `bos.write(bytes)` 写入数据。数据会先写入到缓冲区，当缓冲区满或手动调用 `flush()` 或关闭流时，缓冲区数据才会一次性写入到文件，减少了对磁盘的频繁 I/O 操作。
        2.  **缓冲读取:**  类似地，创建 `FileInputStream`，然后用 `BufferedInputStream` 包装。 使用 `bis.read()` 读取数据。`BufferedInputStream` 会预先从文件中读取一部分数据到缓冲区，后续的 `read()` 操作首先从缓冲区读取，提高了读取效率。
        3.  **性能对比 (演示):**  示例中简单对比了使用缓冲流和不使用缓冲流读取大文件的时间，通常使用缓冲流会显著提升性能。 (注意：实际对比效果会受到文件大小、磁盘性能等多种因素影响，这里只是为了演示缓冲流的作用)。

    *   **`DataInputStream` / `DataOutputStream`:**  用于读写 Java 基本数据类型 (int, float, boolean, char, long, double 等) 的数据。保证数据以二进制格式存储和读取，并保持数据类型。

        ```java
        import java.io.*;

        public class DataStreamExample {
            public static void main(String[] args) {
                String dataFile = "data.dat";

                // 使用 DataOutputStream 写入基本数据类型到文件
                try (FileOutputStream fos = new FileOutputStream(dataFile);
                     DataOutputStream dos = new DataOutputStream(fos)) {
                    dos.writeInt(123);
                    dos.writeDouble(3.14159);
                    dos.writeBoolean(true);
                    dos.writeUTF("Hello, Data Stream"); // 写入 UTF-8 编码的字符串
                    System.out.println("Data types written to " + dataFile);
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 使用 DataInputStream 从文件读取基本数据类型
                try (FileInputStream fis = new FileInputStream(dataFile);
                     DataInputStream dis = new DataInputStream(fis)) {
                    int intValue = dis.readInt();
                    double doubleValue = dis.readDouble();
                    boolean booleanValue = dis.readBoolean();
                    String stringValue = dis.readUTF();

                    System.out.println("Read from " + dataFile + ":");
                    System.out.println("Int: " + intValue);
                    System.out.println("Double: " + doubleValue);
                    System.out.println("Boolean: " + booleanValue);
                    System.out.println("String: " + stringValue);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```

        **示例说明:**
        1.  **写入数据类型:**  创建 `DataOutputStream`，它包装了 `FileOutputStream`。 使用 `dos.writeInt()`, `dos.writeDouble()`, `dos.writeBoolean()`, `dos.writeUTF()` 等方法分别写入 int, double, boolean, String 等类型的数据。`writeUTF()` 方法用于写入 UTF-8 编码的字符串，并会在字符串前加上长度信息。
        2.  **读取数据类型:**  创建 `DataInputStream`，包装了 `FileInputStream`。 使用 `dis.readInt()`, `dis.readDouble()`, `dis.readBoolean()`, `dis.readUTF()` 等方法 **按照写入的顺序** 读取对应类型的数据。 必须按照写入的顺序读取，否则数据类型会错乱。

    *   **`ObjectInputStream` / `ObjectOutputStream`:**  用于对象的序列化 (Serialization) 和反序列化 (Deserialization)。可以将 Java 对象转换为字节流进行存储或网络传输，再将字节流恢复为对象。 对象需要实现 `java.io.Serializable` 接口才能被序列化。

        ```java
        import java.io.*;

        class Person implements Serializable { // 实现 Serializable 接口
            private String name;
            private int age;

            public Person(String name, int age) {
                this.name = name;
                this.age = age;
            }

            @Override
            public String toString() {
                return "Person{" +
                       "name='" + name + '\'' +
                       ", age=" + age +
                       '}';
            }
        }

        public class ObjectStreamExample {
            public static void main(String[] args) {
                String objectFile = "person.ser";
                Person person = new Person("Alice", 30);

                // 使用 ObjectOutputStream 序列化对象到文件
                try (FileOutputStream fos = new FileOutputStream(objectFile);
                     ObjectOutputStream oos = new ObjectOutputStream(fos)) {
                    oos.writeObject(person); // 序列化 Person 对象
                    System.out.println("Person object serialized to " + objectFile);
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 使用 ObjectInputStream 从文件反序列化对象
                try (FileInputStream fis = new FileInputStream(objectFile);
                     ObjectInputStream ois = new ObjectInputStream(fis)) {
                    Person restoredPerson = (Person) ois.readObject(); // 反序列化，需要强制类型转换
                    System.out.println("Person object deserialized from " + objectFile + ":");
                    System.out.println(restoredPerson);
                } catch (IOException | ClassNotFoundException e) { // 注意捕获 ClassNotFoundException
                    e.printStackTrace();
                }
            }
        }
        ```

        **示例说明:**
        1.  **序列化:**  `Person` 类实现了 `Serializable` 接口，表示可以被序列化。 创建 `ObjectOutputStream`，包装了 `FileOutputStream`。 使用 `oos.writeObject(person)` 将 `person` 对象序列化为字节流并写入文件 "person.ser"。
        2.  **反序列化:**  创建 `ObjectInputStream`，包装了 `FileInputStream`。 使用 `ois.readObject()` 从文件中读取字节流并反序列化为对象。 返回类型是 `Object`, 需要强制类型转换为 `Person`。 注意捕获 `ClassNotFoundException`，因为反序列化时需要类的定义。

    *   **`PrintStream`:**  `System.out` 和 `System.err` 的类型就是 `PrintStream`。 它提供了 `print()`, `println()`, `printf()` 等方便的打印方法，可以将各种数据类型格式化输出为文本。 虽然 `PrintStream` 是字节流，但它主要用于文本输出，内部会自动将字符转换为字节。

        ```java
        public class PrintStreamExample {
            public static void main(String[] args) {
                PrintStream out = System.out; // 获取标准输出流

                out.print("Hello, "); // 不换行输出
                out.println("PrintStream!"); // 输出并换行
                out.printf("Integer: %d, Double: %.2f\n", 10, 3.14159); // 格式化输出

                // PrintStream 也可以用于文件输出
                try (PrintStream fileOut = new PrintStream(new FileOutputStream("print_output.txt"))) {
                    fileOut.println("Output to file using PrintStream.");
                    fileOut.printf("Formatted output to file: Integer = %d\n", 20);
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                }
            }
        }
        ```

        **示例说明:**
        1.  **控制台输出:** 使用 `System.out` (一个 `PrintStream` 对象) 的 `print()`, `println()`, `printf()` 方法向控制台输出文本和格式化数据。
        2.  **文件输出:** 可以创建 `PrintStream` 对象，并关联 `FileOutputStream`，将数据输出到文件。

**5. 字符流 (Character Streams) 的详细讲解和示例**

字符流主要处理文本数据，并考虑了字符编码。

*   **`Reader` 和 `Writer` 抽象类:**  它们是所有字符输入流和输出流的基类，定义了字符流的基本操作，如 `read()` (读取字符/字符数组) 和 `write()` (写入字符/字符数组/字符串)。

*   **常用字符流实现类:**

    *   **`FileReader` / `FileWriter`:** 用于读写文本文件，**默认使用平台默认字符编码**。  通常用于简单的文本文件读写，但**不推荐直接使用，因为字符编码问题容易出错**。 建议使用 `InputStreamReader`/`OutputStreamWriter` 并显式指定字符编码。

        ```java
        import java.io.FileReader;
        import java.io.FileWriter;
        import java.io.IOException;

        public class FileReaderWriterExample {
            public static void main(String[] args) {
                String textFile = "text.txt";

                // 使用 FileWriter 写入字符到文本文件 (默认字符编码)
                try (FileWriter fw = new FileWriter(textFile)) {
                    fw.write("你好，FileWriter!\n"); // 写入字符串
                    fw.write("This is a line of text.\n");
                    char[] chars = {'A', 'B', 'C'};
                    fw.write(chars); // 写入字符数组
                    System.out.println("Text written to " + textFile + " using FileWriter (default encoding)");
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 使用 FileReader 读取文本文件 (默认字符编码)
                try (FileReader fr = new FileReader(textFile)) {
                    int charData;
                    System.out.print("Text read from " + textFile + " using FileReader (default encoding): \n");
                    while ((charData = fr.read()) != -1) {
                        System.out.print((char) charData);
                    }
                    System.out.println();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```

        **示例说明:**
        1.  **写入文本文件:** 创建 `FileWriter` 对象，关联文本文件 "text.txt"。 使用 `fw.write()` 方法写入字符串、字符或字符数组。
        2.  **读取文本文件:** 创建 `FileReader` 对象，关联文本文件 "text.txt"。 使用 `fr.read()` 逐字符读取文件内容。
        3.  **字符编码:** `FileReader` 和 `FileWriter` 默认使用平台的字符编码，在不同平台或不同编码的文件之间可能出现乱码问题。 **建议使用 `InputStreamReader`/`OutputStreamWriter` 并显式指定字符编码，以避免编码问题。**

    *   **`CharArrayReader` / `CharArrayWriter`:**  类似于字节数组流，用于在内存中的字符数组上进行字符 I/O 操作。

        ```java
        import java.io.CharArrayReader;
        import java.io.CharArrayWriter;
        import java.io.IOException;

        public class CharArrayStreamExample {
            public static void main(String[] args) {
                char[] originalChars = {'J', 'a', 'v', 'a', ' ', '字', '符', '流'};
                // 使用 CharArrayWriter 将字符写入到字符数组
                CharArrayWriter caw = new CharArrayWriter();
                try {
                    caw.write(originalChars);
                    caw.write(" Example");
                } catch (IOException e) {
                    e.printStackTrace();
                }
                char[] charArray = caw.toCharArray(); // 获取写入的字符数组
                System.out.println("Chars written to CharArrayWriter: " + new String(charArray));

                // 使用 CharArrayReader 从字符数组读取数据
                CharArrayReader car = new CharArrayReader(charArray);
                try {
                    int charData;
                    System.out.print("Data read from CharArrayReader: ");
                    while ((charData = car.read()) != -1) {
                        System.out.print((char) charData);
                    }
                    System.out.println();
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    caw.close();
                    car.close();
                }
            }
        }
        ```

        **示例说明:**  用法与 `ByteArrayInputStream`/`ByteArrayOutputStream` 类似，只是操作的是字符数组而不是字节数组。

    *   **`BufferedReader` / `BufferedWriter`:**  缓冲字符流，提供缓冲功能，提高效率。 并且 `BufferedReader` 提供了 `readLine()` 方法，可以方便地按行读取文本文件。

        ```java
        import java.io.*;

        public class BufferedReaderWriterExample {
            public static void main(String[] args) {
                String textFile = "buffered_text.txt";

                // 使用 BufferedWriter 写入缓冲字符到文件
                try (FileWriter fw = new FileWriter(textFile);
                     BufferedWriter bw = new BufferedWriter(fw)) { // 包装 FileWriter
                    bw.write("This is the first line.\n");
                    bw.write("This is the second line.\n");
                    bw.write("And this is the third line.\n");
                    System.out.println("Buffered text written to " + textFile);
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 使用 BufferedReader 缓冲读取文件，并按行读取
                try (FileReader fr = new FileReader(textFile);
                     BufferedReader br = new BufferedReader(fr)) { // 包装 FileReader
                    String line;
                    System.out.println("Lines read from " + textFile + " using BufferedReader:");
                    while ((line = br.readLine()) != null) { // readLine() 读取一行文本，返回 null 表示文件末尾
                        System.out.println(line);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```

        **示例说明:**
        1.  **缓冲写入:** 创建 `FileWriter`，然后用 `BufferedWriter` 包装。 使用 `bw.write()` 写入字符数据。
        2.  **缓冲读取和按行读取:** 创建 `FileReader`，然后用 `BufferedReader` 包装。 使用 `br.readLine()` 按行读取文本文件，直到返回 `null`。 `readLine()` 方法非常方便处理按行组织的文本数据。

    *   **`PrintWriter`:**  功能更丰富的字符输出流，提供了 `print()`, `println()`, `printf()` 等方法，类似于 `PrintStream`，但它是字符流，更适合文本输出。

        ```java
        import java.io.FileWriter;
        import java.io.IOException;
        import java.io.PrintWriter;

        public class PrintWriterExample {
            public static void main(String[] args) {
                String printFile = "print_writer_output.txt";

                // 使用 PrintWriter 写入格式化文本到文件
                try (FileWriter fw = new FileWriter(printFile);
                     PrintWriter pw = new PrintWriter(fw)) { // 包装 FileWriter
                    pw.println("PrintWriter example output.");
                    pw.printf("Formatted output: Integer = %d, String = %s\n", 100, "Example String");
                    pw.print(true); // 可以直接输出 boolean 等基本类型
                    System.out.println("PrintWriter output written to " + printFile);
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 使用 PrintWriter 输出到控制台 (System.out 实际上是 PrintStream, 但 PrintWriter 功能更丰富)
                PrintWriter consoleOut = new PrintWriter(System.out, true); // true 表示自动 flush
                consoleOut.println("PrintWriter to console.");
                consoleOut.printf("Console output: Double = %.3f\n", 2.71828);
                consoleOut.close(); // 关闭 PrintWriter (虽然 System.out 一般不需要关闭，但作为示例演示一下)
            }
        }
        ```

        **示例说明:**
        1.  **文件输出:** 创建 `FileWriter`，然后用 `PrintWriter` 包装。 使用 `pw.println()`, `pw.printf()`, `pw.print()` 等方法输出文本和格式化数据到文件。
        2.  **控制台输出:** 可以创建 `PrintWriter` 对象，并关联 `System.out`，将数据输出到控制台。 `PrintWriter` 提供了比 `PrintStream` 更丰富的字符处理功能。 `PrintWriter(System.out, true)` 的第二个参数 `true` 表示启用自动 flush，每次 `println()` 或 `printf()` 后会自动刷新缓冲区，立即输出到控制台。

    *   **`InputStreamReader` / `OutputStreamWriter`:** **转换流**，用于在字节流和字符流之间进行转换。 当你需要**指定字符编码**时，必须使用这对流。

        ```java
        import java.io.*;
        import java.nio.charset.StandardCharsets;

        public class InputStreamReaderOutputStreamWriterExample {
            public static void main(String[] args) {
                String encodedFile = "encoded_text.txt";
                String textData = "使用 UTF-8 编码写入文本文件。";

                // 使用 OutputStreamWriter 以 UTF-8 编码写入文本文件
                try (FileOutputStream fos = new FileOutputStream(encodedFile);
                     OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8); // 指定 UTF-8 编码
                     BufferedWriter bw = new BufferedWriter(osw)) { // 可以继续用 BufferedWriter 包装提高效率
                    bw.write(textData);
                    System.out.println("Text written to " + encodedFile + " with UTF-8 encoding.");
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 使用 InputStreamReader 以 UTF-8 编码读取文本文件
                try (FileInputStream fis = new FileInputStream(encodedFile);
                     InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8); // 指定 UTF-8 编码
                     BufferedReader br = new BufferedReader(isr)) { // 可以继续用 BufferedReader 包装提高效率
                    String line;
                    System.out.println("Text read from " + encodedFile + " with UTF-8 encoding:");
                    while ((line = br.readLine()) != null) {
                        System.out.println(line);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```

        **示例说明:**
        1.  **编码写入:** 创建 `FileOutputStream`，然后用 `OutputStreamWriter` 包装，**在 `OutputStreamWriter` 的构造函数中指定字符编码 `StandardCharsets.UTF_8`** (或者使用字符编码名称字符串 `"UTF-8"`)。  再用 `BufferedWriter` 包装 `OutputStreamWriter` 可以提高效率。 使用 `bw.write()` 写入文本数据，数据会以 UTF-8 编码写入文件。
        2.  **解码读取:** 创建 `FileInputStream`，然后用 `InputStreamReader` 包装，**同样在 `InputStreamReader` 的构造函数中指定字符编码 `StandardCharsets.UTF_8`**。 再用 `BufferedReader` 包装 `InputStreamReader`。 使用 `br.readLine()` 读取文本文件，文件内容会按照 UTF-8 编码解码为字符。

**6. 控制台 I/O (System.in, System.out, System.err) 详解**

*   **`System.out` 和 `System.err` (PrintStream):**  主要用于输出信息到控制台。 前面 `PrintStream` 和 `PrintWriter` 的示例已经展示了它们的基本用法。

*   **`System.in` (InputStream):**  用于从控制台读取输入。 通常需要结合其他类来使用，例如 `Scanner` 或 `BufferedReader`。

    *   **使用 `Scanner` (推荐，方便快捷):**  `Scanner` 类提供了方便的方法来解析各种类型的输入，例如整数、浮点数、字符串等。

        ```java
        import java.util.Scanner;

        public class ScannerExample {
            public static void main(String[] args) {
                Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象，关联 System.in

                System.out.print("请输入您的姓名：");
                String name = scanner.nextLine(); // 读取一行文本 (包括空格)

                System.out.print("请输入您的年龄：");
                int age = scanner.nextInt();    // 读取一个整数

                System.out.print("请输入您的身高（米）：");
                double height = scanner.nextDouble(); // 读取一个双精度浮点数

                System.out.println("\n您输入的信息是：");
                System.out.println("姓名：" + name);
                System.out.println("年龄：" + age);
                System.out.println("身高：" + height + " 米");

                scanner.close(); // 关闭 Scanner，释放资源 (虽然 System.in 一般不需要手动关闭，但好的习惯)
            }
        }
        ```

        **示例说明:**
        1.  **创建 Scanner:**  `Scanner scanner = new Scanner(System.in);` 创建 `Scanner` 对象，并将 `System.in` 作为输入源。
        2.  **读取不同类型输入:**
            *   `scanner.nextLine()`: 读取一行文本，直到换行符，返回字符串。
            *   `scanner.nextInt()`: 读取一个整数。
            *   `scanner.nextDouble()`: 读取一个双精度浮点数。
            `Scanner` 还提供了 `next()`, `nextFloat()`, `nextBoolean()`, `nextLong()`, `nextShort()` 等方法，可以读取不同类型的输入。
        3.  **关闭 Scanner:**  `scanner.close();` 关闭 `Scanner` 对象，释放资源。

    *   **使用 `BufferedReader` (更底层，更灵活，但稍显繁琐):**  `BufferedReader` 通常与 `InputStreamReader` 结合使用，从 `System.in` 读取字符流，并提供缓冲和按行读取功能。

        ```java
        import java.io.BufferedReader;
        import java.io.IOException;
        import java.io.InputStreamReader;

        public class BufferedReaderConsoleExample {
            public static void main(String[] args) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

                try {
                    System.out.print("请输入一行文本：");
                    String line = reader.readLine(); // 按行读取文本

                    System.out.println("您输入的文本是：" + line);

                    System.out.print("请输入一个整数：");
                    String intStr = reader.readLine();
                    int number = Integer.parseInt(intStr); // 将字符串转换为整数 (需要处理 NumberFormatException)
                    System.out.println("您输入的整数是：" + number);

                } catch (IOException e) {
                    e.printStackTrace();
                } catch (NumberFormatException e) {
                    System.err.println("输入的不是有效的整数！");
                } finally {
                    try {
                        reader.close(); // 关闭 BufferedReader
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        ```

        **示例说明:**
        1.  **创建 BufferedReader:**  `BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));`  将 `System.in` 字节流通过 `InputStreamReader` 转换为字符流，再用 `BufferedReader` 进行缓冲。
        2.  **按行读取:** `reader.readLine()` 读取一行文本。
        3.  **类型转换:**  由于 `readLine()` 返回的是字符串，如果需要读取其他类型的数据（如整数），需要手动进行类型转换，例如使用 `Integer.parseInt()`, `Double.parseDouble()` 等。 需要注意处理类型转换异常 (`NumberFormatException`).
        4.  **关闭 BufferedReader:**  `reader.close();` 关闭 `BufferedReader` 对象。

**7. 文件 I/O 综合示例 (创建、读取、写入、删除文件和目录)**

```java
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;

public class FileOperationsExample {
    public static void main(String[] args) {
        String dirName = "example_dir";
        String fileName = dirName + "/example_file.txt";
        Path dirPath = Paths.get(dirName);
        Path filePath = Paths.get(fileName);

        // 1. 创建目录
        try {
            if (!Files.exists(dirPath)) {
                Files.createDirectory(dirPath);
                System.out.println("目录 '" + dirName + "' 创建成功。");
            } else {
                System.out.println("目录 '" + dirName + "' 已存在。");
            }
        } catch (IOException e) {
            System.err.println("创建目录 '" + dirName + "' 失败: " + e.getMessage());
            return; // 创建目录失败，后续操作无法进行
        }

        // 2. 写入文本文件
        String contentToWrite = "这是写入到文件的文本内容。\n第二行文本。";
        try (BufferedWriter writer = Files.newBufferedWriter(filePath, StandardCharsets.UTF_8)) {
            writer.write(contentToWrite);
            System.out.println("文本写入文件 '" + fileName + "' 成功。");
        } catch (IOException e) {
            System.err.println("写入文件 '" + fileName + "' 失败: " + e.getMessage());
        }

        // 3. 读取文本文件
        try (BufferedReader reader = Files.newBufferedReader(filePath, StandardCharsets.UTF_8)) {
            System.out.println("\n从文件 '" + fileName + "' 读取的内容:");
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("读取文件 '" + fileName + "' 失败: " + e.getMessage());
        }

        // 4. 文件是否存在
        if (Files.exists(filePath)) {
            System.out.println("\n文件 '" + fileName + "' 存在。");
        } else {
            System.out.println("\n文件 '" + fileName + "' 不存在。");
        }

        // 5. 删除文件
        try {
            Files.deleteIfExists(filePath); // 如果文件存在则删除，不存在也不报错
            System.out.println("文件 '" + fileName + "' 删除成功。");
        } catch (IOException e) {
            System.err.println("删除文件 '" + fileName + "' 失败: " + e.getMessage());
        }

        // 6. 删除目录 (目录必须为空才能删除)
        try {
            Files.deleteIfExists(dirPath); // 如果目录为空则删除，否则删除失败
            System.out.println("目录 '" + dirName + "' 删除成功。");
        } catch (IOException e) {
            System.err.println("删除目录 '" + dirName + "' 失败: " + e.getMessage());
        }
    }
}
```

**示例说明:**
1.  **创建目录:** 使用 `Files.createDirectory(dirPath)` 创建目录。
2.  **写入文本文件:** 使用 `Files.newBufferedWriter(filePath, StandardCharsets.UTF_8)` 创建 `BufferedWriter`，并指定 UTF-8 编码。 使用 `writer.write()` 写入文本内容。
3.  **读取文本文件:** 使用 `Files.newBufferedReader(filePath, StandardCharsets.UTF_8)` 创建 `BufferedReader`，并指定 UTF-8 编码。 使用 `reader.readLine()` 按行读取文件内容。
4.  **文件是否存在:** 使用 `Files.exists(filePath)` 判断文件或目录是否存在。
5.  **删除文件:** 使用 `Files.deleteIfExists(filePath)` 删除文件。
6.  **删除目录:** 使用 `Files.deleteIfExists(dirPath)` 删除目录。 **注意：`Files.deleteDirectory()` 只能删除空目录，如果要删除非空目录，需要先递归删除目录下的所有文件和子目录。**

**8. NIO (New I/O) 简要介绍**

Java NIO (Non-blocking I/O) 和 NIO.2 (New I/O 2) 是 Java I/O 的高级特性，提供了更高效、更灵活的 I/O 操作方式。

*   **NIO (java.nio 包):**  引入了通道 (Channels)、缓冲区 (Buffers)、选择器 (Selectors) 等概念，支持非阻塞 I/O 操作。 适用于高并发、高性能 I/O 场景，例如网络服务器。

*   **NIO.2 (java.nio.file 包):**  在 Java 7 中引入，也称为 New I/O 2 或 Filesystem API。  提供了更现代、更易用的文件 I/O API，例如 `Path`, `Paths`, `Files` 类。 上面的文件 I/O 示例中已经使用了 `java.nio.file.Files` 类进行文件操作。 NIO.2 也提供了异步 I/O 操作的支持。

**NIO 的核心组件:**

*   **Channels (通道):**  类似于流，但更加底层，可以是双向的 (既可以读也可以写)。  例如 `FileChannel`, `SocketChannel`, `ServerSocketChannel` 等。
*   **Buffers (缓冲区):**  数据读写的中转站。 数据从通道读取到缓冲区，或者从缓冲区写入到通道。 例如 `ByteBuffer`, `CharBuffer`, `IntBuffer` 等。
*   **Selectors (选择器):**  允许单线程管理多个通道的 I/O 事件。 可以监听多个通道的就绪状态 (例如，可读、可写)。 实现非阻塞 I/O 的关键。

**NIO 的优势:**

*   **非阻塞 I/O:**  允许程序在等待 I/O 操作完成时，继续执行其他任务，提高效率和响应性。
*   **基于缓冲区的操作:**  数据在缓冲区中批量处理，减少系统调用次数，提高吞吐量。
*   **通道和选择器:**  提供了更底层、更灵活的 I/O 控制。

**NIO 示例 (简要示意，更详细的 NIO 用法需要更深入的学习):**

```java
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class NIOExample {
    public static void main(String[] args) {
        String nioFile = "nio_example.txt";

        // 使用 FileChannel 写入数据
        try (FileChannel fileChannel = FileChannel.open(Paths.get(nioFile), StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            ByteBuffer buffer = ByteBuffer.allocate(1024); // 创建缓冲区
            String data = "Hello, NIO FileChannel!";
            buffer.put(data.getBytes()); // 将数据放入缓冲区
            buffer.flip(); // 切换到读模式 (准备从缓冲区读取数据写入通道)
            fileChannel.write(buffer); // 从缓冲区写入通道 (文件)
            System.out.println("Data written to " + nioFile + " using FileChannel.");
        } catch (Exception e) {
            e.printStackTrace();
        }

        // 使用 FileChannel 读取数据
        try (FileChannel fileChannel = FileChannel.open(Paths.get(nioFile), StandardOpenOption.READ)) {
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = fileChannel.read(buffer); // 从通道 (文件) 读取数据到缓冲区
            if (bytesRead > 0) {
                buffer.flip(); // 切换到读模式 (准备从缓冲区读取数据)
                byte[] byteArray = new byte[bytesRead];
                buffer.get(byteArray, 0, bytesRead); // 从缓冲区读取数据到字节数组
                String readData = new String(byteArray);
                System.out.println("Data read from " + nioFile + " using FileChannel: " + readData);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**NIO 学习资源:**  NIO 比较复杂，如果需要深入学习，可以参考 Java NIO 相关的教程和书籍。

**9. Java I/O 最佳实践和注意事项**

*   **资源管理 (try-with-resources):**  始终使用 `try-with-resources` 语句来自动关闭流、Reader、Writer 等 I/O 资源，确保资源及时释放，避免资源泄露。
*   **异常处理 (try-catch):**  I/O 操作容易抛出 `IOException`，务必使用 `try-catch` 块来捕获和处理 I/O 异常，保证程序的健壮性。
*   **选择合适的流类型:**  根据处理的数据类型选择字节流 (`InputStream`/`OutputStream`) 或字符流 (`Reader`/`Writer`)。 处理二进制数据用字节流，处理文本数据用字符流。
*   **字符编码:**  处理文本数据时，务必注意字符编码问题。 推荐使用 `InputStreamReader`/`OutputStreamWriter` 并显式指定字符编码 (如 UTF-8)，避免乱码。
*   **缓冲流:**  在需要提高 I/O 效率时，使用缓冲流 (`BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, `BufferedWriter`)。
*   **性能优化:**  对于高并发、高性能 I/O 场景，可以考虑使用 Java NIO 或异步 I/O。
*   **文件路径:**  处理文件路径时，使用 `java.nio.file.Path` 和 `Paths` 类，以及 `Files` 类提供的文件操作方法，更加现代和方便。
*   **安全性:**  在处理用户输入的文件路径或文件名时，要进行安全检查，防止路径遍历漏洞等安全问题。

**总结**

Java I/O 系统是一个强大而复杂的体系，提供了丰富的类和方法来处理各种输入输出操作。 理解字节流和字符流的区别、掌握常用 I/O 类的用法、注意资源管理和异常处理、了解字符编码和 NIO 的基本概念，是编写高质量 Java 应用程序的基础。 通过不断的学习和实践，你将能够熟练运用 Java I/O 技术来处理各种数据输入输出的需求。 希望这份详细的讲解和示例能够帮助您深入理解 Java I/O!















---






## 极尽详细的为我讲解在互联网大厂笔试中acm模式下，java的关于输入输出的所有相关知识，并给出具体使用示例



当然！为了帮助你充分准备互联网大厂笔试中的 ACM 模式 Java 输入输出，我将提供一个极尽详细的讲解，并附带具体的代码示例。这将涵盖你在笔试中可能遇到的各种情况，并教你如何高效、准确地处理输入输出。

**1. ACM 模式输入输出的重要性**

在互联网大厂的笔试中，ACM 模式是常见的题目提交方式。与核心代码模式不同，ACM 模式要求你编写**完整的程序**，包括从标准输入读取数据，进行计算处理，并将结果输出到标准输出。这意味着，除了算法逻辑，**高效且正确的输入输出处理也是至关重要的**。

*   **时间限制敏感：** 笔试通常有严格的时间限制。低效的输入输出方法可能会导致你的程序超时 (Time Limit Exceeded, TLE)，即使你的算法是正确的。
*   **格式要求严格：** 题目对输入和输出的格式有明确的规定。不符合格式的输出可能导致判题系统无法正确评估你的答案，结果为格式错误 (Presentation Error, PE) 或答案错误 (Wrong Answer, WA)。
*   **多组测试用例：** 大部分 ACM 模式的题目会包含多组测试用例。你的程序需要能够正确处理多组输入，并对每组输入都给出正确的输出。

因此，掌握高效且正确的 Java 输入输出方法，是你在 ACM 模式笔试中取得成功的关键一步。

**2. Java 中常用的输入方法详解 (ACM 模式)**

在 ACM 模式下，Java 中最常用的输入方式是使用 `Scanner` 和 `BufferedReader`。 虽然 `Scanner` 更易于使用，但在性能上，`BufferedReader` 通常更高效，特别是在处理大量数据输入时。

**2.1. `Scanner` 类**

`Scanner` 类是 Java 提供的用于扫描输入文本的实用工具类。它可以从标准输入 (`System.in`)、文件、字符串等多种来源读取数据，并可以方便地解析出各种基本数据类型和字符串。

**优点:**

*   **易用性好：** API 简洁直观，提供了 `nextInt()`, `nextDouble()`, `nextLine()`, `next()` 等方法，可以方便地读取各种类型的数据。
*   **功能丰富：** 可以使用正则表达式进行更复杂的输入解析。

**缺点:**

*   **性能相对较低：**  与 `BufferedReader` 相比，`Scanner` 在处理大量数据输入时效率较低，容易成为性能瓶颈。在时间要求严格的 ACM 题目中，应谨慎使用。

**常用 `Scanner` 方法示例:**

```java
import java.util.Scanner;

public class ScannerInputExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取整数
        System.out.print("请输入一个整数: ");
        int intValue = scanner.nextInt();
        System.out.println("您输入的整数是: " + intValue);

        // 读取浮点数
        System.out.print("请输入一个浮点数: ");
        double doubleValue = scanner.nextDouble();
        System.out.println("您输入的浮点数是: " + doubleValue);

        // 读取字符串 (读取到空格或换行符为止)
        System.out.print("请输入一个单词: ");
        String word = scanner.next();
        System.out.println("您输入的单词是: " + word);

        // 读取一行字符串 (读取整行，包括空格)
        System.out.print("请输入一行文本: ");
        scanner.nextLine(); // 消耗掉 nextDouble() 或 nextInt() 遗留的换行符
        String line = scanner.nextLine();
        System.out.println("您输入的文本行是: " + line);

        scanner.close(); // 记得关闭 Scanner
    }
}
```

**ACM 模式下 `Scanner` 的常见用法示例:**

*   **读取一行中的多个整数：**

    ```java
    Scanner scanner = new Scanner(System.in);
    int a = scanner.nextInt();
    int b = scanner.nextInt();
    // ...
    ```

*   **循环读取多组输入，直到输入结束 (例如，遇到特定结束符或 EOF)：**

    ```java
    Scanner scanner = new Scanner(System.in);
    while (scanner.hasNextInt()) { // 判断是否有下一个 int 输入
        int num = scanner.nextInt();
        // 处理 num
        System.out.println("读取到的数字: " + num);
    }
    scanner.close();
    ```

    或者，如果题目规定输入 `0 0` 结束：

    ```java
    Scanner scanner = new Scanner(System.in);
    while (true) {
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        if (a == 0 && b == 0) {
            break; // 输入 0 0 结束循环
        }
        int sum = a + b;
        System.out.println("和: " + sum);
    }
    scanner.close();
    ```

**2.2. `BufferedReader` 类**

`BufferedReader` 类提供了缓冲字符输入流，它可以从字符输入流中读取文本，并缓冲字符，以便实现字符、数组和行的有效读取。  `BufferedReader` 通常与 `InputStreamReader` 结合使用，将字节流 (`System.in` 是字节流) 转换为字符流，并指定字符编码（通常使用 UTF-8）。

**优点:**

*   **高性能：**  由于使用了缓冲区，`BufferedReader` 的读取效率比 `Scanner` 高得多，尤其是在处理大量文本输入时。
*   **按行读取方便：**  提供了 `readLine()` 方法，可以方便地读取一行文本。

**缺点:**

*   **使用稍显复杂：**  相比 `Scanner`，`BufferedReader` 的使用稍微复杂一些，需要手动进行类型转换。
*   **只能读取字符串：**  `BufferedReader` 的 `readLine()` 方法只返回字符串，需要手动将字符串解析为其他数据类型 (如 `Integer.parseInt()`, `Double.parseDouble()` 等)。

**常用 `BufferedReader` 方法示例:**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BufferedReaderInputExample {
    public static void main(String[] args) {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        try {
            // 读取一行文本
            System.out.print("请输入一行文本: ");
            String line = reader.readLine();
            System.out.println("您输入的文本行是: " + line);

            // 读取整数 (需要手动解析)
            System.out.print("请输入一个整数: ");
            String intStr = reader.readLine();
            int intValue = Integer.parseInt(intStr);
            System.out.println("您输入的整数是: " + intValue);

            // 读取浮点数 (需要手动解析)
            System.out.print("请输入一个浮点数: ");
            String doubleStr = reader.readLine();
            double doubleValue = Double.parseDouble(doubleStr);
            System.out.println("您输入的浮点数是: " + doubleValue);

        } catch (IOException e) {
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("输入格式错误，无法解析为数字！");
        } finally {
            try {
                reader.close(); // 记得关闭 BufferedReader
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**ACM 模式下 `BufferedReader` 的常见用法示例:**

*   **读取一行中的多个整数 (分割字符串后解析):**

    ```java
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    String line = reader.readLine();
    String[] parts = line.split(" "); // 使用空格分割字符串
    int a = Integer.parseInt(parts[0]);
    int b = Integer.parseInt(parts[1]);
    // ...
    ```

*   **循环读取多组输入，直到输入结束 (例如，遇到 null 表示 EOF)：**

    ```java
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    String line;
    while ((line = reader.readLine()) != null) { // readLine() 返回 null 表示 EOF
        // 处理 line
        System.out.println("读取到的行: " + line);
    }
    reader.close();
    ```

    或者，如果题目规定输入 `0 0` 结束 (需要手动解析和判断)：

    ```java
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    String line;
    while ((line = reader.readLine()) != null) {
        String[] parts = line.split(" ");
        int a = Integer.parseInt(parts[0]);
        int b = Integer.parseInt(parts[1]);
        if (a == 0 && b == 0) {
            break; // 输入 0 0 结束循环
        }
        int sum = a + b;
        System.out.println("和: " + sum);
    }
    reader.close();
    ```

**2.3. `Scanner` vs. `BufferedReader` 的选择**

*   **性能要求不高，输入数据量不大：** 可以优先考虑 `Scanner`，因为它更易于使用，代码更简洁。
*   **性能要求高，输入数据量大，或者时间限制非常严格：**  必须使用 `BufferedReader`，以避免因输入效率过低而导致超时。
*   **ACM 笔试的默认选择：**  为了应对各种可能的场景，**推荐在 ACM 模式的笔试中默认使用 `BufferedReader` 进行输入**。 尽管初期使用可能稍有不便，但长期来看，它可以让你更好地适应高效率的输入输出要求。

**3. Java 中常用的输出方法详解 (ACM 模式)**

Java 中常用的输出方法主要是 `System.out.println()`, `System.out.print()`, 和 `PrintWriter`。  与输入类似，虽然 `System.out.println()` 和 `System.out.print()` 使用方便，但在性能上，`PrintWriter` 通常更高效，尤其是在大量数据输出时。

**3.1. `System.out.println()` 和 `System.out.print()`**

`System.out.println()` 和 `System.out.print()` 是 `PrintStream` 类的方法，用于向标准输出流 (`System.out`) 打印数据。

*   `System.out.println(x)`:  输出 `x` 的字符串表示形式，并在末尾添加一个换行符。
*   `System.out.print(x)`:  输出 `x` 的字符串表示形式，但不添加换行符。

**优点:**

*   **易用性极佳：**  使用非常简单，直接调用即可输出各种类型的数据。
*   **常用且方便：**  适合简单的输出需求和调试输出。

**缺点:**

*   **性能相对较低：**  与 `PrintWriter` 相比，`System.out` 的输出效率较低，特别是在大量数据输出时。

**ACM 模式下 `System.out` 的常见用法示例:**

*   **输出单个结果：**

    ```java
    int result = calculateSum(a, b);
    System.out.println(result); // 输出计算结果并换行
    ```

*   **输出多个结果，中间用空格分隔，最后换行：**

    ```java
    int result1 = calculateResult1();
    int result2 = calculateResult2();
    System.out.print(result1 + " "); // 输出 result1，后跟一个空格
    System.out.println(result2);     // 输出 result2，并换行
    ```

**3.2. `PrintWriter` 类**

`PrintWriter` 类是一个字符打印输出流，它可以将格式化的数据打印到文本输出流。 `PrintWriter` 可以包装 `System.out`，以提高输出效率，并提供更丰富的格式化输出功能，例如 `printf()` 方法。

**优点:**

*   **高性能：**  由于使用了缓冲区，`PrintWriter` 的输出效率比 `System.out` 高得多，尤其是在大量文本输出时。
*   **格式化输出：**  提供了 `printf()` 方法，可以进行格式化输出，满足 ACM 题目中对输出格式的严格要求。

**缺点:**

*   **使用稍显复杂：**  相比 `System.out`，`PrintWriter` 的使用稍微复杂一些，需要创建 `PrintWriter` 对象。

**常用 `PrintWriter` 方法示例:**

```java
import java.io.PrintWriter;

public class PrintWriterOutputExample {
    public static void main(String[] args) {
        PrintWriter writer = new PrintWriter(System.out); // 包装 System.out

        // 输出文本并换行
        writer.println("Hello, PrintWriter!");

        // 输出文本不换行
        writer.print("This is ");
        writer.print("PrintWriter ");
        writer.println("example.");

        // 格式化输出 (类似于 C 语言的 printf)
        int age = 30;
        double salary = 12000.50;
        String name = "Alice";
        writer.printf("Name: %s, Age: %d, Salary: %.2f\n", name, age, salary);

        writer.flush(); // 刷新缓冲区，确保输出立即写入 (通常不需要手动 flush，println/printf 会自动 flush)
        writer.close(); // 关闭 PrintWriter (虽然 System.out 一般不需要手动关闭，但作为示例演示一下)
    }
}
```

**ACM 模式下 `PrintWriter` 的常见用法示例:**

*   **输出单个结果：**

    ```java
    PrintWriter writer = new PrintWriter(System.out);
    int result = calculateSum(a, b);
    writer.println(result);
    writer.flush();
    ```

*   **输出多个结果，中间用空格分隔，最后换行：**

    ```java
    PrintWriter writer = new PrintWriter(System.out);
    int result1 = calculateResult1();
    int result2 = calculateResult2();
    writer.print(result1 + " ");
    writer.println(result2);
    writer.flush();
    ```

*   **格式化输出，例如保留两位小数：**

    ```java
    PrintWriter writer = new PrintWriter(System.out);
    double average = calculateAverage();
    writer.printf("%.2f\n", average); // 保留两位小数输出
    writer.flush();
    ```

**3.3. `System.out` vs. `PrintWriter` 的选择**

*   **性能要求不高，输出数据量不大，格式要求简单：** 可以优先考虑 `System.out.println()` 和 `System.out.print()`，代码更简洁。
*   **性能要求高，输出数据量大，或者需要格式化输出，或者时间限制非常严格：**  必须使用 `PrintWriter`，以避免因输出效率过低而导致超时，并满足格式化输出的需求。
*   **ACM 笔试的默认选择：**  为了应对各种可能的场景，**推荐在 ACM 模式的笔试中默认使用 `PrintWriter` 进行输出**。  与 `BufferedReader` 配合使用，可以构建高效的输入输出框架。

**4. ACM 模式下处理多组测试用例**

ACM 题目通常包含多组测试用例。你的程序需要能够循环读取输入，并对每组输入都给出相应的输出。常见的测试用例组织方式有以下几种：

**4.1. 固定数量的测试用例**

题目会明确给出测试用例的数量 `T`。你的程序需要先读取 `T`，然后循环执行 `T` 次测试逻辑。

**示例代码 (使用 `Scanner`):**

```java
import java.util.Scanner;

public class FixedTestCaseScanner {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // 读取测试用例数量 T
        for (int i = 0; i < t; i++) {
            // 读取每组测试用例的输入数据
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            // 计算结果
            int sum = a + b;
            // 输出结果
            System.out.println("Case #" + (i + 1) + ": " + sum); // 格式化输出，例如 "Case #1: 3"
        }
        scanner.close();
    }
}
```

**示例代码 (使用 `BufferedReader` 和 `PrintWriter`):**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class FixedTestCaseBufferedReader {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        int t = Integer.parseInt(reader.readLine()); // 读取测试用例数量 T
        for (int i = 0; i < t; i++) {
            // 读取每组测试用例的输入数据
            String[] parts = reader.readLine().split(" ");
            int a = Integer.parseInt(parts[0]);
            int b = Integer.parseInt(parts[1]);
            // 计算结果
            int sum = a + b;
            // 输出结果
            writer.println("Case #" + (i + 1) + ": " + sum); // 格式化输出
        }
        writer.flush();
        reader.close();
        writer.close();
    }
}
```

**4.2. 输入驱动数量的测试用例**

题目不会直接给出测试用例数量，而是通过输入数据的特定格式来暗示。 例如，第一行输入是测试用例的数量，或者每组测试用例的第一个输入值表示这组测试是否有效。

**示例：第一行输入是测试用例数量 (与 4.1 类似，只是输入方式不同)**

**示例代码 (使用 `Scanner`):**  与 4.1 示例代码相同。

**示例代码 (使用 `BufferedReader` 和 `PrintWriter`):**  与 4.1 示例代码相同。

**示例：每组测试用例的第一个输入值决定是否继续 (例如，输入 `-1` 表示结束)**

**示例代码 (使用 `Scanner`):**

```java
import java.util.Scanner;

public class InputDrivenTestCaseScanner {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int caseNum = 1;
        while (true) {
            int a = scanner.nextInt();
            if (a == -1) {
                break; // 输入 -1 结束
            }
            int b = scanner.nextInt();
            int sum = a + b;
            System.out.println("Case #" + caseNum++ + ": " + sum);
        }
        scanner.close();
    }
}
```

**示例代码 (使用 `BufferedReader` 和 `PrintWriter`):**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class InputDrivenTestCaseBufferedReader {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        int caseNum = 1;
        while (true) {
            String[] parts = reader.readLine().split(" ");
            int a = Integer.parseInt(parts[0]);
            if (a == -1) {
                break; // 输入 -1 结束
            }
            int b = Integer.parseInt(parts[1]);
            int sum = a + b;
            writer.println("Case #" + caseNum++ + ": " + sum);
        }
        writer.flush();
        reader.close();
        writer.close();
    }
}
```

**4.3. EOF (End-of-File) 结束的测试用例**

题目不会给出测试用例数量，程序需要循环读取输入，直到读到文件末尾 (EOF) 时结束。  对于 `Scanner`，可以使用 `scanner.hasNext()` 或 `scanner.hasNextLine()` 判断是否还有输入。 对于 `BufferedReader`， `reader.readLine()` 返回 `null` 表示 EOF。

**示例代码 (使用 `Scanner`):**

```java
import java.util.Scanner;

public class EofTestCaseScanner {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int caseNum = 1;
        while (scanner.hasNextInt()) { // 判断是否有下一个 int 输入 (或 scanner.hasNextLine() 判断是否有下一行)
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            int sum = a + b;
            System.out.println("Case #" + caseNum++ + ": " + sum);
        }
        scanner.close();
    }
}
```

**示例代码 (使用 `BufferedReader` 和 `PrintWriter`):**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class EofTestCaseBufferedReader {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        String line;
        int caseNum = 1;
        while ((line = reader.readLine()) != null) { // readLine() 返回 null 表示 EOF
            String[] parts = line.split(" ");
            int a = Integer.parseInt(parts[0]);
            int b = Integer.parseInt(parts[1]);
            int sum = a + b;
            writer.println("Case #" + caseNum++ + ": " + sum);
        }
        writer.flush();
        reader.close();
        writer.close();
    }
}
```

**5. ACM 模式输入输出示例问题及完整代码**

**示例问题 1：A+B Problem**

**题目描述：**

输入两个整数 A 和 B，计算它们的和并输出。

**输入格式：**

输入包含多组测试用例。
每组测试用例占一行，包含两个整数 A 和 B，用空格分隔。
当输入 `0 0` 时表示输入结束，不需要处理。

**输出格式：**

对于每组测试用例，输出 A+B 的结果，每组结果占一行。

**样例输入：**

```
1 2
3 4
5 6
0 0
```

**样例输出：**

```
3
7
11
```

**Java 代码 (使用 `BufferedReader` 和 `PrintWriter`):**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class ABProblem {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(" ");
            int a = Integer.parseInt(parts[0]);
            int b = Integer.parseInt(parts[1]);
            if (a == 0 && b == 0) {
                break; // 输入 0 0 结束
            }
            int sum = a + b;
            writer.println(sum);
        }
        writer.flush();
        reader.close();
        writer.close();
    }
}
```

**示例问题 2：简单计算器**

**题目描述：**

实现一个简单的计算器，支持加法 (+) 和减法 (-)。
输入两个整数和一个运算符 (+ 或 -)，计算结果并输出。

**输入格式：**

输入包含多组测试用例。
每组测试用例占一行，包含两个整数 num1 和 num2，以及一个运算符 op (+ 或 -)，用空格分隔。
当输入 `0 0 ?` (问号可以是任意运算符) 时表示输入结束，不需要处理。

**输出格式：**

对于每组测试用例，输出计算结果，每组结果占一行。

**样例输入：**

```
10 5 +
20 8 -
5 3 +
0 0 ?
```

**样例输出：**

```
15
12
8
```

**Java 代码 (使用 `BufferedReader` 和 `PrintWriter`):**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class SimpleCalculator {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(" ");
            int num1 = Integer.parseInt(parts[0]);
            int num2 = Integer.parseInt(parts[1]);
            String op = parts[2];
            if (num1 == 0 && num2 == 0) {
                break; // 输入 0 0 ? 结束
            }
            int result = 0;
            if (op.equals("+")) {
                result = num1 + num2;
            } else if (op.equals("-")) {
                result = num1 - num2;
            }
            writer.println(result);
        }
        writer.flush();
        reader.close();
        writer.close();
    }
}
```

**示例问题 3：反转字符串**

**题目描述：**

输入一个字符串，将其反转后输出。

**输入格式：**

输入包含多组测试用例。
每组测试用例占一行，包含一个字符串。
当输入 "END" 时表示输入结束，不需要处理。

**输出格式：**

对于每组测试用例，输出反转后的字符串，每组结果占一行。

**样例输入：**

```
hello
world
test
END
```

**样例输出：**

```
olleh
dlrow
tset
```

**Java 代码 (使用 `BufferedReader` 和 `PrintWriter`):**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class ReverseString {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.equals("END")) {
                break; // 输入 "END" 结束
            }
            String reversedLine = new StringBuilder(line).reverse().toString();
            writer.println(reversedLine);
        }
        writer.flush();
        reader.close();
        writer.close();
    }
}
```

**6. ACM 模式 Java 输入输出性能优化**

*   **使用 `BufferedReader` 和 `PrintWriter`：** 优先选择 `BufferedReader` 进行输入，`PrintWriter` 进行输出，以提高 I/O 效率。
*   **减少不必要的对象创建：**  在循环中避免频繁创建新的对象，尤其是在性能敏感的代码段。 例如，`StringBuilder` 可以在循环外部创建，然后在每次循环中 `append` 和 `setLength(0)` 重用。
*   **批量处理：**  如果可能，尽量批量读取和写入数据，而不是逐个字符或逐行进行 I/O 操作。 `BufferedReader` 的 `readLine()` 和 `PrintWriter` 的 `println()` 等方法已经使用了缓冲，可以实现一定程度的批量处理。
*   **避免频繁的 `flush()` 操作：**  `PrintWriter` 的 `println()` 和 `printf()` 方法通常会自动 flush 缓冲区。 如果没有特殊需求，不需要手动频繁调用 `flush()`，频繁 flush 反而可能降低性能。

**7. ACM 模式 Java 输入输出常见错误和调试技巧**

*   **输入格式错误：**
    *   **问题：** 输入数据格式与题目描述不符，例如空格数量不对、分隔符错误、数据类型不匹配等。
    *   **调试：** 仔细阅读题目输入格式描述，检查输入代码是否正确解析了输入。 可以先将读取到的原始输入字符串打印出来，检查是否符合预期。
*   **输出格式错误 (Presentation Error, PE)：**
    *   **问题：** 输出结果内容正确，但格式不符合题目要求，例如多余或缺少空格、换行符、大小写错误、精度问题等。
    *   **调试：** 仔细阅读题目输出格式描述，**逐字逐句对比你的程序输出和样例输出**，找出格式差异。 特别注意空格、换行符、小数点位数等细节。 使用 `PrintWriter` 的 `printf()` 方法可以更精确地控制输出格式。
*   **时间超限 (Time Limit Exceeded, TLE)：**
    *   **问题：** 程序运行时间超过了题目限制，可能是算法效率太低，也可能是输入输出效率过低（尤其在使用低效的输入输出方法时，例如在大量数据输入输出时使用 `Scanner` 和 `System.out`）。
    *   **调试：** 首先检查算法复杂度是否过高，尝试优化算法。 如果算法已经优化，但仍然 TLE，则需要检查输入输出代码，尝试使用 `BufferedReader` 和 `PrintWriter` 替换 `Scanner` 和 `System.out`。
*   **运行时错误 (Runtime Error, RE)：**
    *   **问题：** 程序在运行时发生错误，例如数组越界、空指针异常、除零错误、`NumberFormatException` (数字格式异常，例如尝试将非数字字符串转换为整数) 等。
    *   **调试：** 仔细检查代码，特别是数组访问、指针操作、类型转换等容易出错的地方。  使用 `try-catch` 块捕获可能抛出的异常，例如 `NumberFormatException`，并进行错误处理。  在本地 IDE 中运行程序，使用调试器单步调试，或者添加 `System.err.println()` 输出错误信息，帮助定位错误。

**8. ACM 模式 Java 输入输出模板代码**

这是一个常用的 ACM 模式 Java 输入输出模板代码，使用了 `BufferedReader` 和 `PrintWriter`，并处理了 `IOException` 异常。 你可以在此模板基础上修改和扩展，以适应不同的题目需求。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class ACMTemplate {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        // --- 在这里编写你的解题代码 ---

        String line;
        while ((line = reader.readLine()) != null) { // 或使用其他循环条件，例如固定测试用例数量
            // 解析输入数据
            String[] parts = line.split(" ");
            int a = Integer.parseInt(parts[0]);
            int b = Integer.parseInt(parts[1]);

            // 计算结果
            int result = a + b;

            // 输出结果
            writer.println(result); // 或使用 writer.printf() 进行格式化输出
        }

        // --- 解题代码结束 ---
        writer.flush();
        reader.close();
        writer.close();
    }
}
```

**9. ACM 模式练习平台推荐**

*   **LeetCode:** (虽然 LeetCode 主要使用核心模式，但在 "Contest" 竞赛模式中也常有 ACM 模式的题目)
*   **Codeforces:**  著名的算法竞赛平台，题目质量高，比赛频繁，完全是 ACM 模式。
*   **AtCoder:**  日本的算法竞赛平台，题目难度分级清晰，适合不同水平的选手，也是 ACM 模式。
*   **牛客网:**  中国的算法竞赛和求职平台，有大量的 ACM 模式练习题和比赛。
*   **POJ (Peking University Online Judge):**  老牌的 OJ 平台，有很多经典的 ACM 题目。
*   **洛谷:**  中国的 OJ 平台，适合初学者和进阶选手，也支持 ACM 模式。
*   **HDU (Hangzhou Dianzi University Online Judge):**  中国的 OJ 平台，题目数量多，适合练习。

通过在这些平台上进行大量的练习，你可以逐步熟悉 ACM 模式的输入输出处理，并提高你的算法和编程能力，为应对互联网大厂的笔试做好充分准备！ 祝你笔试顺利！

















































































































































## 迭代和递归什么区别？


**迭代 (Iteration) 和 递归 (Recursion) 的区别：深入解析与面试话术**

迭代和递归是编程中两种非常重要的控制流程结构，用于重复执行一段代码。虽然它们都可以实现循环的效果，但其背后的机制、使用场景以及优缺点却有显著的区别。 理解迭代和递归的区别是编程基础中的核心概念，也是面试中常考的知识点。

下面我将从定义、机制、特点、优缺点、应用场景以及面试话术等多个方面，对迭代和递归进行深入的对比和讲解，并通过代码示例帮助你更好地理解。

**1. 定义和机制：本质上的不同**

**迭代 (Iteration):**

*   **定义:** 迭代是一种**循环控制结构**，通过**重复执行**一段代码块（称为循环体）来解决问题。  迭代依赖于**循环语句**（如 `for` 循环、`while` 循环）显式地控制循环的次数或条件。
*   **机制:** 迭代通过**循环变量**的更新或**条件判断**来控制循环的进行。程序会**顺序执行**循环体内的代码，每次循环都基于上一次循环的状态进行。
*   **内存使用:** 迭代通常使用**固定的内存空间**，因为每次循环都在相同的函数调用栈帧内执行，不会产生额外的栈帧开销（除非循环体内部有函数调用）。

**递归 (Recursion):**

*   **定义:** 递归是一种**函数调用自身**的编程技巧。一个递归函数会直接或间接地调用自身来解决规模更小的子问题，直到达到**基本情况 (base case)**，停止递归并返回结果。
*   **机制:** 递归基于**函数调用栈 (call stack)**。每次递归调用都会创建一个新的**栈帧**，用于存储当前函数调用的局部变量、参数和返回地址。当达到基本情况时，递归开始**回溯**，逐层返回结果，并释放栈帧。
*   **内存使用:** 递归的内存使用与递归深度有关。每次递归调用都会增加函数调用栈的深度，如果递归深度过大，可能会导致**栈溢出 (StackOverflowError)**。

**核心区别总结:**

| 特征         | 迭代 (Iteration)                 | 递归 (Recursion)                 |
| ----------- | ------------------------------- | ------------------------------- |
| 控制结构     | 循环语句 (for, while, do-while)  | 函数调用自身                  |
| 执行方式     | 重复执行代码块                  | 函数调用栈，逐层调用和返回        |
| 终止条件     | 循环条件 (显式)                | 基本情况 (Base Case) (显式)        |
| 内存使用     | 固定 (通常)                      | 与递归深度相关，可能栈溢出       |
| 代码结构     | 循环结构，通常更直接             | 函数结构，有时更简洁，有时更复杂 |
| 解决问题     | 适合循环规律明显的问题            | 适合问题可以分解为相似子问题的问题 |

**2. 代码示例：迭代 vs. 递归 (Java)**

为了更直观地理解迭代和递归的区别，我们以计算阶乘 (Factorial) 为例，分别用迭代和递归实现。

**2.1 迭代实现阶乘:**

```java
public class FactorialIteration {

    public static int factorialIterative(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Factorial is not defined for negative numbers");
        }
        if (n == 0) {
            return 1; // 0! = 1
        }

        int result = 1; // 初始化结果为 1
        // 使用 for 循环进行迭代
        for (int i = 1; i <= n; i++) {
            result *= i; // 循环累乘，result = result * i
        }
        return result; // 返回最终的阶乘结果
    }

    public static void main(String[] args) {
        int num = 5;
        int fact = factorialIterative(num);
        System.out.println(num + "的阶乘 (迭代) 是: " + fact); // 输出: 5的阶乘 (迭代) 是: 120
    }
}
```

**代码注释:**

*   `factorialIterative(int n)` 函数使用迭代 (for 循环) 来计算 `n` 的阶乘。
*   首先处理负数和 0 的特殊情况。
*   `result` 变量初始化为 1，用于累乘。
*   `for` 循环从 1 迭代到 `n`，每次循环将 `result` 乘以当前的 `i` 值。
*   循环结束后，`result` 变量存储了 `n` 的阶乘，并返回。

**2.2 递归实现阶乘:**

```java
public class FactorialRecursion {

    public static int factorialRecursive(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Factorial is not defined for negative numbers");
        }
        // 基本情况 (Base Case): n = 0 时，0! = 1，递归终止条件
        if (n == 0) {
            return 1;
        } else {
            // 递归调用: n! = n * (n-1)!
            // 函数调用自身，计算 (n-1) 的阶乘，然后乘以 n
            return n * factorialRecursive(n - 1);
        }
    }

    public static void main(String[] args) {
        int num = 5;
        int fact = factorialRecursive(num);
        System.out.println(num + "的阶乘 (递归) 是: " + fact); // 输出: 5的阶乘 (递归) 是: 120
    }
}
```

**代码注释:**

*   `factorialRecursive(int n)` 函数使用递归来计算 `n` 的阶乘。
*   同样首先处理负数情况。
*   **基本情况 (Base Case):** `if (n == 0)`，当 `n` 等于 0 时，直接返回 1，这是递归的终止条件，防止无限递归。
*   **递归调用:** `return n * factorialRecursive(n - 1);`， 这是递归的核心。函数调用自身 `factorialRecursive(n - 1)` 来计算 `(n-1)` 的阶乘，然后将结果乘以 `n`。
*   递归过程会不断调用自身，每次 `n` 的值减 1，直到 `n` 变为 0，触发基本情况，递归开始回溯，逐层返回结果。

**递归调用过程图解 (factorialRecursive(5)):**

```
factorialRecursive(5)
= 5 * factorialRecursive(4)
= 5 * (4 * factorialRecursive(3))
= 5 * (4 * (3 * factorialRecursive(2)))
= 5 * (4 * (3 * (2 * factorialRecursive(1))))
= 5 * (4 * (3 * (2 * (1 * factorialRecursive(0)))))
= 5 * (4 * (3 * (2 * (1 * 1))))  // 基本情况: factorialRecursive(0) 返回 1
= 5 * (4 * (3 * (2 * 1)))
= 5 * (4 * (3 * 2))
= 5 * (4 * 6)
= 5 * 24
= 120
```

**3. 迭代和递归的优缺点**

**迭代 (Iteration):**

**优点:**

*   **效率高，资源消耗少:** 迭代通常比递归效率更高，因为迭代没有函数调用的开销，不会产生额外的栈帧，内存使用相对固定。
*   **易于理解和调试:** 迭代的代码逻辑通常更直接，更容易跟踪循环变量的变化，调试相对简单。
*   **避免栈溢出:** 迭代不会因为循环次数过多而导致栈溢出问题。

**缺点:**

*   **代码可能稍显冗长:** 对于某些问题，迭代的实现代码可能会比递归更长，结构可能不如递归简洁。
*   **不适合解决所有问题:** 对于某些问题，特别是那些本身就具有递归结构的问题（例如树的遍历、分治算法），使用迭代实现可能比较复杂或难以理解。

**递归 (Recursion):**

**优点:**

*   **代码简洁、优雅:** 对于某些问题，递归的实现代码非常简洁、优雅，更符合问题的自然描述方式，例如树的遍历、快速排序、归并排序等。
*   **更易于理解某些算法:** 递归能够更自然地表达某些算法的逻辑，例如分治策略、回溯算法等。

**缺点:**

*   **效率较低，资源消耗大:** 递归每次函数调用都会产生新的栈帧，函数调用和返回的开销较大，效率相对较低。
*   **可能导致栈溢出:** 如果递归深度过大，超过了函数调用栈的容量限制，会导致栈溢出错误。
*   **调试相对困难:** 递归的调用链条较深，跟踪和调试递归函数可能比迭代更复杂。

**选择建议:**

*   **优先考虑迭代:** 在性能敏感的场景，或者当问题可以使用简单的循环结构解决时，优先考虑使用迭代。
*   **适当使用递归:** 对于问题本身就具有递归结构，或者使用递归能使代码更简洁、易懂的情况，可以考虑使用递归。但需要注意控制递归深度，避免栈溢出，并考虑性能影响。
*   **尾递归优化:**  某些编程语言（例如 Scheme, Scala, 部分版本的 Java 等）支持尾递归优化。如果使用尾递归，编译器或解释器可以将尾递归转换为迭代执行，从而避免栈溢出，并提高性能。但 Java 虚拟机 (JVM) 对尾递归的优化支持有限，通常不依赖 Java 的尾递归优化。

**4. 应用场景：什么情况下用迭代，什么情况下用递归？**

**适合使用迭代的场景:**

*   **循环次数已知或可控的问题:** 例如，遍历数组、列表，执行固定次数的重复操作。
*   **性能敏感的场景:** 需要追求效率，减少资源消耗的场景。
*   **简单循环逻辑:**  循环逻辑比较直接，使用循环语句即可清晰表达的场景。
*   **需要避免栈溢出的场景:**  当循环次数可能非常大时，为了避免栈溢出，应使用迭代。

**适合使用递归的场景:**

*   **问题可以分解为相似的子问题:**  例如，树的遍历、图的搜索、分治算法（快速排序、归并排序）、动态规划等。
*   **代码简洁性优先:**  在某些情况下，递归实现的代码更简洁、易懂，代码可读性更重要时。
*   **算法本身就是递归定义的:**  例如，数学上的递归定义、某些数据结构的递归特性（树、图）。
*   **回溯算法:**  需要尝试多种可能性，并在不满足条件时回退到上一步的算法，递归天然适合回溯。

**常见应用示例:**

*   **迭代:**
    *   遍历数组、链表、集合
    *   计算累加、累乘
    *   查找元素 (线性查找)
    *   简单的数据处理循环

*   **递归:**
    *   树的遍历 (前序、中序、后序、层序)
    *   图的深度优先搜索 (DFS)
    *   分治算法 (快速排序、归并排序、二分查找)
    *   回溯算法 (八皇后问题、数独求解、迷宫问题)
    *   斐波那契数列 (虽然迭代更高效，但递归版本更简洁)
    *   汉诺塔问题

**5. 面试话术：如何清晰流畅地回答迭代和递归的区别？**

当面试官问到 "迭代和递归有什么区别？" 时，你可以按照以下结构进行回答，力求清晰、全面、深入：

**你的回答框架（示例话术）：**

**1.  简洁定义 (开门见山，点明核心):**

> "迭代和递归都是编程中用于重复执行代码的控制结构，但它们在实现机制上有着本质的区别。 **迭代是通过循环语句显式地控制循环次数，而递归是通过函数调用自身来解决子问题。**"

**2.  机制和内存 (深入原理，突出差异):**

> "从机制上讲，**迭代是基于循环结构，程序顺序执行，内存使用相对固定。** 而**递归是基于函数调用栈，每次递归调用都会创建新的栈帧，用于存储局部变量和返回地址，内存使用与递归深度有关。**  如果递归深度过大，可能会导致栈溢出。"

**3.  优缺点对比 (权衡利弊，体现选择能力):**

> "**迭代的优点是效率高、资源消耗少、易于理解和调试，并且避免栈溢出。 但缺点是代码可能稍显冗长，不适合解决所有问题。 递归的优点是代码简洁、优雅，更易于理解某些算法，但缺点是效率较低、资源消耗大，可能导致栈溢出，调试也相对困难。**"

**4.  应用场景 (结合实际，展现应用理解):**

> "**一般来说，迭代更适合循环次数已知或可控、性能敏感、简单循环逻辑的场景。  而递归更适合问题可以分解为相似子问题、代码简洁性优先、算法本身是递归定义的场景，例如树的遍历、分治算法、回溯算法等。**  在实际开发中，我们需要根据具体问题和需求，权衡迭代和递归的优缺点，选择合适的实现方式。"

**5.  补充 (可选，加深印象):**

> "在某些编程语言中，尾递归可以被优化为迭代执行，从而在保持递归代码简洁性的同时，避免栈溢出问题。 但 Java 对尾递归的优化支持有限。"

**面试话术技巧:**

*   **结构化回答:**  按照定义 -> 机制 -> 优缺点 -> 应用场景 -> 补充的逻辑结构回答，条理清晰。
*   **关键词突出:**  在回答中突出 "循环语句"、"函数调用"、"栈帧"、"栈溢出"、"效率"、"简洁性" 等关键词，让面试官快速抓住重点。
*   **对比分析:**  通过优缺点的对比，突出迭代和递归的不同特点和适用场景，体现你对两种方法的理解和选择能力。
*   **结合实际:**  如果可能，结合实际项目经验或算法应用场景，用具体的例子说明迭代和递归的应用，增加回答的说服力。
*   **自信流畅:**  提前准备，熟悉迭代和递归的原理和应用，在面试时才能表达自信流畅。

**总结:**

理解迭代和递归的区别是编程基础的核心内容。  掌握它们的定义、机制、优缺点、应用场景，并能清晰流畅地表达出来，对于面试至关重要。  通过学习本文的内容，并结合代码示例进行练习，相信你能够充分理解迭代和递归，在面试中脱颖而出。
































# 数组




## [力扣704. 二分查找](https://leetcode.cn/problems/binary-search/description/)

已解答
简单

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
 

提示：

1. 你可以假设 nums 中的所有元素是不重复的。
2. n 将在 [1, 10000]之间。
3. nums 的每个元素都将在 [-9999, 9999]之间。








### C语言





```C

int lower_bound( int* nums, int numsSize, int target ){
    // lower_bound 函数用于查找第一个不小于目标值的位置，lower_bound意思为“下界，底部的边界”


    int left=0;
    // 初始化左边界
    int right = numsSize - 1;
    // 初始化右边界
    

    while( left <= right ){
        // 当左边界小于等于右边界时继续循环

        /*
        在二分查找算法中，while (left <= right) 和 while (left < right) 的区别在于它们处理边界条件的方式不同。

        while (left <= right)
        这种写法表示在 left 等于 right 时，循环仍然会继续执行。这意味着当 left 和 right 相等时，仍然会计算一次 mid 并进行比较。这种方式确保了所有可能的元素都被检查到，适用于查找目标值的确切位置。
        while (left <= right)：
        当 left 和 right 相等时，仍然会执行循环体。
        确保所有元素都被检查到。
        适用于查找目标值的确切位置。

        while (left < right)
        这种写法表示在 left 等于 right 时，循环会停止。这意味着当 left 和 right 相等时，不会再计算 mid 并进行比较。这种方式适用于查找范围的边界，但可能会遗漏最后一个元素的检查。
        while (left < right)：
        当 left 和 right 相等时，循环停止。
        可能会遗漏最后一个元素的检查。
        适用于查找范围的边界。

        */

        int mid = left + (right - left) / 2 ;
        // 计算中间位置

        if( nums[mid] < target ){
            // left < mid < target < right，中间值小于目标值，说明目标值在右半部分

            left = mid + 1;
            // 更新left边界为mid+1，以将查找target的范围缩小一半


        }
        else{
            // left < target < mid < right,中间值大于等于目标值，说明目标值在左半部分

            right = mid - 1;
            // 更新right边界为mid-1，以将查找target的范围缩小一半

        }



    }

    return left;
    // 返回左边界，即第一个不小于目标值的位置


}



int search(int* nums, int numsSize, int target) {
    // search 函数用于在数组中查找目标值的位置
    
    int i = lower_bound( nums, numsSize, target );

    return ( i < numsSize  &&  nums[i] == target ) ? i : -1 ;
    // 如果找到目标值，返回其下标；否则返回 -1

}

```






### C++


```C++

class Solution {
public:


    int lower_bound( vector<int> &nums, int target ) {

        int left = 0, right = (int) nums.size() - 1; 

        while( left <= right ) {

            int mid = left + ( right - left ) / 2;

            if( nums[mid] < target ) {

                left = mid + 1;

            }
            else {

                right = mid - 1;

            }


        }

        return left;
    }






    int search(vector<int>& nums, int target) {

        int i = lower_bound( nums, target );

        return i < nums.size() && nums[i] == target ? i : -1;

        
    }





};

```






### Java语言



















































## [力扣27. 移除元素](https://leetcode.cn/problems/remove-element/description/)

已解答
简单

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。

假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：

- 更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。
- 返回 k。

用户评测：

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```
如果所有的断言都通过，你的解决方案将会 通过。

 

示例 1：

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

示例 2：

输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
 

提示：

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100













### 新数组暂存法-Java




```java

class Solution {
    /**
     * 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。
     * 元素的顺序可能发生改变。
     * 然后返回 nums 中与 val 不同的元素的数量。
     *
     * 假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：
     *
     * 更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。
     * 返回 k。
     *
     * 示例 1：
     * 输入：nums = [3,2,2,3], val = 3
     * 输出：2, nums = [2,2,_,_]
     * 解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
     *
     * 示例 2：
     * 输入：nums = [0,1,2,2,3,0,4,2], val = 2
     * 输出：5, nums = [0,1,4,0,3,_,_,_]
     * 解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
     *
     * @param nums  输入的整数数组
     * @param val   需要移除的数值
     * @return      返回 nums 中与 val 不同的元素的数量 (k)
     *              修改后的 nums 数组的前 k 个元素包含不等于 val 的元素
     */
    public int removeElement(int[] nums, int val) {

        int k = 0; // 初始化计数器 k，用于记录不等于 val 的元素的数量。最终 k 将作为返回值。

        int j = 0; // 初始化索引 j，用于在临时数组 temp 中存放不等于 val 的元素的位置。

        int[] temp = new int[nums.length]; // 创建一个新的临时数组 temp，大小与输入数组 nums 相同。
                                          // 这个数组用于暂存 nums 中不等于 val 的元素。

        // 遍历输入数组 nums 的每一个元素
        for (int i = 0; i < nums.length; i++) {

            // 检查当前元素 nums[i] 是否不等于给定的值 val
            if (val != nums[i]) {
                // 如果 nums[i] 不等于 val，则说明这个元素需要保留

                temp[j] = nums[i]; // 将 nums[i] 复制到临时数组 temp 的 j 位置。
                                  // 相当于把不等于 val 的元素放到 temp 数组的前面部分。
                j++; // 移动临时数组 temp 的索引 j，指向下一个可存放元素的位置。
                k++; // 增加计数器 k，因为我们找到了一个不等于 val 的元素。

            }
            else {
                // 如果 nums[i] 等于 val，则说明这个元素需要移除，
                // 在 else 代码块中，我们什么都不做，相当于忽略了这个等于 val 的元素。
                // 它不会被复制到 temp 数组中，也就实现了“移除”的效果。
            }
        }

        // 循环结束后，temp 数组的前 k 个位置存放了 nums 中所有不等于 val 的元素。
        // 现在需要将 temp 数组的前 k 个元素复制回原始数组 nums 的前 k 个位置。
        // 注意题目要求是 "原地 移除"，虽然这里使用了 temp 数组，但是最终修改的是输入的 nums 数组的前部分。
        for (int i = 0; i < temp.length; i++) {
            // 将 temp 数组的元素逐个复制回 nums 数组的对应位置。
            // 实际上只需要复制前 k 个元素就够了，但复制整个 temp 数组到 nums 数组也是可以的，
            // 因为题目只要求 nums 数组的前 k 个元素是正确的，k 后面的元素是什么值并不重要。
            nums[i] = temp[i];
        }

        return k; // 返回计数器 k，它代表了 nums 数组中不等于 val 的元素的数量。
                   // 并且 nums 数组的前 k 个位置已经被修改为不等于 val 的元素。
    }
}

```








### 双指针法-Java







```java

class Solution {
    /**
     * 
     * @param nums  输入的整数数组
     * @param val   需要移除的数值
     * @return      返回 nums 中与 val 不同的元素的数量 (k)
     *              修改后的 nums 数组的前 k 个元素包含不等于 val 的元素
     */
    public int removeElement(int[] nums, int val) {
        // 双指针法

        int k = 0; // 初始化计数器 k，也作为慢指针，指向下一个要放置非 val 元素的位置。
                   // k 的值最终会是不等于 val 的元素的数量。

        // 遍历输入数组 nums 的每一个元素，使用 i 作为快指针。
        for (int i = 0; i < nums.length; i++) {

            // 检查当前元素 nums[i] 是否不等于给定的值 val
            if (nums[i] != val) {
                // 如果 nums[i] 不等于 val，则说明这个元素需要保留

                nums[k] = nums[i]; // 将 nums[i] 的值复制到 nums[k] 的位置。
                                  // 这相当于将不等于 val 的元素移动到数组的前面部分。
                                  // 注意这里是直接在原数组 nums 上进行操作，实现了 "原地移除"。
                k++; // 移动慢指针 k，指向下一个可存放非 val 元素的位置。
                     // 同时，k 的增加也表示找到了一个不等于 val 的元素，计数加一。
            }
            // 如果 nums[i] 等于 val，则什么都不做。
            // 快指针 i 继续前进，而慢指针 k 保持不动。
            // 相当于跳过等于 val 的元素，并且在数组的前面部分 "空出" 一个位置，
            // 这个位置后续可能会被非 val 的元素覆盖。
        }

        // 循环结束后，nums 数组的前 k 个位置存放了所有不等于 val 的元素。
        // k 的值就是不等于 val 的元素的数量。
        // nums 数组中索引 k 及以后的元素的值可以是任意的，题目并不关心。
        return k; // 返回计数器 k，它代表了 nums 数组中不等于 val 的元素的数量。
                   // 并且 nums 数组的前 k 个位置已经被修改为不等于 val 的元素。
    }
}


```









### 双指针法-C++





```C++


class Solution {
public:
    int removeElement(vector<int>& nums, int val) {


        int k=0;

        for( int i=0; i < nums.size(); i++ ) {

            if( nums[i] != val ) {

                nums[k] = nums[i];

                k++;
                
            }


        }



        return k;


        
    }
};


```





















## [力扣977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)
已解答
简单

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

 

示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]

示例 2：

输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
 

提示：

- 1 <= nums.length <= 10^4
- -10^4 <= nums[i] <= 10^4
- nums 已按 非递减顺序 排序















### 将数组 nums 中的数平方后直接排序-Java




```Java


class Solution {
    /**
     * @param nums  按非递减顺序排序的整数数组
     * @return      返回每个数字的平方组成的新数组，并按非递减顺序排序
     */
    public int[] sortedSquares(int[] nums) {
        // 排序法：此方法先对原数组的每个元素进行平方操作，然后再对整个数组进行排序。
        // 这种方法思路简单直接，易于理解。

        // 遍历数组 nums 的每一个元素
        for (int i = 0; i < nums.length; i++) {
            // 对当前元素 nums[i] 进行平方操作，并将结果赋值回 nums[i]
            nums[i] *= nums[i]; // 相当于 nums[i] = nums[i] * nums[i];
                                 // 经过这个循环后，nums 数组中的每个元素都变成了它原来的平方值。
        }

        // 对数组 nums 进行排序。由于之前已经进行了平方操作，
        // 排序后的数组 nums 将会是平方值按非递减顺序排列的数组。
        Arrays.sort(nums); // 使用 Arrays.sort() 方法对整个 nums 数组进行升序排序。
                           // 对于基本类型数组（如 int[]），Arrays.sort() 使用高效的排序算法。

        return nums; // 返回排序后的数组 nums。
                     // 此时的 nums 数组已经包含了原数组每个元素的平方值，并且这些平方值是按非递减顺序排列的。
    }
}


```














### 双指针法-Java



```Java

class Solution {
    /**
     * 提示：由于输入数组 nums 已经按非递减顺序排序，平方后的最大值可能出现在数组的两端。
     *      因此可以使用双指针方法，从两端向中间遍历，比较平方值的大小，并将较大的值从后向前放入新数组中。
     *
     * @param nums  按非递减顺序排序的整数数组
     * @return      返回每个数字的平方组成的新数组，并按非递减顺序排序
     */
    public int[] sortedSquares(int[] nums) {
        // 双指针法：利用输入数组已排序的特性，从两端向中间处理，构建排序后的平方数组。

        // 对数组中的每个元素进行平方操作 (原地修改 nums 数组)
        for (int i = 0; i < nums.length; i++) {
            nums[i] *= nums[i]; // 将 nums[i] 替换为其平方值
        }
        // 此时 nums 数组中的元素都是平方值，但顺序可能不是最终排序的顺序。

        int left = 0;          // 初始化左指针 left，指向数组的起始位置
        int right = nums.length - 1; // 初始化右指针 right，指向数组的末尾位置
        int k = nums.length - 1;   // 初始化新数组的指针 k，指向新数组的末尾位置
                                   // 我们将从新数组的末尾向前填充排序后的平方值。
        int[] rets = new int[nums.length]; // 创建一个新的数组 rets，用于存放排序后的平方值结果。
                                          // 长度与原数组 nums 相同。

        // 双指针循环，直到左指针 left 超过右指针 right
        for (; left <= right; ) { // 循环条件：当左指针 left 小于等于 右指针 right 时继续

            // 比较 nums[left] 和 nums[right] 的值 (此时数组 nums 中存储的是平方值)
            if (nums[left] < nums[right]) {
                // 如果左指针指向的平方值小于右指针指向的平方值，
                // 说明右指针指向的平方值较大，应该放在排序后数组的当前末尾 (rets[k])

                rets[k] = nums[right]; // 将较大的平方值 (nums[right]) 放入 rets[k]
                right--;               // 右指针向左移动一位，考察前一个较大的平方值
                k--;                 // 新数组的指针 k 也向前移动一位，准备放置下一个较大的平方值

            } else {
                // 如果左指针指向的平方值大于等于右指针指向的平方值，
                // 说明左指针指向的平方值较大或相等，应该放在排序后数组的当前末尾 (rets[k])

                rets[k] = nums[left];  // 将较大的平方值 (nums[left]) 放入 rets[k]
                left++;                // 左指针向右移动一位，考察下一个较大的平方值
                k--;                  // 新数组的指针 k 也向前移动一位，准备放置下一个较大的平方值
            }
            // 循环会持续到 left > right，此时左右指针交错，表示所有元素都已处理完毕。
        }

        return rets; // 返回排序后的平方值数组 rets。
                     // rets 数组中的元素是按非递减顺序排列的原数组 nums 元素的平方值。
    }
}


```















### 将数组 nums 中的数平方后直接排序-C++



```C++


class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {


        vector<int> ans;

        for( int num : nums ) {

            ans.push_back( num * num );
        }

        sort( ans.begin() , ans.end() );

        return ans;
        
    }
};



```


















## [力扣209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
已解答
中等

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：

输入：target = 4, nums = [1,4,4]
输出：1

示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^4













### 双指针法之滑动窗口-Java


```Java


class Solution {
    /**
     *  解法：双指针之滑动窗口
     *  总结滑动窗口的步骤:
        1.初始化窗口: 设置 left = 0, right = 0 (或者 right = -1，根据窗口定义调整)，初始化 sum 和 result。
        2.移动右指针 (扩展窗口): 外层循环控制 right 指针的移动，将新元素加入窗口，更新 sum。
        3.判断窗口是否满足条件: 检查当前窗口的 sum 是否满足题目条件 (例如 sum >= s)。
        4.移动左指针 (收缩窗口): 如果窗口满足条件，内层循环控制 left 指针的移动，缩小窗口，同时更新 result (如果需要求最小值)。 在移动 left 的过程中，要保证窗口仍然满足条件。
        5.重复步骤 2-4 直到右指针到达数组末尾: 继续扩展和收缩窗口，寻找所有可能的解。
        6.返回结果: 根据 result 的值判断是否有解，并返回结果。
     * @param target  目标和值
     * @param nums    正整数数组
     * @return      最小子数组的长度，如果不存在则返回 0
     */
    public int minSubArrayLen(int target, int[] nums) {

        int sum = 0;          // 用于记录滑动窗口中元素的和
        int left = 0;         // 滑动窗口的左边界
        int result = Integer.MAX_VALUE; // 存储最小子数组的长度，初始化为最大值，方便后续比较最小值

        // 使用 right 指针遍历数组，扩展滑动窗口的右边界
        for (int right = 0; right < nums.length; right++) {

            sum += nums[right]; // 将右指针当前指向的元素加入滑动窗口的和

            // 当滑动窗口的和 sum 大于等于目标值 target 时，开始收缩窗口
            while (sum >= target) {
                // 找到了一个和大于等于 target 的子数组，更新 result 为当前窗口长度和之前最小长度的较小值
                // right - left + 1 计算的是当前滑动窗口的长度
                result = Math.min(result, right - left + 1);

                // 为了找到更小的满足条件的子数组，尝试缩小滑动窗口的左边界，用于下次while循环的条件判断。
                sum -= nums[left]; // 从 sum 中减去滑动窗口左边界的元素
                left++;          // 左边界右移，缩小窗口
            }
        }

        // 循环结束后，如果 result 仍然是 Integer.MAX_VALUE，说明没有找到满足条件的子数组，返回 0
        // 否则返回找到的最小长度 result
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}


```







### 双指针法之滑动窗口-C++





```C++



class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {


        int left= 0;

        int right=0;

        int sum = 0;

        int subLength = nums.size()+1;

        for( ; right < nums.size(); right++ ) {

            
            sum += nums[right];

            while( sum >= target ) {

                subLength = min( subLength, right - left + 1 );

                
                sum -= nums[left];

                left++;

            }


            


        }



        return subLength <= nums.size() ? subLength : 0;
        

        
    }
};



```






























## [力扣59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/description/)
已解答
中等

给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

 

示例 1：

输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

示例 2：

输入：n = 1
输出：[[1]]
 

提示：

1 <= n <= 20












### 循环不变量原则-Java




```Java

class Solution {
    public int[][] generateMatrix(int n) {
        /**螺旋矩阵的生成可以看作是**逐层填充**的过程。
        我们从最外层开始，按照**顺时针方向**，依次填充矩阵的**上行、右列、下行、左列**。
        每填充完一圈，就向内移动到下一层，重复相同的填充步骤，直到填充完整个矩阵。
        为了精确控制填充的边界和避免重复填充，我们使用**循环不变量原则**，
        即在每一条边的填充循环中，都坚持使用**左闭右开**的区间来定义循环的边界。 
        同时，我们使用**起始坐标 (startX, startY) 和偏移量 (offset)** ,
        来动态调整每一层填充的起始位置和每条边的填充长度，使得填充过程能够一层层向内螺旋进行。
        对于**奇数阶矩阵**，中心位置会单独留空，需要在循环结束后额外填充矩阵的中心点。
        通过这种分层、分边，并结合循环不变量和边界动态调整的策略，
        我们可以有效地生成任意大小的螺旋矩阵。 */

        int[][] matrix = new int[n][n]; // 1. 初始化 n x n 的矩阵，用于存储螺旋矩阵的元素

        int startX = 0;     // 2. 定义每一圈循环的起始行索引 (startX, startY)
        int startY = 0;     // 3. 定义每一圈循环的起始列索引 (startX, startY)
        int offset = 1;     // 4. offset 控制每一圈填充时，每条边遍历的长度。
                            //    每填充一圈，offset 需要增加，使得每条边的结束位置向内收缩。
        int k = 1;          // 5. k 代表当前需要填充的数字，从 1 开始递增，直到 n*n
        int i;              // 6. i 代表行索引，用于循环遍历
        int j;              // 7. j 代表列索引，用于循环遍历

        int loop = 0;       // 8. loop 记录当前的圈数，也用于控制外层循环的次数。
                            //    对于 n x n 的矩阵，需要循环 n/2 圈 (向下取整)。

        while (loop < n / 2) { // 9. 外层循环，控制螺旋矩阵的圈数。每循环一次，填充一圈。

            // 10. 填充上行，从左到右 (行索引固定为 startX，列索引 j 从 startY 开始到 n - offset)
            //    循环不变量：左闭右开区间 [startY, n - offset)
            for (i = startX, j = startY; j < n - offset; j++) {
                matrix[i][j] = k; // 将数字 k 填充到矩阵的 [i][j] 位置
                k++;             // k 自增，准备填充下一个数字
            }

            // 11. 填充右列，从上到下 (列索引固定为 j，行索引 i 从 startX 开始到 n - offset)
            //     循环不变量：左闭右开区间 [startX, n - offset)
            for (; i < n - offset; i++) { // 注意：这里 i 的初始化使用了上一个循环结束后的值
                matrix[i][j] = k;
                k++;
            }

            // 12. 填充下行，从右到左 (行索引固定为 i，列索引 j 从当前 j 开始到 startY，反向填充)
            //     循环不变量：左闭右开区间 (startY, j] -  注意这里是反向，所以是开区间到闭区间
            for (; j > startY; j--) {      // 注意：这里 j 的初始化使用了上一个循环结束后的值，且 j 是递减的
                matrix[i][j] = k;
                k++;
            }

            // 13. 填充左列，从下到上 (列索引固定为 startY，行索引 i 从当前 i 开始到 startX，反向填充)
            //     循环不变量：左闭右开区间 (startX, i] -  注意这里是反向，所以是开区间到闭区间
            for (; i > startX; i--) {      // 注意：这里 i 的初始化使用了上一个循环结束后的值，且 i 是递减的
                matrix[i][j] = k;
                k++;
            }

            loop++; // 14. 完成一圈填充后，圈数 loop 增加，准备开始填充下一圈

            // 15. 更新下一圈的起始位置 (startX, startY) 和 offset

            // startX = i;
            // startY = j+1;
            /* my error
            这里的问题在于，你将循环变量 i 和 j 的值直接赋给了 startX 和 startY。
            startX = i;: 在完成 左列 的填充后，i 的值会递减到 startX 的初始值。 因此，startX = i; 实际上是将 startX 设置为了它自己 当前 的值，而不是在每一圈结束后 递增 它，以移动到下一圈的起始行。
            startY = j+1;: 在完成 左列 的填充后，j 的值保持不变（始终是 startY 的初始值），所以 startY = j+1; 实际上是将 startY 设置为了 startY + 1。 虽然 startY 递增了，但是 startX 没有正确递增，导致起始点在行方向上没有正确下移。
            */


            startX++; // 行起始索引增加，向下移动一行
            startY++; // 列起始索引增加，向右移动一列
            /**正确的更新方式：在每一圈循环结束后，你需要将 startX 和 startY 都 递增 1，同时 offset 也需要递增，才能正确地移动到下一圈的起始位置，并调整每条边的填充长度。 */

            offset++; // offset 增加，使得下一圈每条边的结束位置都向内收缩
                      // offset 的增加保证了每圈填充的长度逐渐减小，符合螺旋规律。
        }

        // 16. 处理 n 为奇数的情况，矩阵中心会留有一个空位，需要单独填充
        if (n % 2 != 0) {
            // n为奇数时，矩阵中心单点需要单独填充
            // 矩阵中心的坐标为 (n-1)/2, (n-1)/2  (例如 n=3 时，中心坐标为 (1,1))
            matrix[(n - 1) / 2][(n - 1) / 2] = n * n; // 将 n*n 填充到矩阵中心
        }

        return matrix; // 17. 返回生成的螺旋矩阵
    }
}


```












## 





















































## 
































## 






































# 链表





## [力扣203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)
已解答
简单

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
 

示例 1：


输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
示例 2：

输入：head = [], val = 1
输出：[]
示例 3：

输入：head = [7,7,7,7], val = 7
输出：[]
 

提示：

- 列表中的节点数目在范围 [0, 10^4] 内
- 1 <= Node.val <= 50
- 0 <= val <= 50
















### 设置一个虚拟头结点再进行移除节点操作-C++






```C++


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {

        struct ListNode* dummyHead = new ListNode(0,head);
        /*
        struct ListNode：这是定义链表节点的结构体类型。
        *dummyHead：这表示我们正在创建一个 ListNode 类型的指针，命名为 dummyHead。
        new：C++ 的内存分配操作符，用于在堆上动态创建对象。
        new ListNode(0, head)：使用 new 操作符创建一个新的 ListNode 实例，
        使用两个参数调用其构造函数：第一个参数 0 用于初始化节点的 val 成员，
        第二个参数 head 用于初始化节点的 next 成员，即 dummyHead->next = head.
        使用哑节点 dummyHead 作为遍历的起始点，可以简化删除头节点的逻辑。
        因为如果 head 需要被删除，你只需要更新哑节点的 next 指针，而不需要单独处理头节点的特殊情况。
        */

        struct ListNode* index = dummyHead;
        /* 
        由于 dummyHead->next = head，故下面的while循环中， index->next 初始指向 head。
         而我原本的错误写法 ListNode* index = head中，下面的while循环中 ，index->next 初始指向head->next,错过了遍历头结点
        */
        while( index->next != NULL )
        {// 遍历链表，直到index指向的节点的next为NULL

            if(  index->next->val == val)
            {// 如果当前节点的值等于val，则删除当前节点

                index->next = index->next->next;
                // 跳过当前节点的next指针指向下一个节点的next，
                // 这样当前节点就会被删除，因为没有任何指针指向它

            }
            else
            {// 如果当前节点的值不等于val

                index = index->next;
                // 将index指针移动到下一个节点
            }



        }

        return dummyHead->next;
        // 由于哑节点的val始终为0，我们返回哑节点的next，即原链表的头节点或新的头节点

    }
};




```










### 设置一个虚拟头结点再进行移除节点操作-Java







```Java


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {

        // 创建一个虚拟头节点 (dummy node)。
        // 虚拟头节点的next指针指向链表的头节点 head。
        // 这样做的好处是，即使头节点需要被删除，我们也不需要特殊处理，
        // 因为我们总是从 dummyNode 的 next 开始操作。
        ListNode dummyNode = new ListNode( 0, head );

        // 定义一个指针 cur，用于遍历链表并进行删除操作。
        // 初始化 cur 指向 dummyNode。
        ListNode cur = dummyNode;

        // 循环遍历链表，直到 cur 的下一个节点为空 (即 cur 到达链表尾部)。
        while( cur.next != null ) {

            // 检查 cur 的下一个节点 (cur.next) 的值是否等于给定的值 val。
            if( cur.next.val == val ) {
                // 如果 cur.next 节点的值等于 val，则需要删除 cur.next 节点。

                // 删除操作：将 cur 的 next 指针 指向 cur.next 的 next 指针。
                // 效果：跳过了 cur.next 节点，相当于从链表中移除了 cur.next 节点。
                //      此时 cur 仍然指向原来的位置，保持不变，以便继续检查新的 cur.next 是否也需要删除。
                cur.next = cur.next.next;


            }
            else {
                // 如果 cur.next 节点的值不等于 val，则不需要删除 cur.next 节点。

                // 将 cur 指针向后移动一位，即移动到 cur.next 节点，
                // 继续向后遍历链表，检查下一个节点。
                cur = cur.next;
            }

            //cur = cur.next;
            /**错误分析：
            当你在 if( cur.next.val == val ) 块中执行了 cur.next = cur.next.next; 进行删除操作后，cur.next 的指向已经发生了改变，它可能指向了链表中的下一个有效节点，或者可能变成了 null (如果 cur.next 原本指向的是链表的最后一个节点，那么删除后 cur.next 就变成了 null)。
            关键问题是，即使你删除了一个节点，你仍然无条件地执行了 cur = cur.next;。 这意味着，在某些情况下，cur 可能会跳过一些节点，或者更糟糕的是，当你在删除操作后 cur.next 已经变成 null 时，你仍然尝试将 cur 移动到 cur.next， 这就会导致 cur 变成 null， 并且在下一次循环迭代时，尝试访问 cur.next 时就会发生 NullPointerException。
            修正方案：
            你只需要在 没有执行删除操作 的情况下才移动 cur 指针。也就是说，只有当 cur.next.val != val 时，你才应该执行 cur = cur.next;。 当执行了删除操作 cur.next = cur.next.next; 后，你不需要移动 cur 指针，因为你需要 再次检查 当前 cur 指针的 next 节点（因为新的 cur.next 可能是需要删除的节点）。*/



        }

        // 循环结束后，所有值为 val 的节点都已被删除。
        // 返回 dummyNode.next，即新的链表的头节点。
        // 注意：即使原始头节点被删除了，dummyNode.next 也会指向新的头节点 (或者 null 如果链表为空)。
        return dummyNode.next;


    }
}



```







## [力扣707. 设计链表](https://leetcode.cn/problems/design-linked-list/description/)
已解答
中等

你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。

实现 MyLinkedList 类：

- MyLinkedList() 初始化 MyLinkedList 对象。
- int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。
- void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
- void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。
- void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。
 

示例：

输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
 

提示：

0 <= index, val <= 1000
请不要使用内置的 LinkedList 库。
调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。








### Java-无注释





```Java



class MyLinkedList {
    
    class ListNode {

        int val;
        ListNode next;

        ListNode(int val) {

            this.val = val;

        }

    }

    ListNode head;
    int size;

    public MyLinkedList() {

        head = null;
        size = 0;
        
    }
    
    public int get(int index) {
        
        if( head == null || index < 0 || index >= size ) {
            /**如果链表为空，或者给出的下标超出链表有效范围，则判断下标无效，直接返回-1 */
            return -1;

        }

        ListNode cur = head;

        for( int i=0; i < index; i++ ) {

            cur = cur.next;

        }

        if( cur != null ) {

            return cur.val;

        }
        else{

            return -1;
        }

        


    }
    
    public void addAtHead(int val) {


        ListNode newHead = new ListNode(val);

        newHead.next = head;

        head = newHead;
        size++;

    }
    
    public void addAtTail(int val) {
        /**
        错误原因: 在 addAtTail 方法中，当链表为空时，cur 指针被初始化为 null，导致在 while(cur.next != null) 条件判断中访问 cur.next 发生 NullPointerException。
        修正方案: 在 addAtTail 方法中，首先判断链表是否为空 (head == null)。如果为空，则将新节点直接设置为链表的头节点 (head = newNode)。 如果链表不为空，则按照原来的逻辑遍历到链表末尾并添加新节点。
         */

        ListNode newNode = new ListNode(val);

        if( head == null ) {

            head = newNode;
        }
        else {

            ListNode cur = head;

            while( cur.next != null ) {

                cur = cur.next;

            }

            cur.next = newNode;
            
        }
        
        size++;


    }
    
    public void addAtIndex(int index, int val) {


        if( index == 0 ) {

            addAtHead(val);
            // size++;多余了，因为addAtHead中已包含size++

        }
        else if( index == size ) {


            addAtTail(val);
            // size++;多余了，因为addAtTail中已包含size++

        }
        else if( index > 0 && index < size ){


            ListNode cur = head;

            for( int i=0; i < index-1; i++ ) {

                cur = cur.next;

            }


            ListNode newNode = new ListNode(val);

            newNode.next = cur.next;

            cur.next = newNode;

            size++;
            
        }

    }
    
    public void deleteAtIndex(int index) {
        /**
        代码错误原因总结：你的 deleteAtIndex 方法没有正确处理“删除索引为 0 的节点，并且链表本身就是空”的情况。 当链表为空 (head == null) 时，尝试访问 head.next 会导致 NullPointerException。
        修正方案：在 deleteAtIndex 方法中，你需要在一开始就判断链表是否为空，并且判断给定的 index 是否有效。 对于删除索引为 0 的情况，如果链表为空，则不需要进行任何操作，直接返回即可。
        */

        if( head == null || index < 0 || index >= size ) {
            /**修改说明：
            添加 head == null 判断: 在 deleteAtIndex 方法的开始处，添加了 if (head == null || index < 0 || index >= size) 判断条件。
            空链表直接返回: 如果 head == null (链表为空)，或者 index 超出有效范围，则直接 return; 结束方法，不做任何删除操作。 这样就避免了在空链表时访问 head.next 导致的 NullPointerException。 */

            return;
        }


        if( index == 0 ) {

            head = head.next;

            size--;

        }
        else if( index > 0 && index < size ){


            ListNode cur = head;

            for( int i=0; i < index-1; i++ ) {

                cur = cur.next;

            }

            cur.next = cur.next.next;

            size--;
            
        }

        
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */




```










### Java-注释版




```Java




class MyLinkedList {
    /**This题目 **“设计链表”** 的核心目标是让你**从零开始构建一个自定义的链表数据结构**。你需要自己实现链表的基本操作，就像 Java 标准库中的 `LinkedList` 那样，但这次你需要自己动手完成底层细节。
    **解题思路可以分解为以下几个关键步骤和设计思想：**
    1.  **选择链表类型：单链表 vs 双链表**
        题目允许你选择单链表或双链表。  **单链表** 因为结构相对简单，更容易实现，通常是首选，尤其是在练习链表基础操作时。  双链表虽然操作上更灵活（例如可以方便地向前遍历），但实现稍微复杂一些。  示例代码选择了**单链表**，因为它已经足够满足题目所有功能需求，并且更简洁。
    2.  **设计链表节点 (`ListNode` 类)**
        无论单链表还是双链表，节点都是链表的基本组成单元。 你需要定义一个 `ListNode` 类来表示链表中的节点。
        *   **单链表节点 (`ListNode`):**
            *   **`val` (int):** 存储节点本身的数据值。题目要求是整数类型。
            *   **`next` (ListNode):** 指向链表中的下一个节点的指针（引用）。  对于单链表的最后一个节点，`next` 通常设置为 `null`。

        *   **双链表节点 (如果选择双链表):**
            *   除了 `val` 和 `next`，双链表节点还需要一个
            *   **`prev` (ListNode):** 指向上一个节点的指针（引用）。 对于双链表的第一个节点，`prev` 通常设置为 `null`。

        示例代码中，`ListNode` 类只包含了 `val` 和 `next`，因为选择的是**单链表**。

    3.  **设计 `MyLinkedList` 类 (链表类)**
        `MyLinkedList` 类是用来管理整个链表的，它需要包含以下关键部分：
        *   **`head` (ListNode):**  **头节点指针**。  `head` 指向链表的第一个节点。  如果链表为空，`head` 为 `null`。  `head` 是链表的入口，所有对链表的操作通常都从 `head` 开始。
        *   **`size` (int):**  **链表长度**。  `size` 记录链表中节点的数量。  维护 `size` 的目的是为了方便进行**索引有效性检查**，例如在 `get(index)`、`deleteAtIndex(index)` 等操作中，可以快速判断给定的索引是否超出链表范围。
        *   **构造函数 (`MyLinkedList()`):**  **初始化空链表**。  在构造函数中，将 `head` 设置为 `null`，`size` 设置为 `0`，表示创建一个空的链表。

    4.  **实现链表操作方法 (核心功能)**
        你需要实现题目要求的以下几个核心操作方法。  每个方法的实现都需要考虑链表的特性和边界情况。
        *   **`get(int index)`: 获取指定索引节点的值**
            *   **索引有效性检查:**  首先要检查 `index` 是否有效，即 `index` 是否在 `0` 到 `size - 1` 的范围内。 如果无效，直接返回 `-1`。
            *   **链表为空检查:**  如果链表为空 (`head == null`)，也应该返回 `-1`。
            *   **遍历链表:**  从 `head` 开始，使用一个临时指针 `cur` 遍历链表，移动 `index` 次 `next` 指针，直到 `cur` 指向目标索引的节点。
            *   **返回值:**  返回 `cur` 指向节点的 `val` 值。

        *   **`addAtHead(int val)`: 在链表头部添加节点**
            *   **创建新节点:**  创建一个新的 `ListNode` 对象，值为 `val`。
            *   **连接新节点:**  将新节点的 `next` 指针指向当前的 `head` 节点。
            *   **更新 `head` 指针:**  将 `head` 指针更新为指向新节点，使其成为新的头节点。
            *   **更新 `size`:**  链表长度 `size` 加 1。

        *   **`addAtTail(int val)`: 在链表尾部添加节点**
            *   **创建新节点:**  创建一个新的 `ListNode` 对象，值为 `val`。
            *   **处理空链表情况:**  如果链表为空 (`head == null`)，则新节点直接成为 `head`。
            *   **遍历到尾节点:**  如果链表非空，从 `head` 开始遍历，找到链表的最后一个节点 (即 `next` 指针为 `null` 的节点)。
            *   **连接新节点:**  将尾节点的 `next` 指针指向新创建的节点。
            *   **更新 `size`:**  链表长度 `size` 加 1.

        *   **`addAtIndex(int index, int val)`: 在指定索引位置之前添加节点**
            *   **索引有效性检查:**  检查 `index` 是否有效，即 `index` 是否在 `0` 到 `size` 的范围内。  注意 `index == size` 是允许的，表示在尾部追加。  如果 `index` 无效，不进行任何操作。
            *   **处理头部插入情况 (`index == 0`):**  直接调用 `addAtHead(val)`。
            *   **处理尾部追加情况 (`index == size`):**  直接调用 `addAtTail(val)`。
            *   **在中间位置插入:**
                *   **遍历到插入位置的前一个节点:** 从 `head` 开始遍历，找到索引为 `index - 1` 的节点。
                *   **连接新节点:**  将新节点的 `next` 指针指向插入位置的后继节点 (即原来索引为 `index` 的节点)。  将前一个节点的 `next` 指针指向新节点。
            *   **更新 `size`:**  链表长度 `size` 加 1。

        *   **`deleteAtIndex(int index)`: 删除指定索引位置的节点**
            *   **索引有效性检查:**  检查 `index` 是否有效，即 `index` 是否在 `0` 到 `size - 1` 的范围内。 并且要检查链表是否为空 (`head == null`)。 如果无效或链表为空，不进行任何操作。
            *   **处理删除头节点情况 (`index == 0`):**  将 `head` 指针直接指向原来的第二个节点 (`head.next`)。
            *   **删除中间位置节点:**
                *   **遍历到删除位置的前一个节点:** 从 `head` 开始遍历，找到索引为 `index - 1` 的节点。
                *   **跳过要删除的节点:**  将前一个节点的 `next` 指针指向要删除节点的下一个节点 (`current.next = current.next.next`)。
            *   **更新 `size`:**  链表长度 `size` 减 1。

    5.  **边界情况和错误处理**
        在实现链表操作时，要特别注意以下边界情况和错误处理：
        *   **空链表 (`head == null`):**  在 `get`, `addAtTail`, `deleteAtIndex` 等方法中，都需要考虑链表为空的情况，并进行特殊处理，避免空指针异常。
        *   **索引越界 (`index < 0` 或 `index >= size`，或 `index > size`):**  在 `get`, `addAtIndex`, `deleteAtIndex` 等方法中，要进行索引有效性检查，确保索引在合法范围内。  超出范围的操作应该被忽略或返回错误值。
        *   **删除头节点 (`index == 0` in `deleteAtIndex`):**  删除头节点需要特殊处理，因为需要更新 `head` 指针。
        *   **添加到链表末尾 (`index == size` in `addAtIndex`):**  添加到链表末尾可以复用 `addAtTail` 的逻辑。

    6.  **代码注释和可读性**
        为了方便理解和维护代码，应该添加清晰的注释，解释每个方法和关键代码段的逻辑。  代码应该保持良好的缩进和命名习惯，提高可读性。  示例代码就包含了非常详细的注释，有助于理解每个步骤的目的。
    **总结来说，解决“设计链表”题目的关键在于：**
    *   **理解链表的基本概念和操作原理** (插入、删除、遍历等)。
    *   **选择合适的数据结构 (单链表或双链表)**，并定义节点类。
    *   **实现 `MyLinkedList` 类，包含 `head` 和 `size` 等必要成员变量。**
    *   **仔细实现每个操作方法 (`get`, `addAtHead`, `addAtTail`, `addAtIndex`, `deleteAtIndex`)，并处理好各种边界情况和错误。**
    *   **编写清晰的代码注释，提高代码可读性和可维护性。**
    通过以上步骤，你就可以成功地设计并实现自己的链表数据结构。  不断练习链表相关的题目，可以帮助你更深入地理解链表的特性和应用。 
    */

    /**
     * 内部类 ListNode，用于表示链表中的节点。
     */
    class ListNode {
        int val;     // 节点存储的值
        ListNode next; // 指向下一个节点的指针

        /**
         * ListNode 构造函数，创建一个新的节点。
         * @param val 节点的值
         */
        ListNode(int val) {
            this.val = val;
        }
    }

    ListNode head; // 链表的头节点，指向链表的第一个节点。如果链表为空，则为 null。
    int size;      // 链表的长度，即链表中节点的个数。

    /**
     * MyLinkedList 构造函数，初始化一个空的链表。
     * 初始化头节点 head 为 null，链表大小 size 为 0。
     */
    public MyLinkedList() {
        head = null; // 初始化时，链表为空，头节点为 null
        size = 0;    // 初始化时，链表长度为 0
    }

    /**
     * get(int index) 方法：获取链表中下标为 index 的节点的值。
     * 如果下标无效（小于 0 或大于等于链表长度），则返回 -1。
     * @param index 要获取的节点的下标 (从 0 开始)
     * @return 链表中下标为 index 的节点的值，如果下标无效则返回 -1
     */
    public int get(int index) {
        if( head == null || index < 0 || index >= size ) {
            /**如果链表为空 (head == null)，或者给出的下标超出链表有效范围 (index < 0 或 index >= size)，
             * 则判断下标无效，直接返回 -1。
             */
            return -1;
        }

        ListNode cur = head; // 创建一个临时指针 cur，指向链表的头节点，用于遍历链表。

        for( int i=0; i < index; i++ ) {
            /**循环遍历链表，移动 cur 指针到指定的 index 位置。
             * 循环 i 从 0 到 index - 1，每次循环将 cur 指针移动到下一个节点 (cur = cur.next)。
             * 循环结束后，cur 指针将指向链表中下标为 index 的节点。
             */
            cur = cur.next;
        }

        if( cur != null ) {
            /** 再次检查 cur 是否为空，虽然在前面的 index 检查中已经排除了无效索引，
             *  但为了代码的健壮性，这里再次判断 cur 是否为空 (理论上在有效 index 范围内不应该为空)。
             *  如果 cur 不为空，则返回 cur 节点的值 (cur.val)。
             */
            return cur.val;
        }
        else{
            /** 如果 cur 为空（这种情况在正常逻辑下不应该发生，除非链表在遍历过程中被意外修改），
             *  则返回 -1，表示获取节点值失败。
             */
            return -1;
        }
    }

    /**
     * addAtHead(int val) 方法：将一个值为 val 的节点插入到链表头部。
     * 插入后，新节点成为链表的第一个节点。
     * @param val 要插入的节点的值
     */
    public void addAtHead(int val) {
        ListNode newHead = new ListNode(val); // 创建一个新的 ListNode 对象，值为 val，作为新的头节点。

        newHead.next = head; // 将新节点的 next 指针指向当前的头节点 head。
                             // 如果 head 原本为 null（空链表），则 newHead.next 也为 null。

        head = newHead;      // 将链表的头节点 head 更新为 newHead，新节点成为链表的第一个节点。
        size++;             // 链表长度 size 加 1，因为添加了一个新的节点。
    }

    /**
     * addAtTail(int val) 方法：将一个值为 val 的节点追加到链表的末尾。
     * 新节点成为链表的最后一个节点。
     * @param val 要追加的节点的值
     */
    public void addAtTail(int val) {
        /**
         错误原因: 在 addAtTail 方法中，当链表为空时，cur 指针被初始化为 null，导致在 while(cur.next != null) 条件判断中访问 cur.next 发生 NullPointerException。
         修正方案: 在 addAtTail 方法中，首先判断链表是否为空 (head == null)。如果为空，则将新节点直接设置为链表的头节点 (head = newNode)。 如果链表不为空，则按照原来的逻辑遍历到链表末尾并添加新节点。
         */
        ListNode newNode = new ListNode(val); // 创建一个新的 ListNode 对象，值为 val，用于添加到链表末尾。

        if( head == null ) {
            /** 如果链表为空 (head == null)，则新节点 newNode 将成为链表的头节点。 */
            head = newNode; // 将 head 直接指向新节点 newNode，newNode 成为链表的头节点。
        }
        else {
            /** 如果链表不为空，则需要找到链表的最后一个节点，并将新节点追加到最后一个节点之后。 */
            ListNode cur = head; // 创建一个临时指针 cur，指向链表的头节点，用于遍历链表找到最后一个节点。

            while( cur.next != null ) {
                /** 循环遍历链表，直到 cur 指向最后一个节点。
                 * 循环条件 cur.next != null 确保循环结束时，cur 指向的是 next 指针为 null 的节点，即最后一个节点。
                 */
                cur = cur.next; // 将 cur 指针移动到下一个节点。
            }

            cur.next = newNode; // 当循环结束时，cur 指向最后一个节点，将最后一个节点 cur 的 next 指针指向新节点 newNode，完成尾部追加。
        }

        size++; // 链表长度 size 加 1，因为添加了一个新的节点。
    }

    /**
     * addAtIndex(int index, int val) 方法：将值为 val 的节点插入到链表中下标为 index 的节点之前。
     * - 如果 index 等于链表的长度，那么该节点会被追加到链表的末尾 (相当于 addAtTail)。
     * - 如果 index 比链表长度更大，该节点将 不会插入 到链表中。
     * - 如果 index 小于 0，节点将插入到链表头部 (相当于 addAtHead)。
     * @param index 要插入的位置的下标 (从 0 开始)
     * @param val 要插入的节点的值
     */
    public void addAtIndex(int index, int val) {
        if( index < 0 || index > size ) {
            /** 检查 index 是否有效。
             *  如果 index 小于 0 或大于链表长度 size，则 index 无效，不进行任何插入操作，直接返回。
             *  注意：index 等于 size 是有效的，表示在链表末尾追加。
             */
            return; // index 无效，直接返回，不插入节点。
        }

        if( index == 0 ) {
            /** 如果 index 为 0，则在链表头部插入节点，相当于调用 addAtHead 方法。 */
            addAtHead(val);
            // size++; // size 增加已经在 addAtHead 方法中处理，此处不需要重复增加 size。
        }
        else if( index == size ) {
            /** 如果 index 等于链表长度 size，则在链表尾部追加节点，相当于调用 addAtTail 方法。 */
            addAtTail(val);
            // size++; // size 增加已经在 addAtTail 方法中处理，此处不需要重复增加 size。
        }
        else if( index > 0 && index < size ){
            /** 如果 index 大于 0 且小于链表长度 size，则在链表中间位置插入节点。 */
            ListNode cur = head; // 创建一个临时指针 cur，指向链表的头节点，用于遍历链表找到插入位置的前一个节点。

            for( int i=0; i < index-1; i++ ) {
                /** 循环遍历链表，移动 cur 指针到要插入位置的前一个节点 (index - 1)。
                 * 循环 i 从 0 到 index - 2，每次循环将 cur 指针移动到下一个节点 (cur = cur.next)。
                 * 循环结束后，cur 指针将指向链表中下标为 index - 1 的节点，即要插入位置的前一个节点。
                 */
                cur = cur.next;
            }

            ListNode newNode = new ListNode(val); // 创建一个新的 ListNode 对象，值为 val，用于插入到指定位置。

            newNode.next = cur.next; // 将新节点 newNode 的 next 指针指向当前 cur 节点的 next 指针所指向的节点。
                                     // 也就是将新节点链接到插入位置的后继节点。
            cur.next = newNode;     // 将当前节点 cur 的 next 指针指向新节点 newNode。
                                     // 也就是将新节点链接到插入位置的前驱节点，完成插入操作。

            size++; // 链表长度 size 加 1，因为添加了一个新的节点。
        }
    }

    /**
     * deleteAtIndex(int index) 方法：删除链表中下标为 index 的节点。
     * 如果下标无效（小于 0 或大于等于链表长度），则不进行任何操作。
     * @param index 要删除的节点的下标 (从 0 开始)
     */
    public void deleteAtIndex(int index) {
        /**
         代码错误原因总结：你的 deleteAtIndex 方法没有正确处理“删除索引为 0 的节点，并且链表本身就是空”的情况。 当链表为空 (head == null) 时，尝试访问 head.next 会导致 NullPointerException。
         修正方案：在 deleteAtIndex 方法中，你需要在一开始就判断链表是否为空，并且判断给定的 index 是否有效。 对于删除索引为 0 的情况，如果链表为空，则不需要进行任何操作，直接返回即可。
         */
        if( head == null || index < 0 || index >= size ) {
            /**
             修改说明：
             添加 head == null 判断: 在 deleteAtIndex 方法的开始处，添加了 if (head == null || index < 0 || index >= size) 判断条件。
             空链表直接返回: 如果 head == null (链表为空)，或者 index 超出有效范围，则直接 return; 结束方法，不做任何删除操作。 这样就避免了在空链表时访问 head.next 导致的 NullPointerException。
             */
            return; // 链表为空或 index 无效，直接返回，不进行删除操作。
        }

        if( index == 0 ) {
            /** 如果 index 为 0，则删除链表的头节点。 */
            head = head.next; // 将链表的头节点 head 指向当前头节点的下一个节点。
                             // 如果原链表只有一个节点，head.next 将为 null，head 将变为 null，链表变为空链表。
                             // 如果原链表为空链表 (head == null)，则在方法开始处的判断已经处理，不会执行到此处。

            size--; // 链表长度 size 减 1，因为删除了一个节点。
        }
        else if( index > 0 && index < size ){
            /** 如果 index 大于 0 且小于链表长度 size，则删除链表中间位置的节点。 */
            ListNode cur = head; // 创建一个临时指针 cur，指向链表的头节点，用于遍历链表找到要删除节点的前一个节点。

            for( int i=0; i < index-1; i++ ) {
                /** 循环遍历链表，移动 cur 指针到要删除节点的前一个节点 (index - 1)。
                 * 循环 i 从 0 到 index - 2，每次循环将 cur 指针移动到下一个节点 (cur = cur.next)。
                 * 循环结束后，cur 指针将指向链表中下标为 index - 1 的节点，即要删除节点的前一个节点。
                 */
                cur = cur.next;
            }

            cur.next = cur.next.next; // 将当前节点 cur 的 next 指针 指向 cur.next 的 next 指针。
                                     // 也就是跳过 cur.next 节点，将 cur 节点直接链接到 cur.next 的下一个节点。
                                     // 从而实现删除 cur.next 节点的效果。

            size--; // 链表长度 size 减 1，因为删除了一个节点。
        }
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */




```


































## [力扣206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
已解答
简单

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 

示例 1：


输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]


示例 2：


输入：head = [1,2]
输出：[2,1]


示例 3：

输入：head = []
输出：[]
 

提示：

- 链表中节点的数目范围是 [0, 5000]
- -5000 <= Node.val <= 5000













### 双指针法-Java-无注释版









```Java



/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 双指针法

        if( head == null ) {

            return null;
        }

        ListNode pre = new ListNode() ;

        pre =null;

        ListNode cur = head;
        ListNode temp = new ListNode();

        while( cur.next != null ) {

            temp = cur.next;

            cur.next = pre;

            pre = cur;

            cur = temp;


        }


        cur.next = pre;

        pre = cur;



        return pre;


    }
}


```










### 双指针法-Java-注释优化版 








```Java



/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 双指针法 (Iterative approach using two pointers: pre and cur)

        if( head == null ) {
            // 如果链表为空，则直接返回 null，空链表反转后仍然是空链表
            return null;
        }

        ListNode pre = new ListNode() ; // 初始化前一个指针 pre
        // ListNode pre = null;  // 也可以直接初始化为 null,  ListNode() 默认 val = 0, next = null;  这里使用 ListNode()  或者 null 都可以。

        pre =null; // 初始化 pre 指针为 null，在反转的过程中，pre 将指向 cur 的前一个节点，初始时，第一个节点的前一个节点为 null

        ListNode cur = head; // 初始化当前指针 cur，指向链表的头节点，cur 指针用于遍历链表
        ListNode temp = new ListNode(); // 初始化临时节点 temp，用于在反转时保存 cur 的下一个节点，避免链表断开

        while( cur != null ) { // 修改循环条件为 cur != null， 遍历到链表末尾
        // while( cur.next != null ) { // 原来的循环条件是 cur.next != null，会导致最后一个节点无法反转，循环在倒数第二个节点结束

            temp = cur.next; // 步骤一：保存 cur 的下一个节点到 temp，因为 cur.next 指针即将反转指向前一个节点，需要先保存

            cur.next = pre; // 步骤二：反转 cur 的 next 指针，让它指向 pre，实现当前节点指向前一个节点的反转

            pre = cur; // 步骤三：pre 指针后移，移动到 cur 的位置，为下一次循环做准备，pre 始终指向 cur 的前一个节点（反转后是后一个节点）

            cur = temp; // 步骤四：cur 指针后移，移动到 temp 的位置，即原来的 cur.next 的位置，继续遍历下一个节点

            if (cur == null){ // 增加判断条件，当 cur 为空时，跳出循环，避免 NullPointerException， 同时也避免了原代码在 while( cur.next != null ) 循环条件下，最后一个节点无法反转的问题。
                break;
            }


        }


        // cur.next = pre; //  这行代码是多余的，while 循环条件修改为 cur != null 之后，不需要再在循环外执行 cur.next = pre;

        // pre = cur;  // 这行代码也是多余的， while 循环结束后，pre 已经指向反转后的头节点，不需要再赋值 pre = cur;  且此时 cur 已经为 null

        // while 循环结束后，pre 指针指向原链表的最后一个节点，也就是反转后链表的头节点
        return pre; // 返回 pre，pre 指向反转后链表的头节点


    }
}




```










### 双指针法-C++ 



```C++


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {


        ListNode* pre = nullptr;

        ListNode* cur = head;


        while( cur ) {

            ListNode* nxt = cur->next;

            cur->next = pre;

            pre = cur;

            cur = nxt;

        }

        return pre;
        
    }
};


```












## [力扣24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
已解答
中等

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

示例 1：

输入：head = [1,2,3,4]
输出：[2,1,4,3]

示例 2：

输入：head = []
输出：[]

示例 3：

输入：head = [1]
输出：[1]
 

提示：

链表中节点的数目在范围 [0, 100] 内
0 <= Node.val <= 100












### Java-无注释





```Java


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {




        ListNode dummyNode = new ListNode();

        dummyNode.next = head;

        ListNode cur = dummyNode;

        ListNode temp1 = new ListNode();

        ListNode temp2 = new ListNode();

        if( cur.next == null || cur.next.next == null ) {

            return head;
        }


        while( cur.next != null && cur.next.next != null ) {
            /**问题出现在循环体内部的 指针移动 和 节点交换 的逻辑上。让我们逐步分析：
            temp1 = cur.next;: temp1 指向当前要交换的第一个节点（假设存在）。
            temp2 = cur.next.next.next;: 错误发生处。 这里尝试获取当前要交换的第二个节点的下一个节点。
            如果当前 cur 后面恰好只有两个节点，那么 cur.next.next 将是链表的最后一个节点，它的 next 指针将是 null。
            比如初始链表为[1,2,3,4]时，执行一次循环后变为[2,1,3,4],cur指向1的位置，再执行一次循环后变为[2,1,4,3],cur指向3的位置。
            此时cur.next为null，cur.next.next会导致 NullPointerException。因此每次开启循环前不仅要判断cur.next.next是否不为空，还需要同时判断cur.next是否不为空。
             */



            temp1 = cur.next;

            temp2 = cur.next.next.next;



            cur.next = cur.next.next;

            cur.next.next = temp1;

            cur = cur.next.next;

            cur.next = temp2;


        }


        return dummyNode.next;
        
    }
}


```








### Java-注释版








```Java


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {

        // 创建一个虚拟头节点 dummyNode，用于简化头节点操作
        ListNode dummyNode = new ListNode();

        // 将 dummyNode 的 next 指针指向链表头节点 head
        dummyNode.next = head;

        // 初始化 cur 指针指向 dummyNode，cur 指针用于遍历链表并进行交换操作
        ListNode cur = dummyNode;

        // 创建临时节点 temp1 和 temp2，用于在交换过程中辅助指针操作
        ListNode temp1 = new ListNode();
        ListNode temp2 = new ListNode();

        // 考虑链表为空或只有一个节点的情况，此时无需交换，直接返回原链表头节点
        if( cur.next == null || cur.next.next == null ) {
            // 如果 dummyNode 的下一个节点为空 (链表为空) 或下下个节点为空 (链表只有一个节点)，则无需交换
            return head; // 直接返回原始头节点 head
        }

        // 循环条件：cur 的 next 指针和 cur 的 next 的 next 指针都不为空，
        // 保证 cur 后面至少有两个节点，才能进行两两交换
        while( cur.next != null && cur.next.next != null ) {
            /**问题出现在循环体内部的 指针移动 和 节点交换 的逻辑上。让我们逐步分析：
            temp1 = cur.next;: temp1 指向当前要交换的第一个节点（假设存在）。
            temp2 = cur.next.next.next;: 错误发生处。 这里尝试获取当前要交换的第二个节点的下一个节点。
            如果当前 cur 后面恰好只有两个节点，那么 cur.next.next 将是链表的最后一个节点，它的 next 指针将是 null。
            比如初始链表为[1,2,3,4]时，执行一次循环后变为[2,1,3,4],cur指向1的位置，
            再执行一次循环后变为[2,1,4,3],cur指向3的位置。
            此时cur.next为null，cur.next.next会导致 NullPointerException。
            因此每次开启循环前不仅要判断cur.next.next是否不为空，还需要同时判断cur.next是否不为空。
             */

            // temp1 指向 cur 的下一个节点，即待交换的第一个节点
            temp1 = cur.next;

            // temp2 指向 cur 的下下个节点的下一个节点，即待交换的第二个节点之后的节点
            // 这里是可能出现 NullPointerException 的地方，如果链表剩余节点不足三个，则 cur.next.next.next 可能为空
            temp2 = cur.next.next.next;

            // 将 cur 的 next 指针指向 cur 的下下个节点，即实现了 cur 指向了待交换的第二个节点
            cur.next = cur.next.next;

            // 将 cur 的 next (此时是第二个节点) 的 next 指针指向 temp1 (即原来的第一个节点)，完成第一个节点的后移
            cur.next.next = temp1;

            // cur 指针向前移动两位，指向交换后的第一对节点的末尾，准备进行下一对节点的交换
            cur = cur.next.next;

            // 将 cur 的 next 指针指向 temp2，连接交换后的节点对与后续链表
            cur.next = temp2;


        }

        // 循环结束后，返回 dummyNode 的 next，即交换后的链表头节点
        return dummyNode.next;

    }
}



```















## 
































## 







































































# 




## 
































## 
































## 
































## 
































## 
































## 
































## 
































## 






















































































# 字符串







## 415. 字符串相加
简单

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

 

示例 1：

输入：num1 = "11", num2 = "123"
输出："134"

示例 2：

输入：num1 = "456", num2 = "77"
输出："533"

示例 3：

输入：num1 = "0", num2 = "0"
输出："0"
 

提示：

1 <= num1.length, num2.length <= 10^4
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零








### 力扣官方题解


```JAVA

class Solution {
    public String addStrings(String num1, String num2) {
        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        StringBuffer ans = new StringBuffer();
        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? num1.charAt(i) - '0' : 0;
            int y = j >= 0 ? num2.charAt(j) - '0' : 0;
            int result = x + y + add;
            ans.append(result % 10);
            add = result / 10;
            i--;
            j--;
        }
        // 计算完以后的答案需要翻转过来
        ans.reverse();
        return ans.toString();
    }
}


```









### 官方题解学习解读

结合示例详细具体地讲解该题目

好的，我们来结合示例详细讲解一下 LeetCode 415 "字符串相加" 这道题及其 Java 解法。

**题目解析**

这道题要求我们计算两个以字符串形式表示的非负整数的和，并同样以字符串形式返回结果。关键限制是：

1.  **不能使用内置的大整数库** (如 Java 的 `BigInteger`)。
2.  **不能直接将输入字符串转换为整数类型** (如 `Integer.parseInt()`)，因为字符串可能表示非常大的数字，会超出标准整数类型的范围。

这意味着我们需要模拟我们手动进行竖式加法的过程。

**核心思路：模拟竖式加法**

回想一下我们小学学过的竖式加法：

1.  将两个数字**右对齐**。
2.  从**最低位**（最右边）开始，逐位相加。
3.  如果当前位的和大于等于 10，则需要**进位** (carry) 到下一位。
4.  重复这个过程，直到处理完所有位数，并且没有剩余的进位。

代码就是将这个过程自动化。

**代码讲解 (结合示例)**

```java
class Solution {
    public String addStrings(String num1, String num2) {
        // 初始化两个指针 i 和 j，分别指向 num1 和 num2 的末尾（最低位）
        int i = num1.length() - 1, j = num2.length() - 1;
        // 初始化进位 add 为 0
        int add = 0;
        // 使用 StringBuffer 来高效地拼接结果字符串，因为我们在循环中操作
        StringBuffer ans = new StringBuffer();

        // 循环条件：只要 i 或 j 没有越界（即还有数字位要处理），或者还有进位 add 不为 0，就继续循环
        while (i >= 0 || j >= 0 || add != 0) {
            // 获取 num1 当前位的数字。如果 i 越界了，说明 num1 处理完了，当前位视为 0
            // num1.charAt(i) - '0' 是将字符数字（如 '5'）转换为整数（如 5）的常用技巧
            int x = i >= 0 ? num1.charAt(i) - '0' : 0;
            // 获取 num2 当前位的数字。如果 j 越界了，说明 num2 处理完了，当前位视为 0
            int y = j >= 0 ? num2.charAt(j) - '0' : 0;

            // 计算当前位的和：num1 的当前位 + num2 的当前位 + 上一位的进位
            int result = x + y + add;

            // 将当前位计算结果的个位数（result % 10）追加到 ans 的末尾
            // 注意：我们是从低位向高位计算，所以结果是反的，最后需要翻转
            ans.append(result % 10);

            // 计算新的进位，即当前位计算结果的十位数（result / 10）
            add = result / 10;

            // 将指针 i 和 j 向前（向左）移动一位，处理更高位
            i--;
            j--;
        }

        // 因为我们是从低位向高位追加的，所以得到的 ans 是倒序的，需要翻转过来
        ans.reverse();
        // 将 StringBuffer 转换为 String 并返回
        return ans.toString();
    }
}
```

**示例 1 演练：`num1 = "11", num2 = "123"`**

1.  **初始化:** `i = 1`, `j = 2`, `add = 0`, `ans = ""`
2.  **循环 1:**
    *   `i=1`, `j=2`, `add=0`
    *   `x = num1.charAt(1) - '0' = 1`
    *   `y = num2.charAt(2) - '0' = 3`
    *   `result = 1 + 3 + 0 = 4`
    *   `ans.append(4)` -> `ans = "4"`
    *   `add = 4 / 10 = 0`
    *   `i = 0`, `j = 1`
3.  **循环 2:**
    *   `i=0`, `j=1`, `add=0`
    *   `x = num1.charAt(0) - '0' = 1`
    *   `y = num2.charAt(1) - '0' = 2`
    *   `result = 1 + 2 + 0 = 3`
    *   `ans.append(3)` -> `ans = "43"`
    *   `add = 3 / 10 = 0`
    *   `i = -1`, `j = 0`
4.  **循环 3:**
    *   `i=-1`, `j=0`, `add=0`
    *   `x = 0` (因为 `i < 0`)
    *   `y = num2.charAt(0) - '0' = 1`
    *   `result = 0 + 1 + 0 = 1`
    *   `ans.append(1)` -> `ans = "431"`
    *   `add = 1 / 10 = 0`
    *   `i = -1`, `j = -1`
5.  **循环结束:** `i < 0`, `j < 0`, `add == 0`。
6.  **翻转:** `ans.reverse()` -> `ans = "134"`
7.  **返回:** `"134"`

**示例 2 演练：`num1 = "456", num2 = "77"`**

1.  **初始化:** `i = 2`, `j = 1`, `add = 0`, `ans = ""`
2.  **循环 1:**
    *   `i=2`, `j=1`, `add=0`
    *   `x = 6`, `y = 7`
    *   `result = 6 + 7 + 0 = 13`
    *   `ans.append(3)` -> `ans = "3"`
    *   `add = 13 / 10 = 1`
    *   `i = 1`, `j = 0`
3.  **循环 2:**
    *   `i=1`, `j=0`, `add=1`
    *   `x = 5`, `y = 7`
    *   `result = 5 + 7 + 1 = 13`
    *   `ans.append(3)` -> `ans = "33"`
    *   `add = 13 / 10 = 1`
    *   `i = 0`, `j = -1`
4.  **循环 3:**
    *   `i=0`, `j=-1`, `add=1`
    *   `x = 4`, `y = 0`
    *   `result = 4 + 0 + 1 = 5`
    *   `ans.append(5)` -> `ans = "335"`
    *   `add = 5 / 10 = 0`
    *   `i = -1`, `j = -1`
5.  **循环结束:** `i < 0`, `j < 0`, `add == 0`。
6.  **翻转:** `ans.reverse()` -> `ans = "533"`
7.  **返回:** `"533"`

**示例 3 演练：`num1 = "0", num2 = "0"`**

1.  **初始化:** `i = 0`, `j = 0`, `add = 0`, `ans = ""`
2.  **循环 1:**
    *   `i=0`, `j=0`, `add=0`
    *   `x = 0`, `y = 0`
    *   `result = 0 + 0 + 0 = 0`
    *   `ans.append(0)` -> `ans = "0"`
    *   `add = 0 / 10 = 0`
    *   `i = -1`, `j = -1`
3.  **循环结束:** `i < 0`, `j < 0`, `add == 0`。
4.  **翻转:** `ans.reverse()` -> `ans = "0"`
5.  **返回:** `"0"`

**总结**

该代码通过模拟手动竖式加法，巧妙地处理了字符串表示的大数相加问题。它从两个字符串的末尾开始，逐位相加并处理进位，最后将得到的倒序结果翻转，从而得到正确的和字符串。这种方法避免了使用受限的库函数，并且能够处理任意长度的非负整数字符串。




### 模拟手动竖式加法-Java-无注释





```JAVA

class Solution {
    public String addStrings(String num1, String num2) {



        int i = num1.length()-1;

        int j = num2.length()-1;

        int add = 0;

        StringBuffer sb = new StringBuffer();


        while( i >= 0 || j >= 0 || add > 0 ) {


            int x;

            int y;

            if( i >= 0 ) {

                x = num1.charAt(i) - '0';
            }
            else {
                
                x = 0;
            }

            if( j >= 0 ) {

                y = num2.charAt(j) - '0';
            }
            else {
                
                y = 0;
            }


            int reset = ( x + y + add ) % 10;


            sb.append(reset);

            add = ( x + y + add ) / 10;

            i--;

            j--;


        }

        sb.reverse();

        return sb.toString();


        
    }
}


```





### 模拟手动竖式加法-Java-注释版


对代码进行详细注释，并结合示例讲解



好的，我们来为这段模拟手动竖式加法的 Java 代码添加详细注释，并结合示例进行讲解。

**代码详细注释**

```java
class Solution {
    /**
     * 计算两个字符串表示的非负整数的和。
     *
     * @param num1 第一个非负整数字符串
     * @param num2 第二个非负整数字符串
     * @return 两个整数的和，以字符串形式表示
     */
    public String addStrings(String num1, String num2) {

        // 初始化指针 i 指向 num1 的末尾（最低位）
        int i = num1.length() - 1;
        // 初始化指针 j 指向 num2 的末尾（最低位）
        int j = num2.length() - 1;
        // 初始化进位 add 为 0
        int add = 0;
        // 使用 StringBuffer (或 StringBuilder) 来高效地构建结果字符串（逆序）
        // 因为字符串是不可变的，直接用 + 拼接效率较低
        StringBuffer sb = new StringBuffer();

        // 循环条件：
        // 只要 num1 或 num2 还有未处理的位 (i >= 0 或 j >= 0)，
        // 或者最后还有进位 (add > 0)，就继续循环
        while (i >= 0 || j >= 0 || add > 0) {

            // 获取 num1 当前位的数字
            int x;
            if (i >= 0) {
                // 将字符数字转换为整数。例如 '5' - '0' = 5
                x = num1.charAt(i) - '0';
            } else {
                // 如果 num1 已经处理完毕 (i < 0)，则当前位视为 0
                x = 0;
            }

            // 获取 num2 当前位的数字
            int y;
            if (j >= 0) {
                // 将字符数字转换为整数
                y = num2.charAt(j) - '0';
            } else {
                // 如果 num2 已经处理完毕 (j < 0)，则当前位视为 0
                y = 0;
            }

            // 计算当前位的和（num1 当前位 + num2 当前位 + 上一位的进位）
            // 并取结果的个位数，作为当前位的结果
            int result = (x + y + add) % 10;

            // 将当前位的结果追加到 StringBuffer 的末尾
            // 注意：此时 sb 中存储的是结果的逆序
            sb.append(result);

            // 计算新的进位（和的十位数）
            add = (x + y + add) / 10;

            // 将指针向前移动一位，处理更高位
            i--;
            j--;
        }

        // 因为是从低位向高位追加的，所以需要将结果字符串翻转
        sb.reverse();
        // 将 StringBuffer 转换为 String 并返回
        return sb.toString();
    }
}
```

**结合示例讲解**

我们使用题目中的示例来逐步讲解代码的执行过程。

**示例 1：`num1 = "11", num2 = "123"`**

1.  **初始化:**
    *   `i = 1` (指向 num1 的 '1')
    *   `j = 2` (指向 num2 的 '3')
    *   `add = 0`
    *   `sb = ""`

2.  **循环 1:**
    *   `i=1`, `j=2`, `add=0` -> 满足 `i >= 0 || j >= 0 || add > 0`
    *   `x = num1.charAt(1) - '0' = 1`
    *   `y = num2.charAt(2) - '0' = 3`
    *   `result = (1 + 3 + 0) % 10 = 4`
    *   `sb.append(4)` -> `sb = "4"`
    *   `add = (1 + 3 + 0) / 10 = 0`
    *   `i = 0`, `j = 1`

3.  **循环 2:**
    *   `i=0`, `j=1`, `add=0` -> 满足 `i >= 0 || j >= 0 || add > 0`
    *   `x = num1.charAt(0) - '0' = 1`
    *   `y = num2.charAt(1) - '0' = 2`
    *   `result = (1 + 2 + 0) % 10 = 3`
    *   `sb.append(3)` -> `sb = "43"`
    *   `add = (1 + 2 + 0) / 10 = 0`
    *   `i = -1`, `j = 0`

4.  **循环 3:**
    *   `i=-1`, `j=0`, `add=0` -> 满足 `i >= 0 || j >= 0 || add > 0`
    *   `x = 0` (因为 `i < 0`)
    *   `y = num2.charAt(0) - '0' = 1`
    *   `result = (0 + 1 + 0) % 10 = 1`
    *   `sb.append(1)` -> `sb = "431"`
    *   `add = (0 + 1 + 0) / 10 = 0`
    *   `i = -1`, `j = -1`

5.  **循环 4:**
    *   `i=-1`, `j=-1`, `add=0` -> 不满足 `i >= 0 || j >= 0 || add > 0`，循环结束。

6.  **翻转:** `sb.reverse()` -> `sb = "134"`
7.  **返回:** `"134"`

**示例 2：`num1 = "456", num2 = "77"`**

1.  **初始化:**
    *   `i = 2` (指向 num1 的 '6')
    *   `j = 1` (指向 num2 的 '7')
    *   `add = 0`
    *   `sb = ""`

2.  **循环 1:**
    *   `i=2`, `j=1`, `add=0` -> 满足条件
    *   `x = 6`, `y = 7`
    *   `result = (6 + 7 + 0) % 10 = 3`
    *   `sb.append(3)` -> `sb = "3"`
    *   `add = (6 + 7 + 0) / 10 = 1`
    *   `i = 1`, `j = 0`

3.  **循环 2:**
    *   `i=1`, `j=0`, `add=1` -> 满足条件
    *   `x = 5`, `y = 7`
    *   `result = (5 + 7 + 1) % 10 = 3`
    *   `sb.append(3)` -> `sb = "33"`
    *   `add = (5 + 7 + 1) / 10 = 1`
    *   `i = 0`, `j = -1`

4.  **循环 3:**
    *   `i=0`, `j=-1`, `add=1` -> 满足条件
    *   `x = 4`, `y = 0`
    *   `result = (4 + 0 + 1) % 10 = 5`
    *   `sb.append(5)` -> `sb = "335"`
    *   `add = (4 + 0 + 1) / 10 = 0`
    *   `i = -1`, `j = -1`

5.  **循环 4:**
    *   `i=-1`, `j=-1`, `add=0` -> 不满足条件，循环结束。

6.  **翻转:** `sb.reverse()` -> `sb = "533"`
7.  **返回:** `"533"`

这段代码通过模拟竖式加法，从两个字符串的最低位开始逐位相加，并处理进位，最终得到结果字符串。使用 `StringBuffer` (或 `StringBuilder`) 可以避免频繁创建新的字符串对象，提高了效率。











---

























## 36进制加法（字节面试原题）

题目描述
36进制由0-9，a-z，共36个字符表示。

要求按照加法规则计算出任意两个36进制正整数的和，如1b + 2x = 48  （解释：47+105=152）

要求：不允许使用先将36进制数字整体转为10进制，相加后再转回为36进制的做法





### 模拟手动竖式加法-Java

解答该题目，并结合示例详细具体地讲解该题目






好的，我们来详细讲解这个 36 进制加法问题，并提供 Java 代码实现。

**题目解析**

题目要求我们计算两个用 36 进制表示的正整数的和。36 进制使用数字 '0'-'9' 代表 0-9，字母 'a'-'z' 代表 10-35。关键限制是**不能**将整个 36 进制字符串转换为 10 进制整数，进行加法运算后，再转回 36 进制。

这道题的核心思想与我们之前讨论的 LeetCode 415 "字符串相加" 非常相似，都是**模拟手动竖式加法**的过程，只不过这次的“进制”是 36，而不是 10。

**核心思路：模拟 36 进制竖式加法**

1.  **对齐与遍历：** 将两个 36 进制数（字符串）想象成右对齐。我们从两个字符串的末尾（最低位）开始，逐位向前处理。
2.  **逐位计算：**
    *   对于当前处理的位，获取两个数字对应位的字符。如果某个数字已经处理完毕（指针越界），则认为该位的值为 0。
    *   将这两个字符转换为它们对应的 10 进制数值（0-35）。
    *   将这两个 10 进制数值与来自上一位的**进位 (carry)** 相加，得到当前位的**和 (sum)**。
3.  **处理结果与进位：**
    *   当前位的结果字符，是 `sum % 36` 对应的 36 进制字符。
    *   新的进位 `carry` 是 `sum / 36`。
4.  **循环与结束：** 重复步骤 2 和 3，直到两个字符串的所有位都处理完毕，并且最后的进位 `carry` 也为 0。
5.  **结果翻转：** 由于我们是从低位向高位计算并拼接结果的，所以最终得到的字符串需要翻转才是正确的顺序。

**字符与数值的转换**

我们需要两个辅助函数（或逻辑）来进行 36 进制字符和其对应的 10 进制数值之间的转换：

*   **字符 -> 数值 (charToValue):**
    *   如果字符是 '0' 到 '9'，数值 = `char - '0'`。
    *   如果字符是 'a' 到 'z'，数值 = `char - 'a' + 10`。
*   **数值 -> 字符 (valueToChar):**
    *   如果数值是 0 到 9，字符 = `(char)(value + '0')`。
    *   如果数值是 10 到 35，字符 = `(char)(value - 10 + 'a')`。

**Java 代码实现**

```java
import java.util.HashMap;
import java.util.Map;

public class Base36Addition {

    // 预先构建字符到数值的映射，提高效率
    private static final Map<Character, Integer> charToValueMap = new HashMap<>();
    // 预先构建数值到字符的映射，提高效率
    private static final char[] valueToCharMap = new char[36];

    static {
        // 初始化映射表
        for (int i = 0; i < 10; i++) {
            char c = (char) ('0' + i);
            charToValueMap.put(c, i);
            valueToCharMap[i] = c;
        }
        for (int i = 0; i < 26; i++) {
            char c = (char) ('a' + i);
            int value = 10 + i;
            charToValueMap.put(c, value);
            valueToCharMap[value] = c;
        }
    }

    /**
     * 将 36 进制字符转换为对应的 10 进制数值 (0-35)
     * @param c 36 进制字符 ('0'-'9', 'a'-'z')
     * @return 对应的 10 进制数值
     */
    private static int charToValue(char c) {
        // 可以直接使用预构建的 Map
        return charToValueMap.getOrDefault(Character.toLowerCase(c), 0); // 忽略大小写，如果字符无效返回0
        /* 或者直接计算：
        if (c >= '0' && c <= '9') {
            return c - '0';
        } else if (c >= 'a' && c <= 'z') {
            return c - 'a' + 10;
        } else if (c >= 'A' && c <= 'Z') { // 考虑大写字母输入
            return c - 'A' + 10;
        } else {
            // 可以抛出异常或返回特定值表示无效输入
            throw new IllegalArgumentException("Invalid character in base-36 number: " + c);
        }
        */
    }

    /**
     * 将 10 进制数值 (0-35) 转换为对应的 36 进制字符
     * @param value 10 进制数值 (0-35)
     * @return 对应的 36 进制字符 ('0'-'9', 'a'-'z')
     */
    private static char valueToChar(int value) {
        if (value < 0 || value >= 36) {
            throw new IllegalArgumentException("Value out of range for base-36 conversion: " + value);
        }
        // 可以直接使用预构建的数组
        return valueToCharMap[value];
        /* 或者直接计算：
        if (value >= 0 && value <= 9) {
            return (char) (value + '0');
        } else { // value >= 10 && value <= 35
            return (char) (value - 10 + 'a');
        }
        */
    }

    /**
     * 计算两个 36 进制正整数的和
     * @param num1 第一个 36 进制数字符串
     * @param num2 第二个 36 进制数字符串
     * @return 两个数字的和，以 36 进制字符串表示
     */
    public String addBase36(String num1, String num2) {
        // 指针分别指向两个字符串的末尾
        int i = num1.length() - 1;
        int j = num2.length() - 1;
        // 进位初始化为 0
        int carry = 0;
        // 使用 StringBuilder 存储结果（逆序）
        StringBuilder resultReversed = new StringBuilder();

        // 循环条件：只要还有数字位未处理，或者还有进位，就继续
        while (i >= 0 || j >= 0 || carry != 0) {
            // 获取当前位的数值，如果指针越界则视为 0
            int val1 = (i >= 0) ? charToValue(num1.charAt(i)) : 0;
            int val2 = (j >= 0) ? charToValue(num2.charAt(j)) : 0;

            // 计算当前位的和（两个数值 + 进位）
            int sum = val1 + val2 + carry;

            // 计算当前位的结果字符 (sum % 36) 并追加到结果中
            resultReversed.append(valueToChar(sum % 36));

            // 计算新的进位 (sum / 36)
            carry = sum / 36;

            // 移动指针到下一位（向前）
            i--;
            j--;
        }

        // 翻转结果字符串得到正确的顺序
        return resultReversed.reverse().toString();
    }

    public static void main(String[] args) {
        Base36Addition adder = new Base36Addition();

        // 示例测试
        String num1 = "1b"; // 1*36^1 + 11*36^0 = 36 + 11 = 47 (十进制)
        String num2 = "2x"; // 2*36^1 + 33*36^0 = 72 + 33 = 105 (十进制)
        String sum = adder.addBase36(num1, num2);
        System.out.println(num1 + " + " + num2 + " = " + sum); // 预期输出: 1b + 2x = 48

        // 47 + 105 = 152 (十进制)
        // 152 / 36 = 4 余 8
        // 4 / 36 = 0 余 4
        // 从下往上读余数 -> 48 (三十六进制)

        // 其他测试用例
        String num3 = "z"; // 35
        String num4 = "1"; // 1
        System.out.println(num3 + " + " + num4 + " = " + adder.addBase36(num3, num4)); // 预期输出: z + 1 = 10

        String num5 = "1z"; // 1*36 + 35 = 71
        String num6 = "1";  // 1
        System.out.println(num5 + " + " + num6 + " = " + adder.addBase36(num5, num6)); // 预期输出: 1z + 1 = 20 (71+1=72, 72/36=2余0 -> 20)

        String num7 = "abcdef";
        String num8 = "fedcba";
        System.out.println(num7 + " + " + num8 + " = " + adder.addBase36(num7, num8));
    }
}
```

**结合示例 `1b + 2x = 48` 讲解代码执行流程**

1.  **初始化:** `i = 1` (指向 'b'), `j = 1` (指向 'x'), `carry = 0`, `resultReversed = ""`
2.  **循环 1 (处理最低位 'b' 和 'x'):**
    *   `val1 = charToValue('b') = 11`
    *   `val2 = charToValue('x') = 33`
    *   `sum = 11 + 33 + 0 = 44`
    *   `resultReversed.append(valueToChar(44 % 36))` -> `resultReversed.append(valueToChar(8))` -> `resultReversed.append('8')` -> `resultReversed = "8"`
    *   `carry = 44 / 36 = 1`
    *   `i = 0`, `j = 0`
3.  **循环 2 (处理位 '1' 和 '2'):**
    *   `val1 = charToValue('1') = 1`
    *   `val2 = charToValue('2') = 2`
    *   `sum = 1 + 2 + 1 = 4`
    *   `resultReversed.append(valueToChar(4 % 36))` -> `resultReversed.append(valueToChar(4))` -> `resultReversed.append('4')` -> `resultReversed = "84"`
    *   `carry = 4 / 36 = 0`
    *   `i = -1`, `j = -1`
4.  **循环 3 (检查结束条件):**
    *   `i < 0` (true)
    *   `j < 0` (true)
    *   `carry == 0` (true)
    *   循环条件 `(i >= 0 || j >= 0 || carry != 0)` 为 false，循环结束。
5.  **翻转:** `resultReversed.reverse()` -> `resultReversed = "48"`
6.  **返回:** `"48"`

这个过程完全模拟了手动计算 36 进制加法的步骤，满足了题目不允许整体转换进制的要求。代码中加入了字符与数值转换的辅助函数，并使用了 `StringBuilder` 来高效构建结果字符串。预计算的 Map 和数组可以进一步提高转换效率，但对于面试来说，直接在循环中计算转换也是可以接受的。







# 
































# 二叉树


struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};


解读一下


这段代码定义了一个 C++ 结构体 (struct) `TreeNode`，它通常用于表示二叉树（Binary Tree）中的节点。 让我来详细解读一下：

**结构体定义： `struct TreeNode { ... };`**

*   **`struct TreeNode`**:  这行代码声明了一个名为 `TreeNode` 的结构体。在 C++ 中，`struct` 是一种用户自定义的数据类型，它可以将不同类型的数据组合在一起。结构体类似于类 (class)，但默认情况下，结构体的成员是公有的 (public)，而类的成员默认是私有的 (private)。 在这里，我们使用 `struct` 通常是因为 `TreeNode` 主要用于数据聚合，而不是复杂的行为封装。

**结构体成员：**

1.  **`int val;`**
    *   **`int`**:  这指定了成员变量 `val` 的数据类型为整数 (integer)。
    *   **`val`**:  这是结构体的一个成员变量，通常用来存储节点的值（value）。在二叉树中，每个节点都会包含一个值，这个 `val` 变量就是用来存放这个值的。

2.  **`TreeNode *left;`**
    *   **`TreeNode *`**:  这指定了成员变量 `left` 的数据类型为 `TreeNode *`，这是一个指向 `TreeNode` 类型的指针。
    *   **`left`**:  这是结构体的另一个成员变量，通常用来指向当前节点的**左子节点** (left child)。由于它是一个指针，所以它可以指向另一个 `TreeNode` 类型的对象，从而在树结构中连接到左子节点。如果当前节点没有左子节点，`left` 指针通常会被设置为 `NULL` (或者 `nullptr` 在现代 C++ 中)。

3.  **`TreeNode *right;`**
    *   **`TreeNode *`**:  同样，这指定了成员变量 `right` 的数据类型为 `TreeNode *`，也是一个指向 `TreeNode` 类型的指针。
    *   **`right`**:  这是结构体的第三个成员变量，通常用来指向当前节点的**右子节点** (right child)。类似于 `left` 指针，`right` 指针也用于在树结构中连接到右子节点。如果当前节点没有右子节点，`right` 指针也会被设置为 `NULL`。

**构造函数： `TreeNode(int x) : val(x), left(NULL), right(NULL) {}`**

*   **`TreeNode(int x)`**:  这是一个构造函数 (constructor)。构造函数是一种特殊的成员函数，在创建 `TreeNode` 对象时自动调用。它的名称与结构体名称相同。这里，构造函数接受一个整数参数 `x`。
*   **`: val(x), left(NULL), right(NULL)`**:  这是一个**初始化列表 (initializer list)**。它用于在构造函数体执行之前，高效地初始化结构体的成员变量。
    *   **`val(x)`**:  将传入的参数 `x` 的值赋给成员变量 `val`。
    *   **`left(NULL)`**:  将成员变量 `left` 初始化为 `NULL`。这意味着在创建新的 `TreeNode` 对象时，默认情况下它没有左子节点。
    *   **`right(NULL)`**:  将成员变量 `right` 初始化为 `NULL`。同样，默认情况下，新创建的 `TreeNode` 对象也没有右子节点。
*   **`{}`**:  这是构造函数的函数体，这里是空的。因为所有的初始化工作都在初始化列表中完成了，所以构造函数体不需要再执行额外的代码。

**总结：**

`struct TreeNode` 定义了一个表示二叉树节点的结构。每个 `TreeNode` 对象包含：

*   一个整数值 `val`，存储节点的数据。
*   一个指向左子节点的指针 `left`。
*   一个指向右子节点的指针 `right`。

构造函数 `TreeNode(int x)` 用于创建新的 `TreeNode` 对象，并初始化节点的值为 `x`，同时将左右子节点指针初始化为 `NULL`。

**用途：**

这个 `TreeNode` 结构体是构建和操作二叉树数据结构的基础。 你可以使用它来：

*   创建二叉树的节点。
*   构建各种类型的二叉树，例如二叉搜索树、平衡二叉树等。
*   实现各种二叉树算法，例如遍历（前序、中序、后序）、搜索、插入、删除等。

**示例用法：**

```c++
#include <iostream>

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

int main() {
    // 创建根节点
    TreeNode* root = new TreeNode(1);

    // 创建左子节点和右子节点
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);

    // 创建左子节点的左子节点
    root->left->left = new TreeNode(4);

    // 访问节点的值
    std::cout << "Root value: " << root->val << std::endl; // 输出: Root value: 1
    std::cout << "Left child value: " << root->left->val << std::endl; // 输出: Left child value: 2
    std::cout << "Right child value: " << root->right->val << std::endl; // 输出: Right child value: 3
    std::cout << "Left-left child value: " << root->left->left->val << std::endl; // 输出: Left-left child value: 4

    return 0;
}
```

这段示例代码演示了如何使用 `TreeNode` 结构体创建和连接二叉树的节点，并访问节点的值。  在实际应用中，你会使用这个结构体来构建更复杂的二叉树，并实现各种树相关的算法。






## 极尽详细地讲解二叉树涉及的所有知识，代码示例使用java语言，并且嵌入有详细注释易于理解。


好的，没问题！我会用 Java 语言，并结合详细的注释，深入浅出地讲解二叉树的所有相关知识点。为了方便理解，我会将内容组织成以下结构：

1.  **什么是树和二叉树**
    *   树的基本概念
    *   二叉树的定义和特点
    *   二叉树的节点结构 (Java 代码 `TreeNode` 类)
2.  **二叉树的类型**
    *   满二叉树 (Full Binary Tree)
    *   完全二叉树 (Complete Binary Tree)
    *   完美二叉树 (Perfect Binary Tree)
    *   退化二叉树 (Degenerate or Skewed Binary Tree)
    *   平衡二叉树 (Balanced Binary Tree)
3.  **二叉树的遍历**
    *   前序遍历 (Preorder Traversal)
    *   中序遍历 (Inorder Traversal)
    *   后序遍历 (Postorder Traversal)
    *   层序遍历 (Level Order Traversal / Breadth-First Search)
4.  **二叉搜索树 (Binary Search Tree - BST)**
    *   BST 的定义和性质
    *   BST 的基本操作：查找、插入、删除、最小值、最大值
5.  **平衡二叉搜索树 (Balanced BST) 简介**
    *   为什么需要平衡二叉搜索树
    *   常见的平衡二叉搜索树类型 (AVL 树、红黑树等)
6.  **二叉树的应用场景**
    *   表达式树 (Expression Tree)
    *   哈夫曼树 (Huffman Tree)
    *   决策树 (Decision Tree)
    *   文件系统目录结构
    *   数据库索引 (B-Tree, B+ Tree - 概念联系)
7.  **总结**

让我们开始吧！

---

### 1. 什么是树和二叉树

#### 1.1 树的基本概念

在计算机科学中，**树 (Tree)** 是一种非常重要的非线性数据结构，它模拟了自然界中树状结构。树由节点 (Node) 和边 (Edge) 组成。

*   **节点 (Node)**: 树的基本单元，包含数据和指向子节点的链接。
*   **边 (Edge)**: 连接节点的线，表示节点之间的关系。
*   **根节点 (Root Node)**: 树的顶端节点，没有父节点，一棵树只有一个根节点。
*   **父节点 (Parent Node)**: 有子节点的节点。
*   **子节点 (Child Node)**: 节点的直接后继节点。
*   **叶节点 (Leaf Node)**: 没有子节点的节点，也称为终端节点。
*   **兄弟节点 (Sibling Nodes)**: 拥有相同父节点的节点。
*   **祖先节点 (Ancestor Nodes)**: 从根节点到某个节点路径上的所有节点都是该节点的祖先节点。
*   **后代节点 (Descendant Nodes)**:  某个节点的所有子树中的节点都是该节点的后代节点。
*   **路径 (Path)**: 从一个节点到另一个节点所经过的边序列。
*   **深度 (Depth)**: 从根节点到该节点的唯一路径上的边数。根节点的深度为 0。
*   **高度 (Height)**: 从该节点到最远叶节点的最长路径上的边数。叶节点的高度为 0。树的高度通常指根节点的高度。
*   **层 (Level)**: 根节点为第 0 层，根节点的子节点为第 1 层，以此类推。层数和深度通常可以互换使用，但有时根节点被认为是第 1 层。

**示例：**

```
        A (根节点)
       / \
      B   C
     / \   \
    D   E   F (叶节点)
   /
  G (叶节点)
```

在这个例子中：

*   A 是根节点。
*   B 和 C 是 A 的子节点，A 是 B 和 C 的父节点。
*   D 和 E 是 B 的子节点，F 是 C 的子节点。
*   D, E, F, G 是叶节点。
*   B 和 C 是兄弟节点，D 和 E 是兄弟节点。
*   A, B, D, G 是节点 G 的祖先节点。
*   D, E, G 是节点 B 的后代节点，F 是节点 C 的后代节点。
*   从 A 到 G 的路径是 A-B-D-G。
*   节点 G 的深度是 3。
*   节点 B 的高度是 2 (最长路径 B-D-G 或 B-E)。
*   树的高度是 3 (根节点 A 的高度)。

#### 1.2 二叉树的定义和特点

**二叉树 (Binary Tree)** 是一种特殊的树结构，它的特点是每个节点最多只有两个子节点，分别称为**左子节点 (left child)** 和 **右子节点 (right child)**。

**二叉树的特点：**

1.  **最多两个子节点**:  每个节点最多可以有零个、一个或两个子节点。
2.  **子节点区分左右**:  二叉树的子节点严格区分左子节点和右子节点，即使只有一个子节点，也要区分是左子节点还是右子节点。这是二叉树与普通树的最主要区别。
3.  **递归定义**: 二叉树可以用递归的方式定义。一个二叉树要么是空树，要么由一个根节点和两棵互不相交的分别称作根的左子树和右子树的二叉树组成。

**二叉树的用途非常广泛，例如：**

*   **表示层次关系**:  例如文件系统目录结构、组织结构等。
*   **搜索和排序**:  二叉搜索树 (BST) 是一种高效的搜索和排序数据结构。
*   **表达式求值**:  表达式树可以用于表示和计算数学表达式。
*   **数据压缩**:  哈夫曼树用于数据压缩算法。
*   **路由算法**:  在网络路由中可以使用树结构。

#### 1.3 二叉树的节点结构 (Java 代码 `TreeNode` 类)

在 Java 中，我们可以使用类 (class) 来表示二叉树的节点。通常，一个二叉树节点至少需要包含以下信息：

*   **节点值 (value)**:  存储节点的数据。
*   **左子节点指针 (left pointer)**:  指向左子节点的引用。
*   **右子节点指针 (right pointer)**: 指向右子节点的引用。

下面是使用 Java 代码定义的 `TreeNode` 类：

```java
package binarytree;

/**
 * 二叉树节点类
 */
public class TreeNode {
    int val;         // 节点值
    TreeNode left;   // 左子节点引用
    TreeNode right;  // 右子节点引用

    /**
     * 构造函数，用于创建值为 val 的新节点
     * @param val 节点的值
     */
    public TreeNode(int val) {
        this.val = val;
        this.left = null;  // 初始时左子节点为空
        this.right = null; // 初始时右子节点为空
    }

    // 为了方便，可以添加一个 toString 方法来打印节点值（可选）
    @Override
    public String toString() {
        return String.valueOf(val);
    }
}
```

**代码解释：**

*   **`package binarytree;`**:  声明类所在的包，方便组织代码。
*   **`public class TreeNode { ... }`**:  定义一个公共类 `TreeNode`，表示二叉树节点。
*   **`int val;`**:  定义一个整型成员变量 `val`，用于存储节点的值。你可以根据实际需求更改数据类型，例如 `String`, `double` 等。
*   **`TreeNode left;`**:  定义一个 `TreeNode` 类型的成员变量 `left`，用于存储指向左子节点的引用。`TreeNode` 类型本身就是我们定义的节点类，所以 `left` 可以指向另一个 `TreeNode` 对象，从而构成树结构。如果节点没有左子节点，`left` 的值为 `null`。
*   **`TreeNode right;`**: 定义一个 `TreeNode` 类型的成员变量 `right`，用于存储指向右子节点的引用。与 `left` 类似，`right` 指向右子节点，没有右子节点时值为 `null`。
*   **`public TreeNode(int val) { ... }`**:  这是 `TreeNode` 类的构造函数。
    *   **`this.val = val;`**:  将构造函数传入的参数 `val` 赋值给节点的 `val` 成员变量，初始化节点的值。
    *   **`this.left = null;`**:  将节点的 `left` 成员变量初始化为 `null`，表示新创建的节点默认没有左子节点。
    *   **`this.right = null;`**: 将节点的 `right` 成员变量初始化为 `null`，表示新创建的节点默认没有右子节点。
*   **`@Override public String toString() { ... }`**:  重写 `toString()` 方法（可选）。
    *   **`@Override`**:  注解，表示这个方法重写了父类 `Object` 的 `toString()` 方法。
    *   **`public String toString() { ... }`**:  公共方法，返回一个字符串表示当前对象。
    *   **`return String.valueOf(val);`**:  返回节点值的字符串表示。这样在打印 `TreeNode` 对象时，可以直接输出节点的值，方便调试和查看。

现在我们已经定义了 `TreeNode` 类，可以开始构建二叉树了。

---

### 2. 二叉树的类型

二叉树根据其结构特点，可以分为多种类型。了解这些类型有助于我们更好地理解和应用二叉树。

#### 2.1 满二叉树 (Full Binary Tree)

**定义：**  除了叶节点外，每个节点都有两个子节点。也就是说，如果一个节点不是叶节点，那么它必须有左子节点和右子节点。

**特点：**

*   所有非叶子节点都有两个子节点。
*   叶子节点都在同一层。
*   如果满二叉树的深度为 `k` (根节点深度为 0)，则节点总数为 `2^(k+1) - 1`，叶子节点数为 `2^k`，非叶子节点数为 `2^k - 1`。

**示例：**

```
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

#### 2.2 完全二叉树 (Complete Binary Tree)

**定义：**  除了最后一层外，其他层的节点都被完全填满，并且最后一层的节点都尽可能地集中在左侧。

**特点：**

*   除了最后一层，其他层都是满的。
*   最后一层的节点从左向右连续排列，中间不能有空缺。
*   满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。

**示例：**

**完全二叉树：**

```
        1
       / \
      2   3
     / \ /
    4  5 6
```

**非完全二叉树 (最后一层节点不连续靠左)：**

```
        1
       / \
      2   3
     /   / \
    4   6  7  // 节点 5 缺失，最后一层不连续
```

**完全二叉树的用途：**  堆 (Heap) 这种数据结构通常用完全二叉树来实现。

#### 2.3 完美二叉树 (Perfect Binary Tree)

**定义：**  所有层都被完全填满的二叉树。完美二叉树也称为**完全满二叉树** 或 **理想二叉树**。

**特点：**

*   所有层的节点数都达到最大值。
*   所有叶子节点都在同一层。
*   完美二叉树一定是满二叉树，也是完全二叉树。
*   如果完美二叉树的深度为 `k`，则节点总数为 `2^(k+1) - 1`。

**示例：**

```
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

可以看到，完美二叉树和满二叉树的结构在这个例子中是一样的，但概念上略有区别。通常 "完美二叉树" 更强调所有层都填满的理想状态。

#### 2.4 退化二叉树 (Degenerate or Skewed Binary Tree)

**定义：**  每个节点都只有一个子节点，或者没有子节点。退化二叉树看起来像一个链表。

**特点：**

*   树的高度等于节点总数。
*   退化二叉树分为**左倾斜树 (Left Skewed Tree)** 和 **右倾斜树 (Right Skewed Tree)**。
    *   **左倾斜树**: 所有节点都只有左子节点，或者没有子节点。
    *   **右倾斜树**: 所有节点都只有右子节点，或者没有子节点。

**示例：**

**左倾斜树：**

```
1
 \
  2
   \
    3
     \
      4
```

**右倾斜树：**

```
    1
   /
  2
 /
3
/
4
```

**退化二叉树的缺点：**  当二叉树退化成链表时，某些操作 (如搜索) 的效率会降低，时间复杂度会从平衡情况下的 O(log n) 退化到 O(n)。

#### 2.5 平衡二叉树 (Balanced Binary Tree)

**定义：**  树中每个节点的左子树和右子树的高度差的绝对值不超过 1。平衡二叉树也被称为 **AVL 树 (Adelson-Velsky and Landis Tree)**。

**特点：**

*   左右子树的高度差相对较小，保持树的平衡性。
*   平衡二叉树有助于提高搜索、插入和删除等操作的效率，时间复杂度通常为 O(log n)。
*   满二叉树、完全二叉树和完美二叉树都是平衡二叉树的特例。

**示例：**

**平衡二叉树：**

```
        3
       / \
      2   4
     /     \
    1       5
```

**非平衡二叉树 (节点 2 的左子树高度为 1，右子树高度为 -1，高度差为 2 > 1)：**

```
        3
       / \
      2   4
     /
    1
     \
      5  // 节点 2 的右子树为空，高度为 -1 (或 -1)，左子树高度为 1，高度差绝对值 > 1
```

**平衡二叉树的重要性：**  在实际应用中，为了避免二叉树退化成链表，通常会使用平衡二叉树，例如 AVL 树、红黑树等。这些平衡树会在插入和删除节点时，通过旋转等操作来维持树的平衡，从而保证高效的性能。

**总结：**

不同的二叉树类型适用于不同的应用场景。例如，完全二叉树常用于堆数据结构，平衡二叉树用于需要高效搜索和更新的场景，而满二叉树和完美二叉树通常作为理论上的理想模型。

---

### 3. 二叉树的遍历

**二叉树遍历 (Binary Tree Traversal)** 是指按照某种特定的规则， systematic 地访问二叉树中的所有节点，并且每个节点只被访问一次。遍历是二叉树操作的基础，很多算法都需要通过遍历来完成。

常见的二叉树遍历方式主要有四种：

1.  **前序遍历 (Preorder Traversal)**
2.  **中序遍历 (Inorder Traversal)**
3.  **后序遍历 (Postorder Traversal)**
4.  **层序遍历 (Level Order Traversal / Breadth-First Search)**

前三种遍历方式 (前序、中序、后序) 主要是基于**深度优先搜索 (Depth-First Search - DFS)** 的思想，而层序遍历是基于**广度优先搜索 (Breadth-First Search - BFS)** 的思想。

#### 3.1 前序遍历 (Preorder Traversal)

**遍历顺序：**  **根节点 -> 左子树 -> 右子树** (Root-Left-Right)

**步骤：**

1.  访问根节点。
2.  递归地前序遍历左子树。
3.  递归地前序遍历右子树。

**Java 代码实现 (递归方式)：**

```java
package binarytree;

import java.util.ArrayList;
import java.util.List;

public class BinaryTreeTraversal {

    /**
     * 前序遍历 (递归实现)
     * @param root 二叉树根节点
     * @return 前序遍历结果列表
     */
    public List<Integer> preorderTraversalRecursive(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preorderRecursiveHelper(root, result);
        return result;
    }

    private void preorderRecursiveHelper(TreeNode node, List<Integer> result) {
        if (node == null) {
            return; // 递归终止条件：节点为空
        }

        result.add(node.val);          // 1. 访问根节点 (将节点值加入结果列表)
        preorderRecursiveHelper(node.left, result);   // 2. 递归遍历左子树
        preorderRecursiveHelper(node.right, result);  // 3. 递归遍历右子树
    }

    // ... (其他遍历方法的代码将在后面添加) ...

    public static void main(String[] args) {
        // 构建一个简单的二叉树用于测试遍历
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);

        BinaryTreeTraversal traversal = new BinaryTreeTraversal();

        // 前序遍历测试
        List<Integer> preorderResult = traversal.preorderTraversalRecursive(root);
        System.out.println("前序遍历 (递归): " + preorderResult); // 输出: [1, 2, 4, 5, 3, 6, 7]
    }
}
```

**代码解释：**

*   **`preorderTraversalRecursive(TreeNode root)`**:  前序遍历的入口方法，接收二叉树的根节点 `root` 作为参数，返回一个 `List<Integer>` 存储遍历结果。
*   **`preorderRecursiveHelper(TreeNode node, List<Integer> result)`**:  递归辅助方法，实际执行递归遍历。
    *   **`if (node == null) { return; }`**:  递归终止条件。如果当前节点 `node` 为空 (`null`)，则停止递归，返回上一层调用。
    *   **`result.add(node.val);`**:  **访问根节点**。将当前节点 `node` 的值 `val` 添加到结果列表 `result` 中。
    *   **`preorderRecursiveHelper(node.left, result);`**:  **递归遍历左子树**。调用 `preorderRecursiveHelper` 方法，传入当前节点的左子节点 `node.left` 和结果列表 `result`。
    *   **`preorderRecursiveHelper(node.right, result);`**:  **递归遍历右子树**。调用 `preorderRecursiveHelper` 方法，传入当前节点的右子节点 `node.right` 和结果列表 `result`。

**前序遍历的特点：**  遍历结果的第一个元素总是根节点的值。

#### 3.2 中序遍历 (Inorder Traversal)

**遍历顺序：**  **左子树 -> 根节点 -> 右子树** (Left-Root-Right)

**步骤：**

1.  递归地中序遍历左子树。
2.  访问根节点。
3.  递归地中序遍历右子树。

**Java 代码实现 (递归方式)：**

```java
package binarytree;

import java.util.ArrayList;
import java.util.List;

public class BinaryTreeTraversal {

    // ... (preorderTraversalRecursive 方法代码保持不变) ...

    /**
     * 中序遍历 (递归实现)
     * @param root 二叉树根节点
     * @return 中序遍历结果列表
     */
    public List<Integer> inorderTraversalRecursive(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inorderRecursiveHelper(root, result);
        return result;
    }

    private void inorderRecursiveHelper(TreeNode node, List<Integer> result) {
        if (node == null) {
            return; // 递归终止条件：节点为空
        }

        inorderRecursiveHelper(node.left, result);    // 1. 递归遍历左子树
        result.add(node.val);           // 2. 访问根节点 (将节点值加入结果列表)
        inorderRecursiveHelper(node.right, result);   // 3. 递归遍历右子树
    }

    public static void main(String[] args) {
        // ... (构建二叉树的代码保持不变) ...
        BinaryTreeTraversal traversal = new BinaryTreeTraversal();

        // ... (前序遍历测试代码保持不变) ...

        // 中序遍历测试
        List<Integer> inorderResult = traversal.inorderTraversalRecursive(root);
        System.out.println("中序遍历 (递归): " + inorderResult); // 输出: [4, 2, 5, 1, 6, 3, 7]
    }
}
```

**代码解释：**

*   **`inorderTraversalRecursive(TreeNode root)`**:  中序遍历的入口方法，与前序遍历类似。
*   **`inorderRecursiveHelper(TreeNode node, List<Integer> result)`**:  中序遍历的递归辅助方法。
    *   **`inorderRecursiveHelper(node.left, result);`**:  **递归遍历左子树** (首先遍历左子树)。
    *   **`result.add(node.val);`**:  **访问根节点** (在遍历完左子树后访问根节点)。
    *   **`inorderRecursiveHelper(node.right, result);`**:  **递归遍历右子树** (最后遍历右子树)。

**中序遍历的特点：**  对于二叉搜索树 (BST)，中序遍历的结果是一个**有序序列** (升序)。

#### 3.3 后序遍历 (Postorder Traversal)

**遍历顺序：**  **左子树 -> 右子树 -> 根节点** (Left-Right-Root)

**步骤：**

1.  递归地后序遍历左子树。
2.  递归地后序遍历右子树。
3.  访问根节点。

**Java 代码实现 (递归方式)：**

```java
package binarytree;

import java.util.ArrayList;
import java.util.List;

public class BinaryTreeTraversal {

    // ... (preorderTraversalRecursive 和 inorderTraversalRecursive 方法代码保持不变) ...

    /**
     * 后序遍历 (递归实现)
     * @param root 二叉树根节点
     * @return 后序遍历结果列表
     */
    public List<Integer> postorderTraversalRecursive(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postorderRecursiveHelper(root, result);
        return result;
    }

    private void postorderRecursiveHelper(TreeNode node, List<Integer> result) {
        if (node == null) {
            return; // 递归终止条件：节点为空
        }

        postorderRecursiveHelper(node.left, result);   // 1. 递归遍历左子树
        postorderRecursiveHelper(node.right, result);  // 2. 递归遍历右子树
        result.add(node.val);          // 3. 访问根节点 (将节点值加入结果列表)
    }

    public static void main(String[] args) {
        // ... (构建二叉树的代码保持不变) ...
        BinaryTreeTraversal traversal = new BinaryTreeTraversal();

        // ... (前序和中序遍历测试代码保持不变) ...

        // 后序遍历测试
        List<Integer> postorderResult = traversal.postorderTraversalRecursive(root);
        System.out.println("后序遍历 (递归): " + postorderResult); // 输出: [4, 5, 2, 6, 7, 3, 1]
    }
}
```

**代码解释：**

*   **`postorderTraversalRecursive(TreeNode root)`**:  后序遍历的入口方法，与前序和中序遍历类似。
*   **`postorderRecursiveHelper(TreeNode node, List<Integer> result)`**:  后序遍历的递归辅助方法。
    *   **`postorderRecursiveHelper(node.left, result);`**:  **递归遍历左子树** (首先遍历左子树)。
    *   **`postorderRecursiveHelper(node.right, result);`**:  **递归遍历右子树** (然后遍历右子树)。
    *   **`result.add(node.val);`**:  **访问根节点** (最后访问根节点)。

**后序遍历的特点：**  遍历结果的最后一个元素总是根节点的值。后序遍历常用于计算表达式树的结果，或者在删除树节点时 (先删除子节点，再删除父节点)。

#### 3.4 层序遍历 (Level Order Traversal / Breadth-First Search)

**遍历顺序：**  按照树的层次从上到下，每层从左到右依次访问节点。也称为 **广度优先搜索 (BFS)**。

**步骤：**

1.  使用**队列 (Queue)** 数据结构来辅助遍历。
2.  将根节点加入队列。
3.  当队列不为空时，执行以下操作：
    *   从队列中取出一个节点 (队首节点)，并访问它。
    *   如果该节点有左子节点，将左子节点加入队列。
    *   如果该节点有右子节点，将右子节点加入队列。
4.  重复步骤 3，直到队列为空。

**Java 代码实现 (迭代方式，使用队列)：**

```java
package binarytree;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class BinaryTreeTraversal {

    // ... (前序、中序、后序遍历的递归方法代码保持不变) ...

    /**
     * 层序遍历 (迭代实现，使用队列)
     * @param root 二叉树根节点
     * @return 层序遍历结果列表
     */
    public List<Integer> levelOrderTraversalIterative(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result; // 空树，直接返回空列表
        }

        Queue<TreeNode> queue = new LinkedList<>(); // 使用 LinkedList 实现队列
        queue.offer(root); // 1. 将根节点加入队列

        while (!queue.isEmpty()) { // 2. 当队列不为空时循环
            TreeNode currentNode = queue.poll(); // 3. 从队列中取出一个节点 (队首节点)
            result.add(currentNode.val);         //    访问节点 (将节点值加入结果列表)

            if (currentNode.left != null) {      //    如果节点有左子节点
                queue.offer(currentNode.left);    //    将左子节点加入队列
            }
            if (currentNode.right != null) {     //    如果节点有右子节点
                queue.offer(currentNode.right);   //    将右子节点加入队列
            }
        }
        return result;
    }

    public static void main(String[] args) {
        // ... (构建二叉树的代码保持不变) ...
        BinaryTreeTraversal traversal = new BinaryTreeTraversal();

        // ... (前序、中序、后序遍历测试代码保持不变) ...

        // 层序遍历测试
        List<Integer> levelOrderResult = traversal.levelOrderTraversalIterative(root);
        System.out.println("层序遍历 (迭代): " + levelOrderResult); // 输出: [1, 2, 3, 4, 5, 6, 7]
    }
}
```

**代码解释：**

*   **`levelOrderTraversalIterative(TreeNode root)`**:  层序遍历的入口方法，返回层序遍历结果列表。
*   **`if (root == null) { return result; }`**:  如果根节点为空，直接返回空列表。
*   **`Queue<TreeNode> queue = new LinkedList<>();`**:  创建一个队列 `queue`，用于辅助层序遍历。这里使用 `LinkedList` 来实现队列接口。
*   **`queue.offer(root);`**:  将根节点 `root` 加入队列。`offer()` 方法用于将元素添加到队列的末尾。
*   **`while (!queue.isEmpty()) { ... }`**:  当队列不为空时，循环执行遍历过程。`isEmpty()` 方法检查队列是否为空。
*   **`TreeNode currentNode = queue.poll();`**:  从队列中取出队首节点，赋值给 `currentNode`。`poll()` 方法用于移除并返回队列的队首元素。
*   **`result.add(currentNode.val);`**:  访问当前节点，将节点值添加到结果列表 `result` 中。
*   **`if (currentNode.left != null) { queue.offer(currentNode.left); }`**:  如果当前节点 `currentNode` 有左子节点 (`currentNode.left != null`)，则将左子节点加入队列。
*   **`if (currentNode.right != null) { queue.offer(currentNode.right); }`**:  如果当前节点 `currentNode` 有右子节点 (`currentNode.right != null`)，则将右子节点加入队列。

**层序遍历的特点：**  遍历结果是按照树的层次结构排列的，从上到下，从左到右。层序遍历常用于查找二叉树的宽度、判断是否为完全二叉树等。

**总结：**

掌握这四种基本的二叉树遍历方式非常重要。前序、中序、后序遍历主要用于深度优先的场景，例如复制树结构、表达式求值等；层序遍历适用于广度优先的场景，例如查找最短路径、按层处理节点等。

---

### 4. 二叉搜索树 (Binary Search Tree - BST)

**二叉搜索树 (Binary Search Tree - BST)**，也称为 **二叉排序树**，是一种特殊的二叉树。它不仅具备二叉树的结构特点，还具有特定的排序性质，使得在 BST 中进行查找、插入和删除等操作可以非常高效。

#### 4.1 BST 的定义和性质

**定义：**  二叉搜索树 (BST) 是一棵二叉树，它满足以下性质：

1.  **左子树性质**:  对于树中的任意节点 `node`，其左子树中的所有节点的值都小于 `node.val`。
2.  **右子树性质**:  对于树中的任意节点 `node`，其右子树中的所有节点的值都大于 `node.val`。
3.  **无重复值 (通常)**:  在标准的 BST 中，通常不允许出现值相等的节点。如果允许重复值，可以约定重复值节点放在左子树或右子树。

**示例：**

**二叉搜索树：**

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```

在这个 BST 中，你可以看到：

*   节点 8 的左子树 (以 3 为根) 中的所有节点值 (3, 1, 6, 4, 7) 都小于 8。
*   节点 8 的右子树 (以 10 为根) 中的所有节点值 (10, 14, 13) 都大于 8。
*   这个性质对树中的每个节点都成立。

**非二叉搜索树 (不满足 BST 性质)：**

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      9   7 13  // 节点 9 在节点 6 的右子树中，但 9 > 6，违反 BST 性质
```

#### 4.2 BST 的基本操作

BST 的主要优势在于它支持高效的查找、插入、删除以及获取最小值和最大值等操作。这些操作的时间复杂度在平衡的情况下可以达到 O(log n)，与树的高度成正比。

##### 4.2.1 查找 (Search)

**目标：**  在 BST 中查找给定的值 `target`。

**步骤：**

1.  从根节点开始。
2.  如果当前节点的值等于 `target`，则查找成功，返回当前节点。
3.  如果 `target` 小于当前节点的值，则在当前节点的左子树中继续查找。
4.  如果 `target` 大于当前节点的值，则在当前节点的右子树中继续查找。
5.  如果遍历到空节点 (null)，则查找失败，返回 null。

**Java 代码实现 (递归方式)：**

```java
package binarytree;

public class BinarySearchTreeOperations {

    /**
     * 在 BST 中查找值 (递归实现)
     * @param root BST 根节点
     * @param target 要查找的值
     * @return 找到的节点，如果未找到返回 null
     */
    public TreeNode searchBSTRecursive(TreeNode root, int target) {
        if (root == null || root.val == target) {
            return root; // 1. 递归终止条件：节点为空或找到目标值
        }

        if (target < root.val) {       // 3. 目标值小于当前节点值
            return searchBSTRecursive(root.left, target); // 在左子树中查找
        } else {                      // 4. 目标值大于当前节点值
            return searchBSTRecursive(root.right, target); // 在右子树中查找
        }
    }

    // ... (其他 BST 操作方法将在后面添加) ...

    public static void main(String[] args) {
        // 构建一个示例 BST
        TreeNode root = new TreeNode(8);
        root.left = new TreeNode(3);
        root.right = new TreeNode(10);
        root.left.left = new TreeNode(1);
        root.left.right = new TreeNode(6);
        root.right.right = new TreeNode(14);
        root.left.right.left = new TreeNode(4);
        root.left.right.right = new TreeNode(7);
        root.right.right.left = new TreeNode(13);

        BinarySearchTreeOperations bstOps = new BinarySearchTreeOperations();

        // 查找测试
        int targetValue = 6;
        TreeNode foundNode = bstOps.searchBSTRecursive(root, targetValue);
        if (foundNode != null) {
            System.out.println("在 BST 中找到节点，值为: " + foundNode.val); // 输出: 在 BST 中找到节点，值为: 6
        } else {
            System.out.println("在 BST 中未找到值为 " + targetValue + " 的节点");
        }

        targetValue = 9;
        foundNode = bstOps.searchBSTRecursive(root, targetValue);
        if (foundNode != null) {
            System.out.println("在 BST 中找到节点，值为: " + foundNode.val);
        } else {
            System.out.println("在 BST 中未找到值为 " + targetValue + " 的节点"); // 输出: 在 BST 中未找到值为 9 的节点
        }
    }
}
```

**代码解释：**

*   **`searchBSTRecursive(TreeNode root, int target)`**:  BST 查找的递归方法。
    *   **`if (root == null || root.val == target) { return root; }`**:  递归终止条件。
        *   `root == null`:  如果当前节点为空，表示未找到目标值，返回 `null`。
        *   `root.val == target`:  如果当前节点的值等于目标值 `target`，表示找到目标值，返回当前节点 `root`。
    *   **`if (target < root.val) { ... }`**:  如果目标值 `target` 小于当前节点的值 `root.val`，根据 BST 性质，目标值只可能在左子树中，所以递归调用 `searchBSTRecursive(root.left, target)` 在左子树中继续查找。
    *   **`else { ... }`**:  如果目标值 `target` 大于等于当前节点的值 `root.val` (这里假设没有重复值，所以是大于)，根据 BST 性质，目标值只可能在右子树中，所以递归调用 `searchBSTRecursive(root.right, target)` 在右子树中继续查找。

##### 4.2.2 插入 (Insert)

**目标：**  将一个新值 `val` 插入到 BST 中，并保持 BST 的性质。

**步骤：**

1.  从根节点开始。
2.  如果要插入的值 `val` 小于当前节点的值，则向左子树方向查找插入位置。
3.  如果要插入的值 `val` 大于当前节点的值，则向右子树方向查找插入位置。
4.  当找到一个空位置 (null) 时，将新节点插入到该位置。

**Java 代码实现 (递归方式)：**

```java
package binarytree;

public class BinarySearchTreeOperations {

    // ... (searchBSTRecursive 方法代码保持不变) ...

    /**
     * 在 BST 中插入新值 (递归实现)
     * @param root BST 根节点
     * @param val 要插入的新值
     * @return 插入后的 BST 根节点 (可能根节点会改变，例如在空树中插入第一个节点)
     */
    public TreeNode insertBSTRecursive(TreeNode root, int val) {
        if (root == null) { // 1. 如果树为空，或者找到插入位置 (空节点)
            return new TreeNode(val); // 创建新节点并返回作为子树的根
        }

        if (val < root.val) { // 2. 插入值小于当前节点值
            root.left = insertBSTRecursive(root.left, val); // 递归插入到左子树，并将返回的子树根节点设为当前节点的左子节点
        } else if (val > root.val) { // 3. 插入值大于当前节点值 (假设不允许重复值)
            root.right = insertBSTRecursive(root.right, val); // 递归插入到右子树，并将返回的子树根节点设为当前节点的右子节点
        } // 如果 val == root.val，可以根据需求选择处理方式 (例如忽略插入，或放在右子树等，这里假设忽略重复值)

        return root; // 返回当前节点 (作为子树的根节点)
    }

    public static void main(String[] args) {
        // ... (构建示例 BST 的代码保持不变) ...
        BinarySearchTreeOperations bstOps = new BinarySearchTreeOperations();

        // ... (查找测试代码保持不变) ...

        // 插入测试
        TreeNode newRoot = bstOps.insertBSTRecursive(root, 5); // 插入值 5
        System.out.println("插入值 5 后，BST 根节点仍然是: " + newRoot.val); // 输出: 插入值 5 后，BST 根节点仍然是: 8

        TreeNode foundNodeAfterInsert = bstOps.searchBSTRecursive(newRoot, 5);
        if (foundNodeAfterInsert != null) {
            System.out.println("成功插入节点，值为: " + foundNodeAfterInsert.val); // 输出: 成功插入节点，值为: 5
        } else {
            System.out.println("插入节点失败");
        }

        // 再次插入已存在的值 (例如 6，根据代码逻辑，应该会被忽略)
        TreeNode rootAfterDuplicateInsert = bstOps.insertBSTRecursive(newRoot, 6);
        System.out.println("再次插入已存在值 6 后，BST 根节点仍然是: " + rootAfterDuplicateInsert.val); // 输出: 再次插入已存在值 6 后，BST 根节点仍然是: 8
        // 检查节点 6 是否仍然存在 (应该存在且只有一个)
        int countOf6 = 0;
        // (这里为了简单起见，省略了统计节点 6 数量的代码，实际应用中可以实现一个遍历方法来统计)
        System.out.println("节点 6 在树中应该仍然存在且只有一个");
    }
}
```

**代码解释：**

*   **`insertBSTRecursive(TreeNode root, int val)`**:  BST 插入的递归方法。
    *   **`if (root == null) { return new TreeNode(val); }`**:  递归终止条件。如果当前节点 `root` 为空，表示找到了插入位置，创建一个新的 `TreeNode(val)` 对象并返回，作为当前位置的子树根节点。
    *   **`if (val < root.val) { ... }`**:  如果插入值 `val` 小于当前节点值 `root.val`，则递归调用 `insertBSTRecursive(root.left, val)` 在左子树中继续查找插入位置。并将递归调用返回的新子树根节点赋值给 `root.left`，连接到当前节点的左子节点位置。
    *   **`else if (val > root.val) { ... }`**:  如果插入值 `val` 大于当前节点值 `root.val`，则递归调用 `insertBSTRecursive(root.right, val)` 在右子树中继续查找插入位置，并将返回的新子树根节点赋值给 `root.right`。
    *   **`return root;`**:  返回当前节点 `root`，作为当前子树的根节点。在递归调用的过程中，每一层递归都会返回当前子树的根节点，最终返回的是整个 BST 的根节点 (可能根节点本身没有改变，但子树结构可能已修改)。

##### 4.2.3 删除 (Delete)

BST 的删除操作相对复杂，需要考虑多种情况以保持 BST 的性质。

**目标：**  从 BST 中删除值为 `target` 的节点，并保持 BST 的性质。

**删除节点的几种情况：**

1.  **要删除的节点是叶节点 (没有子节点)**:  直接删除该节点。
2.  **要删除的节点只有一个子节点 (左子节点或右子节点)**:  将该节点的父节点指向其子节点，然后删除该节点。
3.  **要删除的节点有两个子节点**:  这种情况比较复杂，通常有两种处理方法：
    *   **方法 1：**  找到要删除节点**右子树中的最小节点 (后继节点)**，用后继节点的值替换要删除节点的值，然后在右子树中递归删除后继节点 (此时后继节点必然是叶节点或只有一个右子节点的情况，转换为情况 1 或 2)。
    *   **方法 2：**  找到要删除节点**左子树中的最大节点 (前驱节点)**，用前驱节点的值替换要删除节点的值，然后在左子树中递归删除前驱节点 (此时前驱节点必然是叶节点或只有一个左子节点的情况，转换为情况 1 或 2)。

**Java 代码实现 (递归方式，使用后继节点方法)：**

```java
package binarytree;

public class BinarySearchTreeOperations {

    // ... (searchBSTRecursive 和 insertBSTRecursive 方法代码保持不变) ...

    /**
     * 在 BST 中删除节点 (递归实现，使用后继节点方法)
     * @param root BST 根节点
     * @param target 要删除的节点值
     * @return 删除节点后的 BST 根节点
     */
    public TreeNode deleteBSTRecursive(TreeNode root, int target) {
        if (root == null) {
            return null; // 1. 递归终止条件：树为空或未找到目标值
        }

        if (target < root.val) { // 目标值小于当前节点值
            root.left = deleteBSTRecursive(root.left, target); // 在左子树中递归删除
        } else if (target > root.val) { // 目标值大于当前节点值
            root.right = deleteBSTRecursive(root.right, target); // 在右子树中递归删除
        } else { // 找到要删除的节点 (root.val == target)
            // 情况 1: 叶节点 (没有子节点)
            if (root.left == null && root.right == null) {
                return null; // 直接删除，返回 null
            }
            // 情况 2: 只有一个子节点 (左子节点或右子节点)
            else if (root.left == null) {
                return root.right; // 用右子节点替代
            } else if (root.right == null) {
                return root.left;  // 用左子节点替代
            }
            // 情况 3: 有两个子节点 (左右子节点都存在)
            else {
                // 找到后继节点 (右子树中的最小节点)
                TreeNode successor = findMinNode(root.right);
                // 将后继节点的值复制到当前节点
                root.val = successor.val;
                // 在右子树中递归删除后继节点 (注意: 这里删除的是 successor，而不是 target 值)
                root.right = deleteBSTRecursive(root.right, successor.val);
            }
        }
        return root; // 返回当前节点 (作为子树根节点)
    }

    /**
     * 查找 BST 中最小节点 (从给定节点开始的最左子树)
     * @param node 起始节点
     * @return 最小节点
     */
    private TreeNode findMinNode(TreeNode node) {
        while (node.left != null) {
            node = node.left; // 一直向左子树方向查找，直到没有左子节点
        }
        return node; // 返回最左边的节点 (最小节点)
    }

    public static void main(String[] args) {
        // ... (构建示例 BST 的代码保持不变) ...
        BinarySearchTreeOperations bstOps = new BinarySearchTreeOperations();

        // ... (查找和插入测试代码可以保持不变) ...

        // 删除测试
        TreeNode rootAfterDelete = bstOps.deleteBSTRecursive(root, 6); // 删除节点 6 (有两个子节点的情况)
        System.out.println("删除节点 6 后，BST 根节点仍然是: " + rootAfterDelete.val); // 输出: 删除节点 6 后，BST 根节点仍然是: 8

        TreeNode searchDeletedNode = bstOps.searchBSTRecursive(rootAfterDelete, 6);
        if (searchDeletedNode == null) {
            System.out.println("成功删除节点 6"); // 输出: 成功删除节点 6
        } else {
            System.out.println("删除节点 6 失败");
        }

        TreeNode rootAfterDeleteLeaf = bstOps.deleteBSTRecursive(rootAfterDelete, 13); // 删除叶节点 13 (叶节点情况)
        System.out.println("删除叶节点 13 后，BST 根节点仍然是: " + rootAfterDeleteLeaf.val); // 输出: 删除叶节点 13 后，BST 根节点仍然是: 8
        TreeNode searchDeletedLeaf = bstOps.searchBSTRecursive(rootAfterDeleteLeaf, 13);
        if (searchDeletedLeaf == null) {
            System.out.println("成功删除叶节点 13"); // 输出: 成功删除叶节点 13
        } else {
            System.out.println("删除叶节点 13 失败");
        }

        TreeNode rootAfterDeleteOneChild = bstOps.deleteBSTRecursive(rootAfterDeleteLeaf, 10); // 删除只有一个子节点 14 的节点 10 (单子节点情况)
        System.out.println("删除节点 10 后，BST 根节点仍然是: " + rootAfterDeleteOneChild.val); // 输出: 删除节点 10 后，BST 根节点仍然是: 8
        TreeNode searchDeletedOneChild = bstOps.searchBSTRecursive(rootAfterDeleteOneChild, 10);
        if (searchDeletedOneChild == null) {
            System.out.println("成功删除节点 10"); // 输出: 成功删除节点 10
        } else {
            System.out.println("删除节点 10 失败");
        }
    }
}
```

**代码解释：**

*   **`deleteBSTRecursive(TreeNode root, int target)`**:  BST 删除节点的递归方法。
    *   **`if (root == null) { return null; }`**:  递归终止条件，如果树为空或遍历到空节点，表示未找到要删除的节点，直接返回 `null`。
    *   **`if (target < root.val) { ... }`**:  如果目标值 `target` 小于当前节点值 `root.val`，则在左子树中递归删除，并将返回的新子树根节点赋值给 `root.left`。
    *   **`else if (target > root.val) { ... }`**:  如果目标值 `target` 大于当前节点值 `root.val`，则在右子树中递归删除，并将返回的新子树根节点赋值给 `root.right`。
    *   **`else { ... }`**:  如果 `root.val == target`，表示找到了要删除的节点。
        *   **`if (root.left == null && root.right == null) { return null; }`**:  **情况 1 (叶节点)**，直接返回 `null`，相当于将父节点指向当前节点的指针设置为 `null`，从而删除节点。
        *   **`else if (root.left == null) { return root.right; }`**:  **情况 2 (只有右子节点)**，返回 `root.right`，用右子节点替代当前节点。
        *   **`else if (root.right == null) { return root.left; }`**:  **情况 2 (只有左子节点)**，返回 `root.left`，用左子节点替代当前节点。
        *   **`else { ... }`**:  **情况 3 (有两个子节点)**。
            *   **`TreeNode successor = findMinNode(root.right);`**:  调用 `findMinNode` 方法找到当前节点右子树中的最小节点 (后继节点)。
            *   **`root.val = successor.val;`**:  将后继节点的值复制到当前节点的值，相当于用后继节点的值替换了要删除节点的值。
            *   **`root.right = deleteBSTRecursive(root.right, successor.val);`**:  在当前节点的右子树中递归删除后继节点。由于后继节点是右子树中的最小节点，它不可能是情况 3 (有两个子节点)，所以这里的递归删除会简化为情况 1 或 2。
    *   **`return root;`**:  返回当前节点 `root`，作为子树的根节点。

*   **`findMinNode(TreeNode node)`**:  辅助方法，用于在给定的子树中查找最小节点 (即最左边的节点)。

##### 4.2.4 最小值和最大值 (Minimum and Maximum)

*   **最小值 (Minimum)**:  BST 中的最小值一定在**最左边的节点**。从根节点开始，一直向左子树方向遍历，直到到达没有左子节点的节点，该节点就是最小值节点。
*   **最大值 (Maximum)**:  BST 中的最大值一定在**最右边的节点**。从根节点开始，一直向右子树方向遍历，直到到达没有右子节点的节点，该节点就是最大值节点。

**Java 代码实现 (迭代方式)：**

```java
package binarytree;

public class BinarySearchTreeOperations {

    // ... (searchBSTRecursive, insertBSTRecursive, deleteBSTRecursive 方法代码保持不变) ...

    /**
     * 查找 BST 中的最小节点 (迭代实现)
     * @param root BST 根节点
     * @return 最小节点，如果树为空返回 null
     */
    public TreeNode findMinBSTIterative(TreeNode root) {
        if (root == null) {
            return null; // 空树，返回 null
        }
        TreeNode currentNode = root;
        while (currentNode.left != null) {
            currentNode = currentNode.left; // 一直向左遍历
        }
        return currentNode; // 返回最左边的节点 (最小节点)
    }

    /**
     * 查找 BST 中的最大节点 (迭代实现)
     * @param root BST 根节点
     * @return 最大节点，如果树为空返回 null
     */
    public TreeNode findMaxBSTIterative(TreeNode root) {
        if (root == null) {
            return null; // 空树，返回 null
        }
        TreeNode currentNode = root;
        while (currentNode.right != null) {
            currentNode = currentNode.right; // 一直向右遍历
        }
        return currentNode; // 返回最右边的节点 (最大节点)
    }

    public static void main(String[] args) {
        // ... (构建示例 BST 的代码保持不变) ...
        BinarySearchTreeOperations bstOps = new BinarySearchTreeOperations();

        // ... (之前的测试代码可以保持不变) ...

        // 最小值和最大值测试
        TreeNode minNode = bstOps.findMinBSTIterative(root);
        if (minNode != null) {
            System.out.println("BST 中的最小值为: " + minNode.val); // 输出: BST 中的最小值为: 1
        } else {
            System.out.println("BST 为空");
        }

        TreeNode maxNode = bstOps.findMaxBSTIterative(root);
        if (maxNode != null) {
            System.out.println("BST 中的最大值为: " + maxNode.val); // 输出: BST 中的最大值为: 14
        } else {
            System.out.println("BST 为空");
        }
    }
}
```

**代码解释：**

*   **`findMinBSTIterative(TreeNode root)`**:  迭代查找 BST 最小节点的方法.
    *   **`if (root == null) { return null; }`**:  如果根节点为空，返回 `null`。
    *   **`TreeNode currentNode = root;`**:  从根节点开始遍历。
    *   **`while (currentNode.left != null) { currentNode = currentNode.left; }`**:  循环向左子树方向移动，直到 `currentNode.left` 为 `null`，即到达最左边的节点。
    *   **`return currentNode;`**:  返回当前节点 `currentNode`，即最小节点。

*   **`findMaxBSTIterative(TreeNode root)`**:  迭代查找 BST 最大节点的方法，逻辑与 `findMinBSTIterative` 类似，只是方向变为向右子树遍历。

**总结：**

二叉搜索树 (BST) 通过其特定的排序性质，实现了高效的查找、插入、删除、最小值和最大值等操作。在实际应用中，BST 常用于需要频繁进行搜索和更新操作的场景，例如字典、索引等。但需要注意的是，如果 BST 失去平衡，可能会退化成链表，导致性能下降。为了解决这个问题，需要使用平衡二叉搜索树。

---

### 5. 平衡二叉搜索树 (Balanced BST) 简介

#### 5.1 为什么需要平衡二叉搜索树

虽然二叉搜索树 (BST) 在平均情况下查找、插入和删除操作的时间复杂度为 O(log n)，但在最坏情况下 (例如，当插入的元素是有序的，导致 BST 退化成链表时)，这些操作的时间复杂度会退化为 O(n)。

**示例：**  顺序插入 1, 2, 3, 4, 5 到 BST 中，会形成一个右倾斜的退化二叉树：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
```

在这种情况下，查找节点 5 需要遍历所有节点，时间复杂度为 O(n)，效率大大降低。

**为了解决 BST 可能退化的问题，我们需要使用平衡二叉搜索树。**  平衡二叉搜索树通过在插入和删除节点时进行一些调整操作 (例如旋转)，来保持树的平衡性，尽量减少树的高度，从而保证操作的时间复杂度始终维持在 O(log n) 级别。

#### 5.2 常见的平衡二叉搜索树类型

常见的平衡二叉搜索树主要有以下几种：

1.  **AVL 树 (Adelson-Velsky and Landis Tree)**:  最早被发明的自平衡二叉搜索树。AVL 树严格要求每个节点的左右子树高度差的绝对值不超过 1。为了维持平衡，AVL 树在插入和删除节点时，会进行复杂的旋转操作 (单旋转、双旋转)。AVL 树的平衡性非常好，查找效率很高，但维护平衡的代价也比较大，插入和删除操作相对较慢。
2.  **红黑树 (Red-Black Tree)**:  一种应用更广泛的平衡二叉搜索树。红黑树通过对节点进行着色 (红色或黑色) 并引入一些规则，来维持树的近似平衡。红黑树的平衡性不如 AVL 树严格，但维护平衡的代价较低，插入和删除操作的性能相对较好。红黑树在 Java 的 `TreeMap` 和 `TreeSet`，C++ 的 `map` 和 `set` 等数据结构中被广泛使用。
3.  **B 树 (B-Tree) 和 B+ 树 (B+ Tree)**:  主要用于外部存储系统 (例如数据库索引、文件系统)。B 树和 B+ 树是多路搜索树，一个节点可以有多个子节点，可以有效减少磁盘 I/O 次数，提高数据访问效率。B+ 树是 B 树的变种，更适合用于数据库索引。

**平衡二叉搜索树的特点：**

*   **自平衡性**:  能够在插入和删除节点时自动调整树结构，保持树的平衡。
*   **高效性能**:  保证查找、插入、删除等操作的时间复杂度在 O(log n) 级别。
*   **实现复杂性**:  平衡树的实现通常比较复杂，需要考虑各种平衡调整策略和旋转操作。

**选择平衡树的考虑：**

*   **查找频率**:  如果应用场景以查找操作为主，对插入和删除操作的性能要求不高，可以选择 AVL 树，因为 AVL 树的查找效率更高。
*   **插入和删除频率**:  如果应用场景插入和删除操作比较频繁，可以选择红黑树，因为红黑树在插入和删除操作方面性能更均衡。
*   **数据量和存储介质**:  对于大数据量存储在磁盘等外部存储介质的应用，应该选择 B 树或 B+ 树，以减少磁盘 I/O。

**总结：**

平衡二叉搜索树是为了解决普通 BST 可能退化成链表的问题而提出的。通过维持树的平衡性，平衡树能够保证高效的性能，在实际应用中非常重要。常见的平衡树类型包括 AVL 树、红黑树、B 树和 B+ 树，每种树类型都有其适用的场景。

---

### 6. 二叉树的应用场景

二叉树作为一种重要的数据结构，在计算机科学和实际应用中有着广泛的应用。以下是一些常见的二叉树应用场景：

#### 6.1 表达式树 (Expression Tree)

**定义：**  表达式树是一种特殊的二叉树，用于表示数学表达式。

*   **叶节点**:  表示操作数 (operand)，例如数字或变量。
*   **非叶节点**:  表示操作符 (operator)，例如 +, -, \*, / 等。

**示例：**  表达式 `(a + b) * c` 的表达式树：

```
        *
       / \
      +   c
     / \
    a   b
```

**表达式树的用途：**

*   **表达式求值**:  可以通过后序遍历表达式树来计算表达式的值。后序遍历的顺序是：左子树 -> 右子树 -> 根节点。当遍历到操作符节点时，从栈中弹出两个操作数进行运算，并将结果压入栈中。
*   **表达式转换**:  可以通过不同的遍历方式将表达式树转换为前缀表达式 (前序遍历)、中缀表达式 (中序遍历，需要加括号) 和后缀表达式 (后序遍历)。

**表达式求值 (后序遍历)：**

对于上面的表达式树 `(a + b) * c`，假设 `a=2, b=3, c=4`，后序遍历顺序为：`a, b, +, c, *`。

1.  遍历到 `a` (操作数 2)，入栈：`[2]`
2.  遍历到 `b` (操作数 3)，入栈：`[2, 3]`
3.  遍历到 `+` (操作符)，弹出栈顶两个元素 3 和 2，计算 `2 + 3 = 5`，结果 5 入栈：`[5]`
4.  遍历到 `c` (操作数 4)，入栈：`[5, 4]`
5.  遍历到 `*` (操作符)，弹出栈顶两个元素 4 和 5，计算 `5 * 4 = 20`，结果 20 入栈：`[20]`

遍历结束，栈中唯一元素 20 就是表达式 `(a + b) * c` 的值。

#### 6.2 哈夫曼树 (Huffman Tree)

**定义：**  哈夫曼树是一种特殊的二叉树，也称为**最优二叉树**，用于数据压缩中的哈夫曼编码。

**构建过程：**

1.  统计每个字符在文本中出现的频率。
2.  将每个字符作为一个叶节点，频率作为节点的权重。
3.  每次从森林中选取两个权重最小的树 (或节点) 合并成一棵新树，新树的根节点权重为两个子树权重之和。
4.  重复步骤 3，直到森林中只剩下一棵树，这棵树就是哈夫曼树。
5.  给哈夫曼树的边分配编码：通常左分支为 0，右分支为 1。从根节点到每个叶节点的路径上的边编码序列就是该叶节点对应字符的哈夫曼编码。

**哈夫曼树的用途：**

*   **数据压缩 (哈夫曼编码)**:  哈夫曼编码是一种变长编码，频率高的字符使用较短的编码，频率低的字符使用较长的编码，从而达到数据压缩的目的。哈夫曼编码是前缀码，即任何一个字符的编码都不是另一个字符编码的前缀，避免了解码时的歧义。

**示例：**  字符频率：`a: 5, b: 2, c: 3, d: 8`

1.  初始森林：`{a(5), b(2), c(3), d(8)}`
2.  合并 `b(2)` 和 `c(3)`，得到新树 `T1(5)`，森林变为：`{a(5), d(8), T1(5)}`
3.  合并 `a(5)` 和 `T1(5)`，得到新树 `T2(10)`，森林变为：`{d(8), T2(10)}`
4.  合并 `d(8)` 和 `T2(10)`，得到哈夫曼树 `T3(18)`，森林只剩 `T3`。

哈夫曼树 `T3` (假设左分支编码为 0，右分支编码为 1)：

```
         T3(18)
        /      \
       0        1
    d(8)       T2(10)
              /     \
             0       1
          T1(5)    a(5)
         /   \
        0     1
     b(2)    c(3)
```

哈夫曼编码：`a: 11, b: 100, c: 101, d: 0`

#### 6.3 决策树 (Decision Tree)

**定义：**  决策树是一种树状的分类或回归模型。在决策树中，每个内部节点表示一个特征或属性的测试条件，每个分支代表测试输出，每个叶节点代表一个类别或预测值。

**构建过程：**  决策树的构建是一个递归过程，通常采用贪心策略，每次选择最优的特征进行分裂，例如使用信息增益、基尼系数等指标来评估特征的优劣。

**决策树的用途：**

*   **分类**:  根据输入特征对数据进行分类，例如预测用户是否会购买某种商品、判断邮件是否为垃圾邮件等。
*   **回归**:  预测连续型的数值输出，例如预测房价、股票价格等。
*   **规则提取**:  决策树模型具有良好的可解释性，可以从树结构中提取出易于理解的分类或回归规则。

**示例：**  根据天气情况判断是否适合打网球的决策树 (简化示例)：

```
          天气
        /     \
     晴朗      阴天/雨天
    /   \        \
湿度高  湿度低    适合打网球
  /     \
不适合  适合
```

#### 6.4 文件系统目录结构

文件系统目录结构天然地可以用树形结构来表示。

*   **目录 (文件夹)**:  可以看作树的非叶节点，可以包含子目录和文件。
*   **文件**:  可以看作树的叶节点，存储实际的数据。
*   **根目录**:  文件系统的根节点，例如 Windows 的盘符 (C:, D: 等) 或 Linux 的 `/` 目录。

**文件系统目录结构的用途：**

*   **组织和管理文件**:  树形结构使得文件组织和管理更加清晰和有序，方便用户查找和访问文件。
*   **路径表示**:  可以使用路径 (例如 `/home/user/documents/file.txt` 或 `C:\Users\Public\Documents\example.docx`) 来唯一标识文件或目录在文件系统中的位置。
*   **权限管理**:  可以基于目录结构进行权限管理，例如设置不同用户对不同目录的访问权限。

#### 6.5 数据库索引 (B-Tree, B+ Tree - 概念联系)

数据库索引是为了加速数据检索而创建的特殊数据结构。B 树和 B+ 树是常用的数据库索引结构。

**B 树和 B+ 树的特点：**

*   **多路搜索树**:  一个节点可以有多个子节点，减少树的高度，从而减少磁盘 I/O 次数。
*   **平衡性**:  保持树的平衡，保证查询性能稳定。
*   **磁盘友好**:  专门为磁盘存储设计，优化了磁盘读写操作。

**B 树和 B+ 树在数据库索引中的用途：**

*   **加速数据检索**:  通过索引可以快速定位到数据在磁盘上的位置，避免全表扫描，大大提高查询效率。
*   **范围查询优化**:  B+ 树特别适合范围查询，因为所有叶节点通过链表连接在一起，方便顺序遍历。
*   **排序**:  索引本身就是有序的，可以支持排序操作。

**与二叉树的联系：**

B 树和 B+ 树虽然是多路搜索树，但它们的核心思想仍然是基于树形结构的搜索和排序。可以把 B 树和 B+ 树看作是二叉搜索树的扩展和优化，使其更适合处理大规模数据和磁盘存储的场景。

**总结：**

二叉树的应用非常广泛，从数据压缩到人工智能，从文件系统到数据库索引，都能看到二叉树的身影。理解二叉树的原理和特性，能够帮助我们更好地解决实际问题，设计高效的算法和系统。

---

### 7. 总结

恭喜你，已经完成了二叉树的全面学习！我们回顾一下本文涵盖的主要知识点：

1.  **什么是树和二叉树**:  了解了树的基本概念，以及二叉树的定义、特点和节点结构。
2.  **二叉树的类型**:  学习了满二叉树、完全二叉树、完美二叉树、退化二叉树和平衡二叉树等不同类型的二叉树及其特点。
3.  **二叉树的遍历**:  掌握了前序遍历、中序遍历、后序遍历和层序遍历四种基本的二叉树遍历方式 (递归和迭代实现)。
4.  **二叉搜索树 (BST)**:  深入学习了 BST 的定义、性质以及查找、插入、删除、最小值、最大值等基本操作 (递归和迭代实现)。
5.  **平衡二叉搜索树 (Balanced BST) 简介**:  了解了平衡 BST 的必要性，以及 AVL 树、红黑树、B 树和 B+ 树等常见的平衡树类型。
6.  **二叉树的应用场景**:  探讨了二叉树在表达式树、哈夫曼树、决策树、文件系统目录结构和数据库索引等方面的广泛应用。

**二叉树的重要性：**

*   **基础数据结构**:  二叉树是计算机科学中最基本、最重要的数据结构之一。
*   **算法基石**:  许多高级算法和数据结构都建立在二叉树的基础上，例如平衡树、堆、图算法等。
*   **应用广泛**:  二叉树在各个领域都有广泛的应用，从系统软件到应用软件，从数据压缩到人工智能，都离不开二叉树的支持。

**学习建议：**

*   **多练习**:  通过 LeetCode 等平台上的二叉树相关题目进行练习，加深对二叉树的理解和应用能力。
*   **动手实现**:  尝试自己实现各种二叉树操作，例如遍历、BST 操作、平衡树等，加深理解细节。
*   **拓展学习**:  进一步学习平衡树 (AVL 树、红黑树)、堆、图等更高级的数据结构和算法。

希望这篇详细的二叉树讲解能够帮助你系统地学习和掌握二叉树的相关知识。如果你有任何问题或疑问，欢迎随时提出！








## 力扣144. 二叉树的前序遍历

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

 

示例 1：

输入：root = [1,null,2,3]

输出：[1,2,3]

解释：



示例 2：

输入：root = [1,2,3,4,5,null,8,null,null,6,7,9]

输出：[1,2,4,5,6,7,3,8,9]

解释：



示例 3：

输入：root = []

输出：[]

示例 4：

输入：root = [1]

输出：[1]




### 递归法，无注释

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {


    public void Traversal( TreeNode root, List<Integer> list ) {

        if( root == null ){
            return ;
        }

        list.add( root.val );
        Traversal( root.left, list );
        Traversal( root.right, list );


    }



    public List<Integer> preorderTraversal(TreeNode root) {


        List<Integer> list = new ArrayList();

        Traversal( root, list );

        return list;

    }


}

```





### 递归法，有注释

在我的代码中嵌入详细注释说明，使其易于理解



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    /**
     * 辅助函数：递归地遍历二叉树的节点并将其值添加到列表中 (前序遍历)
     *
     * @param root 当前遍历到的节点 (子树的根节点)
     * @param list 用于存储遍历结果的列表，存储节点的值 (Integer 类型)
     *
     * 前序遍历的顺序是： 根节点 -> 左子树 -> 右子树
     */
    public void Traversal( TreeNode root, List<Integer> list ) {

        // 递归终止条件：当遍历到的节点为空 (null) 时，说明已经到达了叶子节点的子节点，或者树本身为空，此时结束递归
        if( root == null ){
            return ; // 结束当前递归调用
        }

        // 前序遍历的第一个操作：访问根节点
        // 将当前节点的值 (root.val) 添加到 list 列表中
        list.add( root.val );

        // 前序遍历的第二个操作：递归遍历左子树
        // 调用 Traversal 函数，传入当前节点的左子节点 (root.left) 和 list 列表
        // 递归会先深入到左子树的最左边，直到左子树为空
        Traversal( root.left, list );

        // 前序遍历的第三个操作：递归遍历右子树
        // 当左子树遍历完成后，调用 Traversal 函数，传入当前节点的右子节点 (root.right) 和 list 列表
        // 递归会遍历右子树的节点
        Traversal( root.right, list );


    }


    /**
     * 主函数：实现二叉树的前序遍历，并返回节点值的列表
     *
     * @param root 二叉树的根节点
     * @return 存储二叉树前序遍历结果的列表 (List<Integer>)
     */
    public List<Integer> preorderTraversal(TreeNode root) {

        // 创建一个新的 ArrayList 来存储前序遍历的结果
        // 使用 ArrayList 是因为它可以动态扩容，并且方便添加元素
        List<Integer> list = new ArrayList();

        // 调用辅助函数 Traversal 来执行实际的前序遍历过程
        // 将根节点 (root) 和结果列表 (list) 传递给 Traversal 函数
        Traversal( root, list );

        // Traversal 函数执行完成后，list 列表中就包含了二叉树的前序遍历结果
        // 返回这个 list 列表
        return list;

    }


}
```







---




## 力扣94. 二叉树的中序遍历


给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。

 

示例 1：


输入：root = [1,null,2,3]
输出：[1,3,2]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]
 

提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100






### 递归法，无注释


```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public void Traversal( TreeNode root, List<Integer> list ) {

        if( root == null ){
            return ;
        }

        
        Traversal( root.left, list );
        list.add( root.val );
        Traversal( root.right, list );


    }


    public List<Integer> inorderTraversal(TreeNode root) {



        List<Integer> list = new ArrayList();

        Traversal( root, list );

        return list;
        
    }
}

```










### 递归法，有注释


```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;         // 节点的值
 *     TreeNode left;    // 指向左子节点的引用，指向左子树的根节点
 *     TreeNode right;   // 指向右子节点的引用，指向右子树的根节点
 *     TreeNode() {}     // 无参构造函数，用于创建空节点 (虽然在二叉树遍历中不常用，但 TreeNode 类定义中可能有)
 *     TreeNode(int val) { this.val = val; } // 构造函数，只初始化节点的值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 构造函数，初始化节点的值以及左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    /**
     * 辅助函数：递归地遍历二叉树的节点并将其值添加到列表中 (中序遍历)
     *
     * @param root 当前遍历到的节点 (子树的根节点)
     * @param list 用于存储遍历结果的列表，存储节点的值 (Integer 类型)
     *
     * 中序遍历的顺序是： 左子树 -> 根节点 -> 右子树
     */
    public void Traversal( TreeNode root, List<Integer> list ) {

        // 递归终止条件：当遍历到的节点为空 (null) 时，说明已经到达了叶子节点的子节点，或者树本身为空，此时结束递归
        if( root == null ){
            return ; // 结束当前递归调用，直接返回到上一层调用
        }

        // 中序遍历的第一个操作：递归遍历左子树
        // 调用 Traversal 函数自身，传入当前节点的左子节点 (root.left) 和 list 列表
        // 递归会持续向左子树深入，直到到达最左边的叶子节点或空节点
        Traversal( root.left, list );

        // 中序遍历的第二个操作：访问根节点
        // 当左子树遍历完成后，访问当前节点 (根节点)
        // 将当前节点的值 (root.val) 添加到 list 列表中
        list.add( root.val );

        // 中序遍历的第三个操作：递归遍历右子树
        // 当根节点访问完成后，递归遍历右子树
        // 调用 Traversal 函数自身，传入当前节点的右子节点 (root.right) 和 list 列表
        // 递归会遍历右子树的所有节点
        Traversal( root.right, list );


    }


    /**
     * 主函数：实现二叉树的中序遍历，并返回节点值的列表
     *
     * @param root 二叉树的根节点
     * @return 存储二叉树中序遍历结果的列表 (List<Integer>)
     */
    public List<Integer> inorderTraversal(TreeNode root) {

        // 创建一个新的 ArrayList 来存储中序遍历的结果
        // ArrayList 是一种动态数组，适合用于存储遍历结果，可以方便地添加元素
        List<Integer> list = new ArrayList();

        // 调用辅助函数 Traversal 来执行实际的中序遍历过程
        // 将二叉树的根节点 (root) 和创建的空列表 (list) 传递给 Traversal 函数
        Traversal( root, list );

        // Traversal 函数执行完成后，list 列表中就包含了二叉树的中序遍历结果
        // 函数最终返回这个包含遍历结果的 list 列表
        return list;

    }
}



```
















## 力扣145. 二叉树的后序遍历


给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

 

示例 1：

输入：root = [1,null,2,3]

输出：[3,2,1]

解释：



示例 2：

输入：root = [1,2,3,4,5,null,8,null,null,6,7,9]

输出：[4,6,7,5,2,9,8,3,1]

解释：



示例 3：

输入：root = []

输出：[]

示例 4：

输入：root = [1]

输出：[1]

 

提示：

树中节点的数目在范围 [0, 100] 内
-100 <= Node.val <= 100






### 递归法，无注释


```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public void Traversal( TreeNode root, List<Integer> list ) {

        if( root == null ){
            return ;
        }

        
        Traversal( root.left, list );
        Traversal( root.right, list );
        list.add( root.val );


    }


    public List<Integer> postorderTraversal(TreeNode root) {


        List<Integer> list = new ArrayList();

        Traversal( root, list );

        return list;
        
    }
}


```






### 递归法，有注释



```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;         // 节点的值
 *     TreeNode left;    // 指向左子节点的引用
 *     TreeNode right;   // 指向右子节点的引用
 *     TreeNode() {}     // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 构造函数，用于初始化节点值以及左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    /**
     * 辅助函数：递归地遍历二叉树的节点并将其值添加到列表中 (后序遍历)
     *
     * @param root 当前遍历到的节点 (子树的根节点)
     * @param list 用于存储遍历结果的列表，存储节点的值 (Integer 类型)
     *
     * 后序遍历的顺序是： 左子树 -> 右子树 -> 根节点
     */
    public void Traversal( TreeNode root, List<Integer> list ) {

        // 递归终止条件：当遍历到的节点为空 (null) 时，说明已经到达了叶子节点的子节点，或者树本身为空，此时结束递归
        if( root == null ){
            return ; // 结束当前递归调用，返回上一层函数
        }

        // 后序遍历的第一个操作：递归遍历左子树
        // 调用 Traversal 函数，传入当前节点的左子节点 (root.left) 和 list 列表
        // 递归会先深入到左子树的最左边，直到左子树为空，完成整个左子树的遍历
        Traversal( root.left, list );

        // 后序遍历的第二个操作：递归遍历右子树
        // 当左子树遍历完成后，调用 Traversal 函数，传入当前节点的右子节点 (root.right) 和 list 列表
        // 递归会遍历右子树的节点，同样会先深入到右子树的最左边，完成整个右子树的遍历
        Traversal( root.right, list );

        // 后序遍历的第三个操作：访问根节点
        // 当左右子树都遍历完成后，才访问根节点
        // 将当前节点的值 (root.val) 添加到 list 列表中
        list.add( root.val );


    }


    /**
     * 主函数：实现二叉树的后序遍历，并返回节点值的列表
     *
     * @param root 二叉树的根节点
     * @return 存储二叉树后序遍历结果的列表 (List<Integer>)
     */
    public List<Integer> postorderTraversal(TreeNode root) {

        // 创建一个新的 ArrayList 来存储后序遍历的结果
        // 使用 ArrayList 是因为它可以动态扩容，并且方便添加元素
        List<Integer> list = new ArrayList();

        // 调用辅助函数 Traversal 来执行实际的后序遍历过程
        // 将根节点 (root) 和结果列表 (list) 传递给 Traversal 函数
        Traversal( root, list );

        // Traversal 函数执行完成后，list 列表中就包含了二叉树的后序遍历结果
        // 返回这个 list 列表
        return list;

    }
}



```




---




## 力扣102. 二叉树的层序遍历



给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
示例 2：

输入：root = [1]
输出：[[1]]
示例 3：

输入：root = []
输出：[]
 

提示：

树中节点数目在范围 [0, 2000] 内
-1000 <= Node.val <= 1000




### BFS--迭代方式--借助队列，无注释。学自代码随想录。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {


        Queue<TreeNode> que = new LinkedList<TreeNode>();

        List<List<Integer>> rets = new LinkedList();

        if( root == null ) {

            return rets;
        }

        que.offer(root);

        
        while( !que.isEmpty() ) {


            int size = que.size();

            List<Integer> linelist = new LinkedList(); 



            for( int i=0; i < size; i++ ) {




                TreeNode node = new TreeNode();

                node = que.poll();

                linelist.add( node.val );


                if( node.left != null ) {

                    que.offer( node.left );

                }

                if( node.right != null ) {

                    que.offer( node.right );
                    
                }



            }


            rets.add( linelist );



        }


        return rets;

        
    }
}


```




### BFS--迭代方式--借助队列，注释版。学自代码随想录。

在我的代码中嵌入详细注释说明，使其易于理解和复习



```java
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;         // 节点的值
 *     TreeNode left;    // 指向左子节点的引用
 *     TreeNode right;   // 指向右子节点的引用
 *     TreeNode() {}     // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 构造函数，用于初始化节点值以及左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 实现二叉树的层序遍历 (Level Order Traversal)
     *
     * @param root 二叉树的根节点
     * @return List<List<Integer>> 返回层序遍历的结果，每一层节点值存储在一个List<Integer>中，
     *         所有层的List<Integer>再组成一个 List<List<Integer>>
     */
    public List<List<Integer>> levelOrder(TreeNode root) {

        // 创建一个队列 (Queue) 用于辅助层序遍历。队列的特点是先进先出 (FIFO)。
        // 这里使用 LinkedList 来实现 Queue 接口，因为 LinkedList 实现了 Queue 接口，并且在队列操作中效率较高。
        Queue<TreeNode> que = new LinkedList<>();

        // 创建一个 List<List<Integer>> 类型的列表 rets (results 的缩写)，用于存储最终的层序遍历结果。
        // 外层的 List 存储每一层的节点值列表，内层的 List<Integer> 存储每一层节点的具体值。
        List<List<Integer>> rets = new LinkedList<>(); // 建议显式指定泛型类型： LinkedList<List<Integer>>()

        // 如果根节点 root 为 null，表示是空树，直接返回空的结果列表 rets。
        if (root == null) {
            return rets; // 空树的层序遍历结果为空列表
        }

        // 如果根节点不为空，首先将根节点加入队列。层序遍历从根节点开始。
        que.offer(root);

        // 当队列不为空时，循环进行层序遍历。
        // 队列为空时，表示所有层级的节点都已遍历完成。
        while (!que.isEmpty()) {
            // size 变量记录当前队列的长度，这个长度代表了当前层级的节点数量。
            int size = que.size();

            // 创建一个新的 List<Integer> 类型的列表 linelist (line list 的缩写)，用于存储当前层级的节点值。
            List<Integer> linelist = new LinkedList<>(); // 建议显式指定泛型类型： LinkedList<Integer>()

            // 使用 for 循环遍历当前层级的所有节点。循环次数为当前层级的节点数量 size。
            for (int i = 0; i < size; i++) {
                // 从队列中取出一个节点 (队首元素)。`que.poll()` 方法会移除并返回队列的头部元素。
                // TreeNode node = new TreeNode(); // 这行代码是多余的，不需要在这里创建新的 TreeNode 对象。
                // node = que.poll();           // 直接将 poll() 的结果赋值给 node 即可。
                TreeNode node = que.poll(); // 从队列中取出一个节点

                // 将取出的节点的值 (node.val) 添加到当前层级的列表 linelist 中。
                linelist.add(node.val);

                // 检查当前节点的左子节点是否存在。如果存在，则将左子节点加入队列。
                // 左子节点是下一层级的节点，加入队列后会在后续的循环中被遍历到。
                if (node.left != null) {
                    que.offer(node.left); // 将左子节点加入队列
                }

                // 检查当前节点的右子节点是否存在。如果存在，则将右子节点加入队列。
                // 右子节点同样是下一层级的节点，加入队列后会在后续的循环中被遍历到。
                if (node.right != null) {
                    que.offer(node.right); // 将右子节点加入队列
                }
            }

            // 当 for 循环结束后，表示当前层级的所有节点都已遍历完成，并且它们的节点值都存储在了 linelist 中。
            // 将存储了当前层级节点值的列表 linelist 添加到最终的结果列表 rets 中。
            rets.add(linelist); // 将当前层级的节点值列表添加到结果列表中
        }

        // while 循环结束后，表示所有层级的节点都已遍历完成。
        // 此时 rets 列表包含了二叉树的层序遍历结果，每一层级的节点值都存储在 rets 的一个子列表中。
        return rets; // 返回层序遍历的结果列表
    }
}
```

**代码改进和注释说明：**

1.  **显式泛型类型**: 在创建 `LinkedList` 时，建议显式指定泛型类型，例如 `new LinkedList<List<Integer>>()` 和 `new LinkedList<Integer>()`，这样代码更清晰易懂。
2.  **去除冗余代码**:  移除了 `TreeNode node = new TreeNode();` 和 `node = que.poll();` 两行代码，直接使用 `TreeNode node = que.poll();` 即可，避免了创建不必要的对象。
3.  **详细注释**:  在代码的关键部分添加了详细的注释，解释了代码的逻辑、变量的作用以及层序遍历的步骤，方便理解和复习。

修改后的代码在逻辑上与原代码相同，但更加清晰、高效，并且注释更加完善，有助于理解层序遍历的实现过程。













---




## 力扣107. 二叉树的层序遍历 II


给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
示例 2：

输入：root = [1]
输出：[[1]]
示例 3：

输入：root = []
输出：[]
 

提示：

树中节点数目在范围 [0, 2000] 内
-1000 <= Node.val <= 1000







### BFS--迭代方式--借助队列，无注释




```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {




        Queue<TreeNode> que = new LinkedList<TreeNode>();

        List<List<Integer>> rets = new LinkedList();

        if( root == null ) {

            return rets;
        }

        que.offer(root);

        
        while( !que.isEmpty() ) {


            int size = que.size();

            List<Integer> linelist = new LinkedList(); 



            for( int i=0; i < size; i++ ) {




                TreeNode node = new TreeNode();

                node = que.poll();

                linelist.add( node.val );


                if( node.left != null ) {

                    que.offer( node.left );

                }

                if( node.right != null ) {

                    que.offer( node.right );
                    
                }



            }


            rets.addFirst( linelist );
            /**102. 二叉树的层序遍历的变体，仅修改本行即可。
            addFirst(E element) / offerFirst(E element): 在链表头部添加元素。
            使得先遍历的树上层的存放靠近链表尾部，后遍历的下层的存放靠近链表头部。
            最终rets中呈现[树底层->树高层]。  
             */ 



        }


        return rets;



        
    }
}

```






### BFS--迭代方式--借助队列，有注释



```java
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;         // 节点的值
 *     TreeNode left;    // 指向左子节点的引用
 *     TreeNode right;   // 指向右子节点的引用
 *     TreeNode() {}     // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 构造函数，用于初始化节点值以及左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 实现二叉树的层序遍历 (Level Order Traversal)
     *
     * @param root 二叉树的根节点
     * @return List<List<Integer>> 返回层序遍历的结果，每一层节点值存储在一个List<Integer>中，
     *         所有层的List<Integer>再组成一个 List<List<Integer>>
     */
    public List<List<Integer>> levelOrderBottom(TreeNode root) {

        // 创建一个队列 (Queue) 用于辅助层序遍历。队列的特点是先进先出 (FIFO)。
        // 这里使用 LinkedList 来实现 Queue 接口，因为 LinkedList 实现了 Queue 接口，并且在队列操作中效率较高。
        Queue<TreeNode> que = new LinkedList<>();

        // 创建一个 List<List<Integer>> 类型的列表 rets (results 的缩写)，用于存储最终的层序遍历结果。
        // 外层的 List 存储每一层的节点值列表，内层的 List<Integer> 存储每一层节点的具体值。
        List<List<Integer>> rets = new LinkedList<>(); // 建议显式指定泛型类型： LinkedList<List<Integer>>()

        // 如果根节点 root 为 null，表示是空树，直接返回空的结果列表 rets。
        if (root == null) {
            return rets; // 空树的层序遍历结果为空列表
        }

        // 如果根节点不为空，首先将根节点加入队列。层序遍历从根节点开始。
        que.offer(root);

        // 当队列不为空时，循环进行层序遍历。
        // 队列为空时，表示所有层级的节点都已遍历完成。
        while (!que.isEmpty()) {
            // size 变量记录当前队列的长度，这个长度代表了当前层级的节点数量。
            int size = que.size();

            // 创建一个新的 List<Integer> 类型的列表 linelist (line list 的缩写)，用于存储当前层级的节点值。
            List<Integer> linelist = new LinkedList<>(); // 建议显式指定泛型类型： LinkedList<Integer>()

            // 使用 for 循环遍历当前层级的所有节点。循环次数为当前层级的节点数量 size。
            for (int i = 0; i < size; i++) {
                // 从队列中取出一个节点 (队首元素)。`que.poll()` 方法会移除并返回队列的头部元素。
                // TreeNode node = new TreeNode(); // 这行代码是多余的，不需要在这里创建新的 TreeNode 对象。
                // node = que.poll();           // 直接将 poll() 的结果赋值给 node 即可。
                TreeNode node = que.poll(); // 从队列中取出一个节点

                // 将取出的节点的值 (node.val) 添加到当前层级的列表 linelist 中。
                linelist.add(node.val);

                // 检查当前节点的左子节点是否存在。如果存在，则将左子节点加入队列。
                // 左子节点是下一层级的节点，加入队列后会在后续的循环中被遍历到。
                if (node.left != null) {
                    que.offer(node.left); // 将左子节点加入队列
                }

                // 检查当前节点的右子节点是否存在。如果存在，则将右子节点加入队列。
                // 右子节点同样是下一层级的节点，加入队列后会在后续的循环中被遍历到。
                if (node.right != null) {
                    que.offer(node.right); // 将右子节点加入队列
                }
            }

            // 当 for 循环结束后，表示当前层级的所有节点都已遍历完成，并且它们的节点值都存储在了 linelist 中。
            // 将存储了当前层级节点值的列表 linelist 添加到最终的结果列表 rets 中。
            rets.addFirst( linelist );
            /**102. 二叉树的层序遍历的变体，仅修改本行即可。
            addFirst(E element) / offerFirst(E element): 在链表头部添加元素。
            使得先遍历的树上层的存放靠近链表尾部，后遍历的下层的存放靠近链表头部。
            最终rets中呈现[树底层->树高层]。  
             */ 

        }

        // while 循环结束后，表示所有层级的节点都已遍历完成。
        // 此时 rets 列表包含了二叉树的层序遍历结果，每一层级的节点值都存储在 rets 的一个子列表中。
        return rets; // 返回层序遍历的结果列表
    }
}

```








---







## 力扣199. 二叉树的右视图


给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

示例 1：

输入：root = [1,2,3,null,5,null,4]

输出：[1,3,4]

解释：



示例 2：

输入：root = [1,2,3,4,null,null,null,5]

输出：[1,3,4,5]

解释：



示例 3：

输入：root = [1,null,3]

输出：[1,3]

示例 4：

输入：root = []

输出：[]

 

提示:

二叉树的节点个数的范围是 [0,100]
-100 <= Node.val <= 100 






### BFS--迭代方式--借助队列，无注释


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {

        Queue<TreeNode> que = new LinkedList<TreeNode>();

        List<Integer> rets = new LinkedList();
        /**102. 二叉树的层序遍历变体
        将树的每一层的最右边结点的值即linelist的尾部元素添加到结果列表rets即可
        */ 

        if( root == null ) {

            return rets;
        }

        que.offer(root);

        
        while( !que.isEmpty() ) {


            int size = que.size();

            List<Integer> linelist = new LinkedList(); 



            for( int i=0; i < size; i++ ) {




                TreeNode node = new TreeNode();

                node = que.poll();

                linelist.add( node.val );


                if( node.left != null ) {

                    que.offer( node.left );

                }

                if( node.right != null ) {

                    que.offer( node.right );
                    
                }



            }


            rets.add( linelist.getLast() );
            /**102. 二叉树的层序遍历变体
            将树的每一层的最右边结点的值即linelist的尾部元素添加到结果列表rets即可
            */ 



        }


        return rets;


        
    }
}


```











### BFS--迭代方式--借助队列，有注释


```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {

        // 创建一个队列 (Queue) 用于辅助层序遍历。队列的特点是先进先出 (FIFO)。
        // 这里使用 LinkedList 来实现 Queue 接口，因为 LinkedList 实现了 Queue 接口，并且在队列操作中效率较高。
        Queue<TreeNode> que = new LinkedList<>();

        List<Integer> rets = new LinkedList();
        /**102. 二叉树的层序遍历变体
        将树的每一层的最右边结点的值即linelist的尾部元素添加到结果列表rets即可
        */ 

        // 如果根节点 root 为 null，表示是空树，直接返回空的结果列表 rets。
        if (root == null) {
            return rets; // 空树的层序遍历结果为空列表
        }

        // 如果根节点不为空，首先将根节点加入队列。层序遍历从根节点开始。
        que.offer(root);

        // 当队列不为空时，循环进行层序遍历。
        // 队列为空时，表示所有层级的节点都已遍历完成。
        while (!que.isEmpty()) {
            // size 变量记录当前队列的长度，这个长度代表了当前层级的节点数量。
            int size = que.size();

            // 创建一个新的 List<Integer> 类型的列表 linelist (line list 的缩写)，用于存储当前层级的节点值。
            List<Integer> linelist = new LinkedList<>(); // 建议显式指定泛型类型： LinkedList<Integer>()

            // 使用 for 循环遍历当前层级的所有节点。循环次数为当前层级的节点数量 size。
            for (int i = 0; i < size; i++) {
                // 从队列中取出一个节点 (队首元素)。`que.poll()` 方法会移除并返回队列的头部元素。
                // TreeNode node = new TreeNode(); // 这行代码是多余的，不需要在这里创建新的 TreeNode 对象。
                // node = que.poll();           // 直接将 poll() 的结果赋值给 node 即可。
                TreeNode node = que.poll(); // 从队列中取出一个节点

                // 将取出的节点的值 (node.val) 添加到当前层级的列表 linelist 中。
                linelist.add(node.val);

                // 检查当前节点的左子节点是否存在。如果存在，则将左子节点加入队列。
                // 左子节点是下一层级的节点，加入队列后会在后续的循环中被遍历到。
                if (node.left != null) {
                    que.offer(node.left); // 将左子节点加入队列
                }

                // 检查当前节点的右子节点是否存在。如果存在，则将右子节点加入队列。
                // 右子节点同样是下一层级的节点，加入队列后会在后续的循环中被遍历到。
                if (node.right != null) {
                    que.offer(node.right); // 将右子节点加入队列
                }
            }

            // 当 for 循环结束后，表示当前层级的所有节点都已遍历完成，并且它们的节点值都存储在了 linelist 中。
            rets.add( linelist.getLast() );
            /**102. 二叉树的层序遍历变体
            将树的每一层的最右边结点的值即linelist的尾部元素添加到结果列表rets即可
            */ 

        }

        // while 循环结束后，表示所有层级的节点都已遍历完成。
        // 此时 rets 列表包含了站在二叉树的右侧，按照从顶部到底部的顺序，从右侧所能看到的节点值。
        return rets; 


        
    }
}



```































---



## 力扣637. 二叉树的层平均值

给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。

 

示例 1：



输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。

示例 2:



输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]






### BFS--迭代方式--借助队列，无注释


```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {



        Queue<TreeNode> que = new LinkedList<TreeNode>();

        List<Double> rets = new LinkedList();
        /**102. 二叉树的层序遍历的变体
        返回类型改为浮点数列表。
        */

        if( root == null ) {

            return rets;
        }

        que.offer(root);

        
        while( !que.isEmpty() ) {


            int size = que.size();

            List<Integer> linelist = new LinkedList(); 



            for( int i=0; i < size; i++ ) {




                TreeNode node = new TreeNode();

                node = que.poll();

                linelist.add( node.val );


                if( node.left != null ) {

                    que.offer( node.left );

                }

                if( node.right != null ) {

                    que.offer( node.right );
                    
                }



            }


            long sum=0;
            /**用于计算二叉树的每层结点的数值总和
            在处理某些特定的测试用例时，例如 root = [2147483647,2147483647,2147483647] 时，你的代码未能通过，原因在于 整数溢出 (Integer Overflow)。
            问题原因：整数溢出
            在你的代码中，你使用 int sum=0; 来累加每一层节点的数值。当二叉树节点的值很大时（例如示例中的 2147483647，这是 int 类型的最大值），在计算同一层节点的总和时，int 类型的 sum 变量可能会发生溢出。
            例如，在测试用例 [2147483647,2147483647,2147483647] 的第二层，你需要计算 2147483647 + 2147483647。由于 int 类型的最大值是 2147483647，两个最大 int 值相加会发生溢出，导致结果变为负数，从而使得平均值计算错误。
            修正方法：使用 long 类型避免溢出
            为了解决整数溢出的问题，你需要将 sum 变量的数据类型从 int 修改为 long。long 类型可以存储更大范围的整数值，足以避免在本题中出现溢出的情况。
            修改后的代码解释：
            在修正后的代码中，我将 int sum=0; 修改为 long sum=0;。这样，sum 变量就可以安全地累加每一层节点的数值，即使节点值很大，也能避免整数溢出。
            */

            Iterator<Integer> iterator = linelist.iterator();
            // iterator(): 返回一个迭代器，用于遍历链表元素

            while( iterator.hasNext() ) {

                sum += iterator.next();
                // 将该层结点的数值累加

            }

            
            double avg =(double) sum / linelist.size();
            // 求该层结点的平均值

            rets.add( avg );
            // 将该层结点平均值放入结果列表


        }


        return rets;



        
    }
}

```






### BFS--迭代方式--借助队列，注释版


在我的代码中嵌入详细注释说明，使其易于理解和复习





```java
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Iterator;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;         // 节点的值
 *     TreeNode left;    // 指向左子节点的引用
 *     TreeNode right;   // 指向右子节点的引用
 *     TreeNode() {}     // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 构造函数，用于初始化节点值以及左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 功能：计算二叉树每一层节点的平均值，并以 List<Double> 形式返回。
     * 采用层序遍历（Breadth-First Search, BFS）算法。
     *
     * @param root 二叉树的根节点
     * @return List<Double> 每一层节点的平均值列表
     */
    public List<Double> averageOfLevels(TreeNode root) {

        // 创建一个队列 (Queue) 用于辅助层序遍历。队列的特点是先进先出 (FIFO)。
        // 这里使用 LinkedList 来实现 Queue 接口，因为它提供了高效的队列操作。
        Queue<TreeNode> que = new LinkedList<TreeNode>();

        // 创建一个 List<Double> 类型的列表 rets (results 的缩写)，用于存储最终的每层平均值结果。
        // List<Double> 用于存储浮点数类型的平均值，因为平均值通常不是整数。
        List<Double> rets = new LinkedList();
        /**
         *  "102. 二叉树的层序遍历的变体" 注释表明此代码是基于层序遍历的思想进行扩展的。
         *  "返回类型改为浮点数列表。"  注释明确了此题目的返回值类型是浮点数列表，用于存储每层平均值。
         */

        // 如果根节点 root 为 null，表示是空树，直接返回空的结果列表 rets。
        // 空树没有层，所以平均值列表也为空。
        if( root == null ) {
            return rets; // 空树返回空的平均值列表
        }

        // 如果根节点不为空，首先将根节点加入队列。层序遍历从根节点开始。
        que.offer(root);

        // 当队列不为空时，循环进行层序遍历。
        // 队列为空时，表示所有层级的节点都已遍历完成。
        while( !que.isEmpty() ) {

            // size 变量记录当前队列的长度，这个长度代表了当前层级的节点数量。
            // 在开始遍历当前层之前，队列中的节点数量就是当前层的节点数。
            int size = que.size();

            // 创建一个新的 List<Integer> 类型的列表 linelist (line list 的缩写)，用于存储当前层级的节点值。
            // 临时存储当前层节点的值，以便后续计算平均值。
            List<Integer> linelist = new LinkedList();

            // 使用 for 循环遍历当前层级的所有节点。循环次数为当前层级的节点数量 size。
            // 循环一次处理当前层队列中的一个节点。
            for( int i=0; i < size; i++ ) {

                // 从队列中取出一个节点 (队首元素)。`que.poll()` 方法会移除并返回队列的头部元素。
                // 取出的节点是当前层级的一个节点。
                TreeNode node = que.poll();

                // 将取出的节点的值 (node.val) 添加到当前层级的列表 linelist 中。
                // 收集当前层节点的值，用于后续计算平均值。
                linelist.add( node.val );

                // 检查当前节点的左子节点是否存在。如果存在，则将左子节点加入队列。
                // 左子节点是下一层级的节点，加入队列后会在后续的 while 循环中被遍历到。
                if( node.left != null ) {
                    que.offer( node.left ); // 将左子节点加入队列，准备下一层遍历
                }

                // 检查当前节点的右子节点是否存在。如果存在，则将右子节点加入队列。
                // 右子节点同样是下一层级的节点，加入队列后会在后续的 while 循环中被遍历到。
                if( node.right != null ) {
                    que.offer( node.right ); // 将右子节点加入队列，准备下一层遍历
                }
            }

            // 使用 long 类型 sum 变量来存储每层节点的数值总和，避免 Integer 溢出。
            // 如果使用 int 类型，当节点值很大时，累加求和可能会超出 int 的最大值范围，导致溢出，计算结果错误。
            long sum=0;
            /**
             * 用于计算二叉树的每层结点的数值总和
             * 在处理某些特定的测试用例时，例如 root = [2147483647,2147483647,2147483647] 时，你的代码未能通过，原因在于 整数溢出 (Integer Overflow)。
             * 问题原因：整数溢出
             * 在你的代码中，你使用 int sum=0; 来累加每一层节点的数值。当二叉树节点的值很大时（例如示例中的 2147483647，这是 int 类型的最大值），在计算同一层节点的总和时，int 类型的 sum 变量可能会发生溢出。
             * 例如，在测试用例 [2147483647,2147483647,2147483647] 的第二层，你需要计算 2147483647 + 2147483647。由于 int 类型的最大值是 2147483647，两个最大 int 值相加会发生溢出，导致结果变为负数，从而使得平均值计算错误。
             * 修正方法：使用 long 类型避免溢出
             * 为了解决整数溢出的问题，你需要将 sum 变量的数据类型从 int 修改为 long。long 类型可以存储更大范围的整数值，足以避免在本题中出现溢出的情况。
             * 修改后的代码解释：
             * 在修正后的代码中，我将 int sum=0; 修改为 long sum=0;。这样，sum 变量就可以安全地累加每一层节点的数值，即使节点值很大，也能避免整数溢出。
             */

            Iterator<Integer> iterator = linelist.iterator();
            // iterator(): 返回一个迭代器，用于遍历链表元素。
            // 获取 linelist 的迭代器，用于遍历当前层节点值列表。

            while( iterator.hasNext() ) {
                sum += iterator.next();
                // 将该层结点的数值累加
                // 使用迭代器遍历 linelist，并将每个节点值累加到 sum 变量中。
            }

            // 计算该层结点的平均值。
            // 将 sum 转换为 double 类型，然后除以当前层节点数量 linelist.size()，得到浮点数类型的平均值。
            double avg =(double) sum / linelist.size();
            // 求该层结点的平均值

            rets.add( avg );
            // 将该层结点平均值放入结果列表
            // 将计算得到的当前层平均值 avg 添加到结果列表 rets 中。
        }

        // while 循环结束后，表示所有层级的节点都已遍历完成。
        // 此时 rets 列表包含了二叉树的每一层节点的平均值。
        return rets; // 返回层序遍历的每层平均值结果列表
    }
}
```
























---












## 力扣226. 翻转二叉树



给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

 

示例 1：



输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
示例 2：



输入：root = [2,1,3]
输出：[2,3,1]
示例 3：

输入：root = []
输出：[]
 

提示：

树中节点数目范围在 [0, 100] 内
-100 <= Node.val <= 100





### DFS递归，无注释

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        // 前序遍历:按根结点，左子树，右子树顺序遍历

        if( root == null ) {

            return null;
        }

        TreeNode temp = new TreeNode();

        temp = root.left;

        root.left = root.right;

        root.right = temp;

        invertTree( root.left );

        invertTree( root.right );

        return root;

    }



}

```





### DFS递归，注释版

在我的代码中嵌入详细注释说明，使其易于理解和复习



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;         // 节点的值
 *     TreeNode left;    // 指向左子节点的引用
 *     TreeNode right;   // 指向右子节点的引用
 *     TreeNode() {}     // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 构造函数，用于初始化节点值以及左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 功能：翻转一棵二叉树，即交换每个节点的左右子树。
     * 采用递归的前序遍历方式实现。
     *
     * @param root 二叉树的根节点
     * @return TreeNode 翻转后的二叉树的根节点
     */
    public TreeNode invertTree(TreeNode root) {
        // 翻转二叉树的核心思想是：
        // 对于树中的每个节点，交换其左子节点和右子节点。
        // 然后递归地对左子树和右子树进行相同的操作。
        // 这里使用前序遍历的方式，即先处理根节点，再处理左子树，最后处理右子树。

        // 递归终止条件：当遍历到空节点时，直接返回 null。
        // 空节点不需要翻转，递归应该在此处结束。
        if( root == null ) {
            return null; // 如果当前节点为空，则直接返回 null
        }

        // 创建一个临时 TreeNode 类型的变量 temp，用于辅助交换左右子节点。
        // 在交换过程中，需要一个临时变量来存储其中一个子节点，避免数据丢失。
        TreeNode temp = new TreeNode();

        // 将当前节点 root 的左子节点赋值给临时变量 temp。
        // 临时保存左子节点的引用，以便后续赋值给右子节点。
        temp = root.left;

        // 将当前节点 root 的右子节点赋值给当前节点 root 的左子节点。
        // 将右子树放到左子树的位置。
        root.left = root.right;

        // 将临时变量 temp 中保存的原左子节点赋值给当前节点 root 的右子节点。
        // 将原左子树放到右子树的位置。
        // 完成当前节点 root 的左右子树的交换。
        root.right = temp;

        // 递归调用 invertTree 函数，翻转当前节点 root 的左子树。
        // 递归地对左子树执行相同的翻转操作。
        invertTree( root.left );

        // 递归调用 invertTree 函数，翻转当前节点 root 的右子树。
        // 递归地对右子树执行相同的翻转操作。
        invertTree( root.right );

        // 当递归遍历和交换完成后，返回根节点 root。
        // 此时，以 root 为根节点的整棵二叉树已经被翻转。
        return root; // 返回翻转后的二叉树根节点
    }
}
```









---






















## 力扣101. 对称二叉树


给你一个二叉树的根节点 root ， 检查它是否轴对称。

 

示例 1：


输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：


输入：root = [1,2,2,null,3,null,3]
输出：false
 

提示：

树中节点数目在范围 [1, 1000] 内
-100 <= Node.val <= 100



### 递归法，无注释。学习灵神。

```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {


        return compare( root.left, root.right );
        
    }


    public boolean compare( TreeNode left, TreeNode right ) {

        if( left == null || right == null ) {

            return left == right;

        }


        if( left.val == right.val && compare( left.left, right.right ) && compare( left.right, right.left ) ) {

            return true;

        }
        else {

            return false;
        }


    }



}

```

在我的代码中嵌入详细注释说明，使其易于理解和复习。并用一段文字总结解题思路。




### 递归法，注释版。学习灵神。



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;             // 节点的值
 *     TreeNode left;       // 左子节点
 *     TreeNode right;      // 右子节点
 *     TreeNode() {}        // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 带 val 参数的构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 带 val, left, right 参数的构造函数，用于初始化节点值和左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 检查给定的二叉树是否轴对称。
     *
     * @param root 二叉树的根节点
     * @return 如果二叉树轴对称，则返回 true；否则返回 false
     */
    public boolean isSymmetric(TreeNode root) {

        // 树为空树的情况，根据题目描述，只有一个节点的树也被认为是轴对称的，
        // 但实际上题目限制了节点数目在 [1, 1000] 内，所以不需要显式处理空树情况。
        // 如果需要考虑空树的情况，可以添加 root == null 的判断，并根据题意返回 true 或 false。

        // 轴对称的关键在于比较根节点的左子树和右子树是否“镜像对称”。
        // 这里调用 compare 方法来递归地比较左子树和右子树。
        // 注意，我们直接比较 root 的 left 和 right 子节点，而不是 root 本身。
        // 因为对称性是相对于根节点而言的，我们需要比较的是根节点的两个子树。
        return compare( root.left, root.right );

    }


    /**
     * 递归比较两个节点（分别来自左子树和右子树）是否镜像对称。
     *
     * @param left  左子树的当前节点
     * @param right 右子树的当前节点
     * @return 如果两个节点及其子树镜像对称，则返回 true；否则返回 false
     */
    public boolean compare( TreeNode left, TreeNode right ) {

        // 递归终止条件：
        // 当 left 和 right 中有一个为空时，检查它们是否都为空。
        // 如果都为空，则表示对称；如果只有一个为空，则不对称。
        if( left == null || right == null ) {

            return left == right; // 只有当 left 和 right 都为 null 时，才返回 true，否则返回 false

        }


        // 递归比较的逻辑：
        // 1. 首先比较当前节点的值是否相等。如果值不相等，则不对称，直接返回 false。
        // 2. 如果值相等，则需要递归地比较：
        //    - 左子树的左子节点 (left.left) 和 右子树的右子节点 (right.right) 是否对称。
        //    - 左子树的右子节点 (left.right) 和 右子树的左子节点 (right.left) 是否对称。
        //    - 只有当当前节点值相等，并且上述两个递归比较都返回 true 时，才表示以当前节点为根的子树是对称的。

        if( left.val == right.val &&  // 当前节点值相等
            compare( left.left, right.right ) && // 递归比较左子树的左子节点和右子树的右子节点
            compare( left.right, right.left ) ) { // 递归比较左子树的右子节点和右子树的左子节点

            return true; // 当前节点及其子树对称，返回 true

        }
        else {
            // 如果当前节点值不相等，或者子树不对称，则返回 false
            return false;
        }


    }



}
```

**解题思路总结:**

判断二叉树是否轴对称的核心思想是递归地比较树的左子树和右子树是否呈现“镜像”关系。我们从根节点的左右子节点开始比较，然后深入到子树的子树。在递归比较过程中，需要同时满足两个条件才能判定为对称：一是当前比较的两个节点值必须相等；二是左子树的左孩子需要与右子树的右孩子对称，同时左子树的右孩子需要与右子树的左孩子对称。递归的终止条件是当比较的两个节点中有一个为空时，此时只有当两个节点都为空时才算作对称。通过这种递归的比较，我们可以有效地判断整个二叉树是否是轴对称的。





---
























## 104. 二叉树的最大深度


给定一个二叉树 root ，返回其最大深度。

二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。

 

示例 1：

输入：root = [3,9,20,null,null,15,7]
输出：3

示例 2：

输入：root = [1,null,2]
输出：2
 

提示：

树中节点的数量在 [0, 10^4] 区间内。
-100 <= Node.val <= 100



### 使用层序遍历迭代法，无注释。学自代码随想录。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {


        
        Queue<TreeNode> que = new LinkedList<TreeNode>();

        // List<List<Integer>> rets = new LinkedList();

        int depth=0;
        /**102. 二叉树的层序遍历变体，只需每次遍历一层将深度加1即可。 */ 

        if( root == null ) {

            return depth;
            /**102. 二叉树的层序遍历变体，只需每次遍历一层将深度加1即可。 */ 
        }

        que.offer(root);

        
        while( !que.isEmpty() ) {


            int size = que.size();

            // List<Integer> linelist = new LinkedList(); 



            for( int i=0; i < size; i++ ) {




                TreeNode node = new TreeNode();

                node = que.poll();

                // linelist.add( node.val );


                if( node.left != null ) {

                    que.offer( node.left );

                }

                if( node.right != null ) {

                    que.offer( node.right );
                    
                }



            }


            // rets.add( linelist );

            depth++;
            /**102. 二叉树的层序遍历变体，只需每次遍历一层将深度加1即可。 */ 



        }


        return depth;



        
    }
}

```
在我的代码中嵌入详细注释说明，使其易于理解和复习。并用一段文字总结解题思路。





### 使用层序遍历迭代法，注释版。学自代码随想录。





```java
import java.util.LinkedList;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;             // 节点的值
 *     TreeNode left;       // 左子节点
 *     TreeNode right;      // 右子节点
 *     TreeNode() {}        // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 带 val 参数的构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 带 val, left, right 参数的构造函数，用于初始化节点值和左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 给定一个二叉树 root ，返回其最大深度。
     * 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。
     *
     * @param root 二叉树的根节点
     * @return 二叉树的最大深度
     */
    public int maxDepth(TreeNode root) {

        // 使用队列进行广度优先搜索 (BFS)
        Queue<TreeNode> que = new LinkedList<TreeNode>();

        // 深度计数器，初始化为 0
        int depth = 0;

        // 如果根节点为空，则树为空树，深度为 0
        if (root == null) {
            return depth; // 返回深度 0
        }

        // 将根节点加入队列，开始 BFS
        que.offer(root);

        // 当队列不为空时，继续 BFS
        while (!que.isEmpty()) {

            // 记录当前层的节点数量，这是队列当前的大小
            int size = que.size();

            // 遍历当前层的所有节点
            for (int i = 0; i < size; i++) {

                // 从队列中取出一个节点 (队首元素出队)
                TreeNode node = que.poll();

                // 检查当前节点的左子节点，如果存在则加入队列，以便下一层遍历
                if (node.left != null) {
                    que.offer(node.left);
                }

                // 检查当前节点的右子节点，如果存在则加入队列，以便下一层遍历
                if (node.right != null) {
                    que.offer(node.right);
                }
            }

            // 每完成一层遍历，深度加 1。
            // 因为外层的 while 循环每次处理一层节点。
            depth++;

        }

        // BFS 结束后，depth 记录的就是二叉树的最大深度
        return depth;
    }
}
```

**解题思路总结:**

本代码采用了**广度优先搜索 (BFS)** 的方法来计算二叉树的最大深度。  BFS 是一种层序遍历算法，它逐层访问树的节点。  我们使用一个**队列**来辅助 BFS。  

1.  **初始化:**  创建一个队列，并将根节点放入队列。深度计数器 `depth` 初始化为 0。
2.  **层序遍历:**  当队列不为空时，循环执行以下步骤：
    *   记录当前队列的大小 `size`，这代表当前层的节点数量。
    *   进行 `size` 次循环，处理当前层的所有节点：
        *   从队列中取出一个节点。
        *   将该节点的非空左子节点和右子节点加入队列，以便在下一轮循环中遍历下一层。
    *   每完成一层节点的遍历 (即完成 `size` 次循环)，将深度计数器 `depth` 加 1。
3.  **返回结果:**  当队列为空时，表示所有层都已遍历完成，此时 `depth` 记录的就是二叉树的最大深度，将其返回。

这种 BFS 方法的优点在于，它逐层遍历，每遍历完一层，深度就增加 1，最终得到的深度值就是从根节点到最远叶子节点的最长路径上的节点数，即最大深度。 这与二叉树最大深度的定义完全一致。






---



























## 力扣111. 二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：2
示例 2：

输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
 

提示：

树中节点数的范围在 [0, 10^5] 内
-1000 <= Node.val <= 1000




### 递归法，无注释。学自代码随想录。


```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {



        if( root == null ) {

            return 0;
        }

        int leftDepth=0;

        int rightDepth=0;

        leftDepth = minDepth( root.left );

        rightDepth = minDepth( root.right );

        if( root.left == null && root.right != null ) {

            return 1 + rightDepth;
        }

        if( root.left != null && root.right == null ) {

            return 1 + leftDepth;
        }

        int ret=0;

        ret = ( leftDepth < rightDepth ? leftDepth:rightDepth ) + 1;

        return ret;



    }
}

```

在我的代码中嵌入详细注释说明，使其易于理解和复习。并用一段文字总结解题思路。









### 递归法，注释版。学自代码随想录。


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;             // 节点的值
 *     TreeNode left;       // 左子节点
 *     TreeNode right;      // 右子节点
 *     TreeNode() {}        // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 带 val 参数的构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 带 val, left, right 参数的构造函数，用于初始化节点值和左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 给定一个二叉树，找出其最小深度。
     * 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
     * 叶子节点是指没有子节点的节点。
     *
     * @param root 二叉树的根节点
     * @return 二叉树的最小深度
     */
    public int minDepth(TreeNode root) {

        // 递归终止条件：如果根节点为空，则最小深度为 0
        if (root == null) {
            return 0;
        }

        // 初始化左子树和右子树的深度
        int leftDepth = 0;
        int rightDepth = 0;

        // 递归计算左子树的最小深度
        leftDepth = minDepth(root.left);
        // 递归计算右子树的最小深度
        rightDepth = minDepth(root.right);

        // 特殊情况处理：
        // 当左子树为空，但右子树不为空时，最小深度应该在右子树的基础上加 1
        // 因为要到达叶子节点，必须经过右子树。
        if (root.left == null && root.right != null) {
            return 1 + rightDepth;
        }

        // 特殊情况处理：
        // 当右子树为空，但左子树不为空时，最小深度应该在左子树的基础上加 1
        // 因为要到达叶子节点，必须经过左子树。
        if (root.left != null && root.right == null) {
            return 1 + leftDepth;
        }

        // 一般情况：当左右子树都不为空，或者都为空时
        // 最小深度应该是左右子树最小深度中的较小值，再加上当前根节点这一层 (深度 + 1)
        int ret = 0;
        ret = (leftDepth < rightDepth ? leftDepth : rightDepth) + 1;

        return ret;
    }
}
```

**解题思路总结:**

本代码采用**递归**的方式来计算二叉树的最小深度。最小深度的定义是从根节点到最近叶子节点的最短路径上的节点数量。 叶子节点是左右子节点都为空的节点。

1.  **递归终止条件:**  当 `root` 为 `null` 时，表示到达空节点，此时深度为 0，递归结束。
2.  **递归步骤:**
    *   分别递归调用 `minDepth` 函数计算左子树 (`root.left`) 和右子树 (`root.right`) 的最小深度，分别得到 `leftDepth` 和 `rightDepth`。
    *   **特殊情况处理（关键部分）:**
        *   如果当前节点 `root` 的左子树为空 (`root.left == null`) 但右子树不为空 (`root.right != null`)，则最小深度应该在右子树的最小深度基础上加 1。因为要找到叶子节点，路径必须经过右子树。
        *   反之，如果右子树为空 (`root.right == null`) 但左子树不为空 (`root.left != null`)，最小深度应该在左子树的最小深度基础上加 1。
    *   **一般情况处理:** 如果左右子树都不为空，或者都为空（此时当前节点是叶子节点），则最小深度是左右子树最小深度中的较小值，再加上 1 （当前节点本身算一层深度）。
3.  **返回值:** 返回计算得到的最小深度。

这种递归方法的核心思想是不断向下探索左右子树，直到遇到叶子节点或者空节点，然后逐层向上返回最小深度值。 特别需要注意的是处理单边子树为空的情况，这是计算 *最小* 深度与计算 *最大* 深度不同的关键点。



















### 迭代法，层序遍历，注释版。学自代码随想录。





```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {


        // 使用队列进行广度优先搜索 (BFS)
        Queue<TreeNode> que = new LinkedList<TreeNode>();

        // 深度计数器，初始化为 0
        int depth = 0;

        // 用于标记是否找到最近叶子节点
        int find = 0;

        // 如果根节点为空，则树为空树，深度为 0
        if (root == null) {
            return depth; // 返回深度 0
        }

        // 将根节点加入队列，开始 BFS
        que.offer(root);

        // 当队列不为空时，继续 BFS
        while (!que.isEmpty()) {

            // 记录当前层的节点数量，这是队列当前的大小
            int size = que.size();

            // 遍历当前层的所有节点
            for (int i = 0; i < size; i++) {

                // 从队列中取出一个节点 (队首元素出队)
                TreeNode node = que.poll();

                // 检查当前节点的左子节点，如果存在则加入队列，以便下一层遍历
                if (node.left != null) {
                    que.offer(node.left);
                }

                // 检查当前节点的右子节点，如果存在则加入队列，以便下一层遍历
                if (node.right != null) {
                    que.offer(node.right);
                }


                if( node.left == null && node.right == null ) {

                    find = 1;
                }


            }

            // 每完成一层遍历，深度加 1。
            // 因为外层的 while 循环每次处理一层节点。
            depth++;


            if( find ==1 ) {
                // 在遍历该层时首次发现了某节点的左右子树都为空，即为最近的叶子节点

                return depth;
            }

        }

        // BFS 结束后
        return depth;
        
    }
}
```

这段代码使用**广度优先搜索 (BFS)** 算法来寻找二叉树的最小深度。与之前求最大深度的 BFS 类似，它也是逐层遍历树的节点，但核心区别在于**寻找目标**和**终止条件**。

在寻找最小深度时，我们的目标是找到**最近的叶子节点**。由于 BFS 是层序遍历，它会优先访问离根节点更近的层。因此，**当我们第一次在某一层发现叶子节点时，从根节点到这个叶子节点的路径长度一定是所有叶子节点路径中最短的**。

代码中，我们仍然使用队列进行 BFS，逐层遍历二叉树。在每一层遍历时，对于每个节点，我们都会检查它是否是叶子节点（即 `node.left == null && node.right == null`）。如果发现叶子节点，就设置 `find` 标志为 1。  一旦在某一层发现了叶子节点，我们立即返回当前的 `depth` 值，因为这已经是最小深度了。  `find` 标志的作用就是优化搜索，一旦找到第一个叶子节点就提前结束遍历，因为 BFS 保证了先遇到的叶子节点一定是深度最小的。

总结来说，这个 BFS 方法通过层序遍历，**优先探索浅层节点**，并在**首次遇到叶子节点时立即停止搜索**，从而高效地找到了二叉树的最小深度。  这种方法确保了找到的深度一定是最小的，因为它保证了到达的第一个叶子节点一定是最浅层的叶子节点。












---























## 力扣222. 完全二叉树的节点个数



给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（从第 0 层开始），则该层包含 1~ 2h 个节点。

 

示例 1：

输入：root = [1,2,3,4,5,6]
输出：6

示例 2：

输入：root = []
输出：0

示例 3：

输入：root = [1]
输出：1





### 递归法，按左右根进行后序遍历。学自代码随想录。



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        // 递归法，按左右根遍历



        if( root == null ) {
            // 空结点返回0

            return 0;
        }


        int leftNum = countNodes( root.left );
        // 递归遍历求左子树节点个数

        int rightNum = countNodes( root.right );
        // 递归遍历求右子树节点个数

        int ret = leftNum + rightNum + 1;
        // 总节点个数= 左子树节点个数 + 右子树节点个数
        
        return ret;
        
    }
}
```






### 迭代法，按层序遍历计数。学自代码随想录。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {



        // 使用队列进行广度优先搜索 (BFS)
        Queue<TreeNode> que = new LinkedList<TreeNode>();

        // 节点计数器
        int cnt = 0;

        if( root == null ) {

            return cnt;
            // 空树直接返回0
        }

        // 将根节点加入队列，开始 BFS
        que.offer(root);

        // 当队列不为空时，继续 BFS
        while (!que.isEmpty()) {

            // 记录当前层的节点数量，这是队列当前的大小
            int size = que.size();

            // 遍历当前层的所有节点
            for (int i = 0; i < size; i++) {

                // 从队列中取出一个节点 (队首元素出队)
                TreeNode node = que.poll();

                cnt++;
                // 每遍历一个节点将计数器加一

                // 检查当前节点的左子节点，如果存在则加入队列，以便下一层遍历
                if (node.left != null) {
                    que.offer(node.left);
                }

                // 检查当前节点的右子节点，如果存在则加入队列，以便下一层遍历
                if (node.right != null) {
                    que.offer(node.right);
                }


            }



        }


        return cnt;
        // 遍历完所有节点后，返回总节点数

        
    }
}
```




















### 递归法+满二叉树的节点公式，无注释。学自代码随想录。


![alt text](image-112.png)





```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        // 按照完全二叉树公式计算


        if( root == null ) {

            return 0;
        }

        int leftDepth=0;

        int leftNum=0;
        
        TreeNode left = root.left;
        
        int rightDepth=0;

        int rightNum=0;

        TreeNode right = root.right;

        while( left != null ) {

            left = left.left;
            
            leftDepth++;

        }

        while( right != null ) {

            right = right.right;

            rightDepth++;
        }

        if( leftDepth == rightDepth ) {
            
            
            return  ( 2 << leftDepth ) - 1 ;

        }


        int ret = countNodes( root.left ) + countNodes( root.right ) + 1;

        

        return ret;




        
    }
}

```

在我的代码中嵌入详细注释说明，并用一段文字总结解题思路，使其易于理解和复习。





### 递归法+满二叉树的节点公式，注释版。学自代码随想录。

![alt text](image-112.png)


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;             // 节点的值
 *     TreeNode left;       // 左子节点
 *     TreeNode right;      // 右子节点
 *     TreeNode() {}        // 无参构造函数
 *     TreeNode(int val) { this.val = val; } // 带 val 参数的构造函数，用于初始化节点值
 *     TreeNode(int val, TreeNode left, TreeNode right) { // 带 val, left, right 参数的构造函数，用于初始化节点值和左右子节点
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
     * 利用完全二叉树的特性进行优化，并非简单的遍历计数。
     *
     * @param root 完全二叉树的根节点
     * @return 树的节点个数
     */
    public int countNodes(TreeNode root) {
        // 完全二叉树节点计数，利用其特性优化

        // 递归终止条件：如果根节点为空，则节点数为 0
        if (root == null) {
            return 0;
        }

        // 初始化左子树和右子树的深度
        int leftDepth = 0;
        int rightDepth = 0;

        // 用于遍历计算深度的临时节点，从左右子节点开始
        TreeNode left = root.left;
        TreeNode right = root.right;

        // 计算左子树的最大深度 (一直向左子树的最左侧遍历)
        while (left != null) {
            left = left.left; // 向左子节点移动
            leftDepth++;     // 深度加 1
        }

        // 计算右子树的最大深度 (一直向右子树的最右侧遍历)
        while (right != null) {
            right = right.right; // 向右子节点移动
            rightDepth++;       // 深度加 1
        }

        // 如果左子树深度等于右子树深度，说明以当前节点为根的子树是满二叉树
        // 满二叉树的节点数可以直接用公式计算：2^(depth + 1) - 1
        // 这里 depth 是从根节点到叶子节点的边数，也就是树的高度，与层数概念略有不同，但在此处深度值是一致的。
        if (leftDepth == rightDepth) {
            // (2 << leftDepth)  等价于 2的 (leftDepth + 1) 次方，因为 leftDepth 是从子节点开始计数的，所以要加1
            // 减 1 是因为公式是 2^(depth + 1) - 1
            return (2 << leftDepth) - 1;

        }

        // 如果左子树深度不等于右子树深度，说明不是满二叉树，需要递归计算
        // 递归计算左子树的节点数 + 递归计算右子树的节点数 + 1 (根节点本身)
        int ret = countNodes(root.left) + countNodes(root.right) + 1;

        return ret;
    }
}
```

**解题思路总结:**

这段代码利用了**完全二叉树**的特性来高效地计算节点总数，而非简单地遍历所有节点。  核心思想是**递归结合完全二叉树的深度特性**。

1.  **深度比较:**  对于给定的根节点，代码首先分别计算其**左子树的最左侧深度**和**右子树的最右侧深度**。  在完全二叉树中，如果左右子树的深度相等，这意味着以当前节点为根的子树是一个**满二叉树**（perfect binary tree，也是一种特殊的完全二叉树）。

2.  **满二叉树优化:**  如果左右子树深度相等，可以直接使用**满二叉树的节点公式** `2^(depth + 1) - 1` 来快速计算节点数，其中 `depth` 是左/右子树的深度。 这种情况下，无需递归深入子树，大大提高了效率。

3.  **递归计算:**  如果左右子树深度不相等，则说明当前子树不是满二叉树，但仍然是完全二叉树。  此时，代码采用**递归**的方式，分别计算**左子树的节点数**和**右子树的节点数**，并将两者之和再加上 1（根节点自身）作为当前子树的节点总数。

4.  **递归终止条件:**  当递归到空节点 (`root == null`) 时，节点数为 0，递归结束。

总而言之，该算法通过深度比较来判断是否为满二叉树，若是则公式计算，否则递归求解，充分利用了完全二叉树的结构特点，避免了对所有节点进行遍历计数，在完全二叉树的场景下，效率优于简单的遍历计数方法。





---






















## 力扣257. 二叉树的所有路径

给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。

 
示例 1：

输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]

示例 2：

输入：root = [1]
输出：["1"]
 

提示：

树中节点的数目在范围 [1, 100] 内
-100 <= Node.val <= 100




### 代码随想录题解

```java

//解法一

//方式一
class Solution {
    /**
     * 递归法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();// 存最终的结果
        if (root == null) {
            return res;
        }
        List<Integer> paths = new ArrayList<>();// 作为结果中的路径
        traversal(root, paths, res);
        return res;
    }

    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {
        paths.add(root.val);// 前序遍历，中
        // 遇到叶子结点
        if (root.left == null && root.right == null) {
            // 输出
            StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快
            for (int i = 0; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));// 记录最后一个节点
            res.add(sb.toString());// 收集一个路径
            return;
        }
        // 递归和回溯是同时进行，所以要放在同一个花括号里
        if (root.left != null) { // 左
            traversal(root.left, paths, res);
            paths.remove(paths.size() - 1);// 回溯
        }
        if (root.right != null) { // 右
            traversal(root.right, paths, res);
            paths.remove(paths.size() - 1);// 回溯
        }
    }
}

//方式二
class Solution {

    List<String> result = new ArrayList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        deal(root, "");
        return result;
    }

    public void deal(TreeNode node, String s) {
        if (node == null)
            return;
        if (node.left == null && node.right == null) {
            result.add(new StringBuilder(s).append(node.val).toString());
            return;
        }
        String tmp = new StringBuilder(s).append(node.val).append("->").toString();
        deal(node.left, tmp);
        deal(node.right, tmp);
    }
}




// 解法二
class Solution {
    /**
     * 迭代法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null)
            return result;
        Stack<Object> stack = new Stack<>();
        // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // 节点和路径同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 若找到叶子节点
            if (node.left == null && node.right == null) {
                result.add(path);
            }
            //右子节点不为空
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            //左子节点不为空
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}


```


为我详细讲解该题目和上述解法，教会我如何独立写出该题目



### gemini-2.5-pro-exp-03-25讲解




好的，我们来详细分析一下 LeetCode 257 "二叉树的所有路径" 这道题以及你提供的三种解法。

**题目理解**

首先，我们要清晰地理解题目的要求：

1.  **输入：** 一个二叉树的根节点 `root`。
2.  **输出：** 一个字符串列表 (`List<String>`)。
3.  **目标：** 找到所有从 **根节点** 开始，到 **叶子节点** 结束的路径。
4.  **叶子节点定义：** 没有左子节点也没有右子节点的节点。
5.  **路径格式：** 路径上的节点值用 "->" 连接。例如，根是 1，左孩子是 2，2 的右孩子是 5（叶子），那么这条路径表示为 "1->2->5"。
6.  **顺序：** 输出列表中路径的顺序不重要。
7.  **约束：** 树的节点数、节点值的范围有限制，这通常意味着 O(N) 或 O(N log N) 复杂度的算法是可以接受的，其中 N 是节点数。

**核心思路：遍历与路径记录**

这道题的本质是**遍历**整个二叉树，并在遍历过程中**记录**下当前的路径。当遍历到一个叶子节点时，就将记录下来的路径格式化成字符串并添加到结果列表中。

由于我们需要深入到树的末端（叶子节点），**深度优先搜索 (DFS)** 是非常自然的选择。DFS 可以通过**递归**或**迭代 (使用栈)** 来实现。

**解法分析**

---

**解法一：递归 (方式一 - 使用 `List<Integer>` 记录路径)**

```java
import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution_Recursive_List { // Renamed class for clarity
    /**
     * 主函数，初始化结果列表和路径列表，并启动递归遍历
     * @param root 二叉树根节点
     * @return 包含所有根到叶子节点路径的字符串列表
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>(); // 存储最终结果的列表
        if (root == null) {
            return res; // 如果树为空，直接返回空列表
        }
        List<Integer> paths = new ArrayList<>(); // 用于存储当前遍历路径上的节点值
        traversal(root, paths, res); // 调用递归辅助函数
        return res;
    }

    /**
     * 递归辅助函数，执行深度优先搜索并记录路径
     * @param node  当前遍历到的节点
     * @param paths 当前路径上已经过的节点值列表 (引用传递，会被修改)
     * @param res   最终结果列表 (引用传递，用于收集路径字符串)
     */
    private void traversal(TreeNode node, List<Integer> paths, List<String> res) {
        // 1. 将当前节点值加入路径列表 (前序遍历位置)
        paths.add(node.val);

        // 2. 检查是否到达叶子节点
        if (node.left == null && node.right == null) {
            // 到达叶子节点，说明找到了一条完整路径
            // 将 paths 中的节点值拼接成 "->" 连接的字符串
            StringBuilder sb = new StringBuilder(); // 使用 StringBuilder 提高效率
            for (int i = 0; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1)); // 添加最后一个节点值 (不加 "->")
            res.add(sb.toString()); // 将构建好的路径字符串添加到结果列表中
            // 注意：这里不需要移除 paths.remove(paths.size() - 1)，因为 return 会结束当前分支的递归
            // 回溯操作会在递归调用返回后执行
            return; // 到达叶子节点，结束当前递归分支
        }

        // 3. 如果不是叶子节点，则继续向子节点递归
        // 递归和回溯是伴随进行的
        if (node.left != null) { // 探索左子树
            traversal(node.left, paths, res);
            // 回溯：当从左子树返回时，需要将当前节点从路径中移除，
            // 以保证探索右子树时，paths 列表是正确的（不包含左子树的节点）
            paths.remove(paths.size() - 1);
        }
        if (node.right != null) { // 探索右子树
            traversal(node.right, paths, res);
            // 回溯：当从右子树返回时，同样需要将当前节点从路径中移除
            paths.remove(paths.size() - 1);
        }
    }
}
```

*   **思路讲解：**
    1.  使用一个辅助函数 `traversal` 进行递归。
    2.  `paths` (一个 `List<Integer>`) 用于记录从根节点到当前节点的路径上的所有节点值。
    3.  **前序遍历思想**：在 `traversal` 函数开始时，立刻将当前节点 `node.val` 加入 `paths` 列表。
    4.  **判断叶子节点**：检查当前节点是否是叶子节点 (`node.left == null && node.right == null`)。
    5.  **路径收集**：如果是叶子节点，遍历 `paths` 列表，使用 `StringBuilder` 构建格式化的路径字符串，并将其添加到结果 `res` 列表中。然后 `return` 结束当前递归分支。
    6.  **递归深入**：如果不是叶子节点，递归调用 `traversal` 探索左子节点（如果存在）和右子节点（如果存在）。
    7.  **回溯（关键！）**：在从一个子节点的递归调用返回 *之后*，必须将当前节点的值从 `paths` 列表中移除 (`paths.remove(paths.size() - 1);`)。这步操作称为**回溯**。它的目的是：当你探索完一个子树（比如左子树）并返回到当前节点时，你需要撤销进入该子树前所做的“将当前节点加入路径”的操作，这样当你去探索另一个子树（比如右子树）时，`paths` 列表的状态才是正确的（只包含根到当前节点的路径，不包含刚刚探索完的那个子树的任何节点）。

---

**解法一：递归 (方式二 - 直接传递路径字符串)**

```java
import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution_Recursive_String { // Renamed class for clarity

    List<String> result = new ArrayList<>(); // 存储最终结果

    /**
     * 主函数，初始化并启动递归
     * @param root 二叉树根节点
     * @return 包含所有根到叶子节点路径的字符串列表
     */
    public List<String> binaryTreePaths(TreeNode root) {
        deal(root, ""); // 初始调用，路径字符串为空
        return result;
    }

    /**
     * 递归辅助函数
     * @param node 当前遍历到的节点
     * @param s    从根节点到当前节点的父节点的路径字符串 (注意：不包含当前节点)
     */
    public void deal(TreeNode node, String s) {
        if (node == null) {
            return; // 递归终止条件：遇到空节点，直接返回
        }

        // 检查是否是叶子节点
        if (node.left == null && node.right == null) {
            // 到达叶子节点，构建最终路径字符串并添加到结果列表
            // 将当前路径 s 和当前叶子节点值拼接起来
            result.add(new StringBuilder(s).append(node.val).toString());
            return; // 结束当前递归分支
        }

        // 如果不是叶子节点，构建传递给子节点的路径字符串
        // 新路径 = 当前路径 s + 当前节点值 + "->"
        String tmp = new StringBuilder(s).append(node.val).append("->").toString();

        // 递归探索左子树，传入更新后的路径字符串 tmp
        deal(node.left, tmp);
        // 递归探索右子树，传入更新后的路径字符串 tmp
        deal(node.right, tmp);

        // 不需要显式回溯：因为 Java 中 String 是不可变的。
        // 每次递归调用 deal(node.left, tmp) 或 deal(node.right, tmp) 时，
        // 传递的 tmp 是一个新的字符串对象（或指向一个常量池中的字符串）。
        // 对子递归调用中 tmp 的任何操作（理论上，虽然这里没操作）都不会影响父调用中的 tmp 或 s。
        // 当递归从子节点返回时，父调用中的 s 或 tmp 变量的值仍然是进入子节点之前的值。
        // 回溯的效果由递归调用栈的弹出自动完成。
    }
}
```

*   **思路讲解：**
    1.  与方式一类似，也是递归 DFS。
    2.  不同之处在于，它不使用 `List<Integer>` 来维护路径，而是直接在递归参数中传递**已经构建好的部分路径字符串** `s`。
    3.  **路径构建**：在递归调用子节点之前，将当前节点的值和 "->" 追加到传入的路径字符串 `s` 后面，形成新的路径字符串 `tmp`，然后将 `tmp` 传递给子节点的递归调用。
    4.  **判断叶子节点**：当遇到叶子节点时，将传入的路径字符串 `s` 和当前叶子节点的值 `node.val` 拼接起来（注意此时叶子节点值后面不加 "->"），形成完整的路径字符串，并添加到结果 `result` 列表中。
    5.  **隐式回溯**：这种方法不需要像方式一那样显式地 `remove` 路径元素。因为 Java 的 `String` 是不可变的，每次拼接字符串 (`new StringBuilder(...)` 或 `s + node.val + "->"`) 实际上会创建新的字符串对象。当递归调用返回时，上一层函数的路径字符串变量 `s` 或 `tmp` 并没有被修改，自然就达到了回溯的效果。

---

**解法二：迭代 (使用栈)**

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution_Iterative_Stack { // Renamed class for clarity
    /**
     * 使用迭代方式 (模拟 DFS) 查找所有路径
     * @param root 二叉树根节点
     * @return 包含所有根到叶子节点路径的字符串列表
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null)
            return result; // 处理空树

        // 使用一个栈来模拟递归过程。
        // 因为需要同时保存节点和到达该节点的路径，所以栈中交替存储 TreeNode 和 String
        // 或者也可以创建一个 Pair<TreeNode, String> 类，或者用两个栈同步操作。
        // 这里采用交替存储在同一个 Object 栈中的方式。
        Stack<Object> stack = new Stack<>();

        // 初始化：将根节点和根节点的路径（仅包含根节点值）压入栈
        // 注意压栈顺序：先压节点，再压路径。这样出栈时先拿到路径，再拿到节点。
        stack.push(root);
        stack.push(root.val + ""); // 初始路径字符串

        while (!stack.isEmpty()) {
            // 出栈：先弹出路径字符串，再弹出对应的节点
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();

            // 检查是否是叶子节点
            if (node.left == null && node.right == null) {
                // 如果是叶子节点，将当前路径添加到结果列表中
                result.add(path);
                // 不需要继续处理子节点，直接进入下一次循环
                // continue; // 可以加 continue，也可以不加，因为后面if条件不会满足
            }

            // 如果有右子节点，将其和对应的路径压栈
            // 注意压栈顺序：先压右子节点，再压左子节点。
            // 因为栈是后进先出(LIFO)，所以先压右再压左，可以保证先处理左子树（符合DFS习惯）。
            if (node.right != null) {
                stack.push(node.right); // 压入右子节点
                // 压入到达右子节点的路径 = 当前路径 + "->" + 右子节点值
                stack.push(path + "->" + node.right.val);
            }

            // 如果有左子节点，将其和对应的路径压栈
            if (node.left != null) {
                stack.push(node.left); // 压入左子节点
                // 压入到达左子节点的路径 = 当前路径 + "->" + 左子节点值
                stack.push(path + "->" + node.left.val);
            }
        }
        return result; // 返回所有收集到的路径
    }
}
```

*   **思路讲解：**
    1.  使用一个栈 `stack` 来模拟递归的调用栈。
    2.  **栈元素**：栈中需要存储两部分信息：当前节点 `TreeNode` 和到达该节点的路径 `String`。这里巧妙地使用了一个 `Object` 类型的栈，交替压入 `TreeNode` 对象和 `String` 对象。另一种方法是创建一个包含 `TreeNode` 和 `String` 的自定义类 `Pair`，或者使用两个栈（一个存节点，一个存路径）并保持同步。
    3.  **初始化**：将根节点和根节点的初始路径（即根节点值的字符串）压入栈。注意压栈顺序，保证出栈时能正确配对。
    4.  **循环**：当栈不为空时，循环执行：
        *   **出栈**：弹出路径字符串和对应的节点。
        *   **判断叶子节点**：检查弹出的节点是否为叶子节点。如果是，将路径字符串加入结果列表。
        *   **压入子节点**：如果节点有子节点，将子节点及其对应的**新路径**（当前路径 + "->" + 子节点值）压入栈。**注意压栈顺序**：通常先压右子节点（及其路径），再压左子节点（及其路径），这样根据栈的 LIFO 特性，会优先处理左子树，模拟了递归中的先左后右的 DFS 行为。
    5.  **无显式回溯**：迭代方法通过栈来管理访问顺序和状态，不需要像递归方法一那样显式的 `remove` 操作。当处理完一个节点（包括其子树）后，它自然就从栈中弹出了，相当于完成了回溯。

---

**如何独立写出该题目**

1.  **理解题意与目标：** 明确要找的是从根到所有叶子节点的路径。
2.  **选择算法：** 意识到需要遍历树，并且路径探索具有“一条路走到黑”的特点，优先考虑深度优先搜索 (DFS)。
3.  **思考 DFS 实现方式：**
    *   **递归：** 这是最自然的 DFS 实现。
        *   **设计递归函数:** 需要哪些参数？至少需要当前节点 `node`。还需要什么来记录路径？
            *   *想法1:* 用一个列表记录路径上的节点值。递归函数需要 `(node, currentPathList, resultList)`。
            *   *想法2:* 直接传递构建中的路径字符串。递归函数需要 `(node, currentPathString, resultList)`。
        *   **确定基线条件 (Base Case):**
            *   遇到 `null` 节点：直接返回。
            *   遇到叶子节点：处理当前路径（构建字符串），将其加入结果列表，然后返回。
        *   **确定递归步骤:**
            *   处理当前节点：将其加入路径（如果是列表方式）或构建新的路径字符串（如果是字符串方式）。
            *   递归调用：对非空的左右子节点进行递归调用，传递更新后的路径信息。
            *   **思考回溯（非常重要！）:** 如果使用可变对象（如 `List`）记录路径，一定要在从子递归返回后，撤销对路径所做的更改（回溯）。如果传递的是不可变对象（如 `String`，并且每次都创建新的），则不需要显式回溯。
    *   **迭代 (使用栈)：** 如果不想用递归，或者需要处理非常深的树（避免栈溢出），可以考虑迭代。
        *   **模拟递归栈:** 需要一个栈来存储待访问的节点。
        *   **状态保存:** 栈中不仅要存节点，还要存到达该节点的状态，即当前的路径。如何存？（用 `Object` 栈交替存，用 `Pair` 对象，用两个栈）。
        *   **处理流程:**
            *   初始化：将根节点和初始路径压栈。
            *   循环：当栈不为空，弹出一个状态（节点+路径）。
            *   检查：是否是叶子节点？是则记录路径。
            *   扩展：将子节点和对应的新路径压栈（注意顺序，通常先右后左，以模拟先处理左）。
4.  **编写代码与细节处理：**
    *   注意边界条件：空树 (`root == null`)。
    *   路径格式化：使用 `StringBuilder` 拼接字符串以提高效率，注意最后一个节点后没有 "->"。
    *   选择数据结构：根据递归/迭代方式选择合适的结构（`List`, `String`, `Stack`, `Pair`）。
5.  **测试：** 用示例测试，考虑特殊情况（只有根节点，单链条树，完全二叉树等）。

通过以上步骤，理解核心是 DFS，然后选择递归或迭代实现，并仔细考虑状态传递（路径记录）和回溯（如果是递归且使用可变对象），就能独立地解决这个问题。 递归的两种方式各有优劣，方式一（列表）回溯更清晰，方式二（字符串）代码可能更简洁；迭代方式则避免了递归深度限制。





### 递归回溯法，无注释。学自代码随想录。





```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        // 递归回溯法

        LinkedList<String> rets = new LinkedList<String>();

        LinkedList<Integer> path = new LinkedList<Integer>();


        traversal( root, path, rets );


        return rets;

        
    }






    public void traversal( TreeNode node, LinkedList<Integer> path, LinkedList<String> rets ) {




        if( node != null ) {

            path.offer( node.val );
        }


        if( node.left == null && node.right == null ) {
            // node为叶子节点

            StringBuilder sb = new StringBuilder();


            for( int i=0; i <= path.size() - 2; i++ ) {
                
                
                sb.append( path.get(i) ).append("->");


            }

            sb.append( path.getLast() );


            

            rets.add( sb.toString() );


            return;

        }


        if( node.left != null ) {

            traversal( node.left, path, rets );


            path.removeLast();

        }

        if( node.right != null ) {

            traversal( node.right, path, rets );

            path.removeLast();

        }
        




        return;



    }





}

```

在我的代码中嵌入详细注释说明和解题思路的文字总结，使其易于理解和复习。





### 递归回溯法，注释版。学自代码随想录。


```java
import java.util.List;
import java.util.LinkedList;
import java.lang.StringBuilder;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
     * 叶子节点 是指没有子节点的节点。
     * <p>
     * 解题思路： 递归回溯法 (Depth First Search with Backtracking)
     * <p>
     * 1.  使用深度优先搜索 (DFS) 遍历二叉树的所有可能路径。
     * 2.  使用一个 LinkedList (path) 来记录从根节点到当前节点的路径上的节点值。
     * 3.  当遍历到叶子节点时，将当前 path 转换为字符串格式，并添加到结果列表 (rets)。
     * 4.  在递归遍历过程中，使用回溯技巧，保证在探索完一个分支后，path 列表能正确回退到父节点的状态，以便继续探索其他分支。
     *
     * @param root 二叉树的根节点
     * @return 包含所有从根节点到叶子节点路径的字符串列表
     */
    public List<String> binaryTreePaths(TreeNode root) {
        // rets 用于存储最终结果，即所有根到叶子节点的路径字符串
        LinkedList<String> rets = new LinkedList<String>();

        // path 用于记录当前从根节点到当前节点的路径上的节点值 (Integer 类型)
        LinkedList<Integer> path = new LinkedList<Integer>();


        traversal(root, path, rets); // 调用递归遍历函数，开始遍历二叉树


        return rets; // 返回存储所有路径字符串的结果列表

    }


    /**
     * 递归遍历二叉树的函数，用于寻找所有根节点到叶子节点的路径
     *
     * @param node 当前遍历到的节点
     * @param path 当前路径，记录从根节点到当前节点的所有节点值
     * @param rets 存储结果的列表，用于收集所有根到叶子节点的路径字符串
     */
    public void traversal(TreeNode node, LinkedList<Integer> path, LinkedList<String> rets) {

        // 递归终止条件/处理节点逻辑：如果当前节点不为空，则将其值加入到 path 列表中
        if (node != null) {
            path.offer(node.val); // 使用 offer() 方法将当前节点的值添加到 path 列表的末尾 (LinkedList 实现了 Deque 接口)
        } else {
            // 如果节点为空，则直接返回，不做任何处理
            return;
        }


        // 终止条件：当遍历到叶子节点时 (没有左子节点和右子节点)
        if (node.left == null && node.right == null) {
            // node 为叶子节点

            StringBuilder sb = new StringBuilder(); // 使用 StringBuilder 高效构建路径字符串


            // 遍历 path 列表，构建路径字符串，除了最后一个节点外，每个节点后面都添加 "->"
            for (int i = 0; i <= path.size() - 2; i++) {

                sb.append(path.get(i)).append("->"); // 将节点值和 "->" 追加到 StringBuilder
            }

            sb.append(path.getLast()); // 将路径中的最后一个节点值添加到 StringBuilder，末尾不需要 "->"


            rets.add(sb.toString()); // 将 StringBuilder 构建的路径字符串转换为 String 类型，并添加到结果列表 rets 中


            return; // 结束当前递归分支，因为已经找到一条完整的根到叶子节点的路径

        }


        // 递归遍历左子树
        if (node.left != null) {
            traversal(node.left, path, rets); // 递归调用 traversal 函数，遍历左子节点及其子树

            path.removeLast(); // 回溯操作：当左子树遍历完成后，需要将 path 列表中最后添加的节点移除
            // 这样做是为了在返回到父节点后，path 列表恢复到遍历左子树之前的状态，以便正确地遍历右子树
        }

        // 递归遍历右子树
        if (node.right != null) {
            traversal(node.right, path, rets); // 递归调用 traversal 函数，遍历右子节点及其子树

            path.removeLast(); // 回溯操作：当右子树遍历完成后，需要将 path 列表中最后添加的节点移除
            // 这样做是为了在返回到父节点后，path 列表恢复到遍历右子树之前的状态，以便在更上层的递归调用中继续正确探索其他分支
        }


        return; // 当前节点不是叶子节点，且已经递归遍历了其左右子树 (如果存在)，函数返回，继续上层递归调用
    }


}
```

**解题思路总结:**

这段代码使用**递归回溯法 (Depth First Search with Backtracking)** 来解决“二叉树的所有路径”问题。核心思想如下：

1.  **深度优先搜索 (DFS):**  代码通过递归的方式，优先向树的深层遍历，即先尽可能地访问节点的左子树，然后再访问右子树，这是一种典型的 DFS 策略。

2.  **路径记录 (path):**  使用一个 `LinkedList<Integer> path` 来动态地记录从根节点到当前节点的访问路径。每当访问到一个新节点，就将其值添加到 `path` 的末尾。

3.  **叶子节点判断与路径保存:** 当 DFS 遍历到一个**叶子节点**（即没有左右子节点的节点）时，说明找到了一条完整的从根到叶子的路径。此时，将 `path` 中记录的节点值转换为字符串形式（用 "->" 连接），并将这个字符串路径添加到结果列表 `rets` 中。

4.  **回溯 (Backtracking):**  在递归调用 `traversal` 函数遍历完一个节点的左子树和右子树后，需要执行 `path.removeLast()` 操作。这个操作是**回溯**的关键步骤。它的作用是：
    *   **恢复路径状态:**  将 `path` 列表恢复到调用遍历当前节点的子树之前的状态。 也就是说，当从一个子树的递归调用返回时，需要将当前节点从 `path` 中移除，这样在探索下一个分支（例如，从左子树返回后，准备探索右子树）时，`path` 列表才代表的是正确的、从根节点到当前父节点的路径，而不是包含了之前已探索子树路径的错误状态。
    *   **保证路径独立性:**  回溯确保了在探索不同分支时，`path` 列表记录的路径是独立的，不会互相干扰。这样才能正确地找出所有从根到叶子的路径。

5.  **结果收集 (rets):**  使用 `LinkedList<String> rets` 来存储最终的结果。每当在叶子节点处找到一条路径并转换为字符串后，就将其添加到 `rets` 列表中。

总而言之，这段代码通过递归实现 DFS 遍历，利用 `path` 列表记录访问路径，并在到达叶子节点时保存路径，同时通过回溯操作保证在不同分支的探索过程中路径记录的正确性，最终收集到所有根到叶子节点的路径。





---























## 力扣404. 左叶子之和

给定二叉树的根节点 root ，返回所有左叶子之和。

 

示例 1：

输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

示例 2:

输入: root = [1]
输出: 0
 

提示:

节点数在 [1, 1000] 范围内
-1000 <= Node.val <= 1000




### 递归法 (后序遍历思想)，无注释


```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        // 递归法，后序遍历

        int sum=0;

        if( root == null ) {

            return 0;
        }

        if( root.left == null && root.right == null ) {

            return 0;
        }

        int leftSum = sumOfLeftLeaves( root.left );

        if( root.left != null && root.left.left == null && root.left.right == null ) {
            // 说明当前root的left为左叶子节点


            sum += root.left.val;

        }


        int rightSum = sumOfLeftLeaves( root.right );

        
        sum += leftSum + rightSum ;



        return sum;


    }
}

```


命令：
1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明







### 递归法 (后序遍历思想)，注释版




```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 404. 左叶子之和
     *
     * 给定二叉树的根节点 root ，返回所有左叶子之和。
     *
     * 叶子节点 是指没有子节点的节点。
     * 左叶子节点是父节点的左子节点，并且它自身是叶子节点。
     *
     * 解题思路： 递归法 (后序遍历思想)
     *
     * 1.  **递归函数定义:**  `sumOfLeftLeaves(TreeNode root)` 函数计算以 `root` 为根节点的二叉树的所有左叶子之和。
     * 2.  **递归终止条件:**
     *     - 如果 `root` 为 `null` (空节点)，则没有左叶子，返回 0。
     *     - 如果 `root` 是叶子节点 (没有左右子节点)，但它本身不是左叶子（因为我们需要判断它的父节点是否将其作为左子节点），所以即使是叶子节点，如果不是左叶子，也返回 0。 叶子节点本身不直接决定结果，而是要看它是否是*左*叶子。
     * 3.  **递归逻辑 (后序遍历思想):**
     *     - 递归遍历左子树： `sumOfLeftLeaves(root.left)` 计算左子树的左叶子之和。
     *     - 判断当前节点的左子节点是否为左叶子：
     *       - 如果 `root.left` 存在 (不为空)，并且 `root.left` 是叶子节点 (即 `root.left.left == null && root.left.right == null`)，
     *       - 则 `root.left` 是一个左叶子节点，将其值 `root.left.val` 加到总和 `sum` 中。
     *     - 递归遍历右子树： `sumOfLeftLeaves(root.right)` 计算右子树的左叶子之和。
     *     - 将左子树的左叶子之和 `leftSum`、当前节点左叶子判断的结果 (可能是 0 或 左叶子的值) 以及右子树的左叶子之和 `rightSum` 相加，得到以 `root` 为根节点的二叉树的左叶子总和。
     * 4.  **返回值:** 返回计算得到的左叶子之和。
     *
     * 注意： 此代码实际上更偏向于后序遍历的思想，因为它先递归处理左右子树，再在当前节点判断左叶子并累加。
     *       更简洁的思路可以在前序遍历或中序遍历中，在遍历到父节点时，判断其左子节点是否为左叶子，如果是则累加。
     */
    public int sumOfLeftLeaves(TreeNode root) {
        // 初始化左叶子之和
        int sum = 0;

        // 递归终止条件：如果当前节点为空，则返回 0，因为空节点没有左叶子
        if (root == null) {
            return 0;
        }

        // 递归终止条件：如果当前节点是叶子节点（没有左右子节点），但叶子节点本身不一定是左叶子，所以这里直接返回0。
        // 因为我们需要判断当前节点的*左子节点*是否为左叶子，而不是当前节点本身是否为叶子。
        if (root.left == null && root.right == null) {
            return 0;
        }

        // 递归计算左子树的左叶子之和
        int leftSum = sumOfLeftLeaves(root.left);

        // 判断当前节点的左子节点是否为左叶子节点
        // 条件1: root.left != null  确保左子节点存在
        // 条件2: root.left.left == null && root.left.right == null  确保左子节点是叶子节点 (没有左右子节点)
        if (root.left != null && root.left.left == null && root.left.right == null) {
            // 如果满足以上条件，说明 root 的左子节点是左叶子节点
            // 将左叶子节点的值加到 sum 中
            sum += root.left.val;
        }

        // 递归计算右子树的左叶子之和 (注意：右子树的左叶子仍然需要计算，但我们只关注*左*叶子)
        int rightSum = sumOfLeftLeaves(root.right);

        // 将左子树的左叶子之和、当前节点判断的左叶子值、右子树的左叶子之和累加起来
        sum += leftSum + rightSum;

        // 返回以当前节点为根的子树的左叶子之和
        return sum;
    }
}
```

**代码的详细讲解说明，结合示例：**

让我们结合示例 **示例 1： `root = [3,9,20,null,null,15,7]`** 来详细讲解代码的执行流程和解题思路。

**示例 1 二叉树结构:**

```
      3
     / \
    9  20
   /  / \
  null 15  7
     / \
    null null
```

**1. `sumOfLeftLeaves(root: 3)` (初始调用，根节点为 3)**

   - `root` (3) 不为 `null`，也不是叶子节点 (有左右子节点)。
   - 计算 `leftSum = sumOfLeftLeaves(root.left: 9)`  （递归调用左子树，根节点为 9）。
   - 判断 `root.left` (9) 是否为左叶子：
     - `root.left` (9) 不为 `null`。
     - `root.left.left` (null) 为 `null` 且 `root.left.right` (null) 为 `null`，所以 `root.left` (9) 是叶子节点。
     - 因此， **9 是节点 3 的左叶子**。 `sum += root.left.val`， `sum` 变为 `0 + 9 = 9`。
   - 计算 `rightSum = sumOfLeftLeaves(root.right: 20)` （递归调用右子树，根节点为 20）。
   - `sum += leftSum + rightSum`，当前 `sum` 变为 `9 + leftSum + rightSum`。  此时 `leftSum` 和 `rightSum` 的值还需要通过递归调用计算出来。

**2. `sumOfLeftLeaves(root: 9)` (递归调用，根节点为 9)**

   - `root` (9) 不为 `null`，但它是叶子节点 (因为 `root.left` 和 `root.right` 都是 `null`)。
   - 进入 `if (root.left == null && root.right == null)` 条件，返回 `0`。
   - 所以 `leftSum` (在步骤 1 中)  = `0`。

**3. `sumOfLeftLeaves(root: 20)` (递归调用，根节点为 20)**

   - `root` (20) 不为 `null`，也不是叶子节点 (有左右子节点)。
   - 计算 `leftSum = sumOfLeftLeaves(root.left: 15)` （递归调用左子树，根节点为 15）。
   - 判断 `root.left` (15) 是否为左叶子：
     - `root.left` (15) 不为 `null`。
     - `root.left.left` (null) 为 `null` 且 `root.left.right` (null) 为 `null`，所以 `root.left` (15) 是叶子节点.
     - 因此， **15 是节点 20 的左叶子**。 `sum += root.left.val`， `sum` 变为 `0 + 15 = 15` (注意，这里的 `sum` 是在 `sumOfLeftLeaves(root: 20)` 这个函数调用内部的局部变量 `sum`，初始值为 0)。
   - 计算 `rightSum = sumOfLeftLeaves(root.right: 7)` （递归调用右子树，根节点为 7）。
   - `sum += leftSum + rightSum`，当前 `sum` (在 `sumOfLeftLeaves(root: 20)`) 变为 `15 + leftSum + rightSum`。 此时 `leftSum` 和 `rightSum` 的值还需要通过递归调用计算出来。

**4. `sumOfLeftLeaves(root: 15)` (递归调用，根节点为 15)**

   - `root` (15) 不为 `null`，但它是叶子节点 (因为 `root.left` 和 `root.right` 都是 `null`)。
   - 进入 `if (root.left == null && root.right == null)` 条件，返回 `0`。
   - 所以 `leftSum` (在步骤 3 中) = `0`。

**5. `sumOfLeftLeaves(root: 7)` (递归调用，根节点为 7)**

   - `root` (7) 不为 `null`，但它是叶子节点 (因为 `root.left` 和 `root.right` 都是 `null`)。
   - 进入 `if (root.left == null && root.right == null)` 条件，返回 `0`。
   - 所以 `rightSum` (在步骤 3 中) = `0`。

**递归结果回溯：**

- 在步骤 5 中，`sumOfLeftLeaves(root: 7)` 返回 `0`，所以步骤 3 中的 `rightSum` = `0`。
- 在步骤 4 中， `sumOfLeftLeaves(root: 15)` 返回 `0`，所以步骤 3 中的 `leftSum` = `0`。
- 因此，步骤 3 中， `sum` (对于根节点 20 的 `sumOfLeftLeaves` 调用) 最终计算为 `15 + 0 + 0 = 15`，并返回 `15`。  所以步骤 1 中的 `rightSum` = `15`。
- 在步骤 2 中，`sumOfLeftLeaves(root: 9)` 返回 `0`，所以步骤 1 中的 `leftSum` = `0`。
- 因此，步骤 1 中， `sum` (对于根节点 3 的 `sumOfLeftLeaves` 初始调用) 最终计算为 `9 + 0 + 15 = 24`，并返回 `24`。

**最终结果： 24**

**示例 2: `root = [1]`**

- `sumOfLeftLeaves(root: 1)`
- `root` (1) 不为 `null`， 并且是叶子节点。
- 进入 `if (root.left == null && root.right == null)` 条件， 返回 `0`。

**最终结果: 0**

**总结：**

代码通过递归地遍历二叉树，并在遍历过程中判断每个节点的左子节点是否为左叶子节点。如果是，则累加其值。 递归的终止条件是遇到空节点或者叶子节点（但叶子节点本身不直接加和，而是作为左叶子判断的条件）。 通过后序遍历的思想（先处理子树，再处理当前节点），确保在判断一个节点是否为左叶子时，其父节点的信息是可用的。



















---











## 力扣513. 找树左下角的值

给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。

假设二叉树中至少有一个节点。

 

示例 1:

输入: root = [2,1,3]
输出: 1

示例 2:

输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7






### 迭代法（层序遍历），无注释



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int findBottomLeftValue(TreeNode root) {



        
        Queue<TreeNode> que = new LinkedList<TreeNode>();

        List<List<Integer>> rets = new LinkedList();


        que.offer(root);

        
        while( !que.isEmpty() ) {


            int size = que.size();

            List<Integer> linelist = new LinkedList(); 



            for( int i=0; i < size; i++ ) {




                TreeNode node = new TreeNode();

                node = que.poll();

                linelist.add( node.val );


                if( node.left != null ) {

                    que.offer( node.left );

                }

                if( node.right != null ) {

                    que.offer( node.right );
                    
                }



            }


            rets.add( linelist );



        }




        return rets.getLast().getFirst();


        
    }
}

```


命令：
1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明











### 迭代法（层序遍历），注释版







```java
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * 513. 找树左下角的值
     *
     * 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。
     * 假设二叉树中至少有一个节点。
     *
     * 解题思路： 广度优先搜索 (BFS) - 层序遍历
     *
     * 1.  **层序遍历:** 使用广度优先搜索 (BFS) 遍历二叉树，逐层访问节点。
     * 2.  **记录每层节点:** 在 BFS 过程中，记录每一层的所有节点值。由于 BFS 是从左到右遍历每一层的，因此每层列表的第一个元素就是该层最左边的节点值。
     * 3.  **获取最后一层最左节点:**  当 BFS 完成后，结果列表 `rets` 中存储了所有层的节点值列表。由于我们是层序遍历，列表的最后一个元素就是树的最底层的所有节点值。而这个列表的第一个元素，就是最底层最左边的节点的值。
     * 4.  **返回值:** 返回结果列表 `rets` 中最后一个列表的第一个元素，即为二叉树最底层最左边节点的值。
     *
     * 示例：
     *
     * 示例 1:  root = [2,1,3]
     *
     *       2
     *      / \
     *     1   3
     *
     *   BFS 过程:
     *   - Level 1: [2]
     *   - Level 2: [1, 3]
     *   结果 rets = [[2], [1, 3]]
     *   最底层最左节点值: rets.getLast().getFirst() = 1
     *
     * 示例 2: root = [1,2,3,4,null,5,6,null,null,7]
     *
     *         1
     *       /  \
     *      2    3
     *     / \  / \
     *    4  null 5 6
     *   / \
     *  7  null
     *
     *   BFS 过程:
     *   - Level 1: [1]
     *   - Level 2: [2, 3]
     *   - Level 3: [4, 5, 6]
     *   - Level 4: [7]
     *   结果 rets = [[1], [2, 3], [4, 5, 6], [7]]
     *   最底层最左节点值: rets.getLast().getFirst() = 7
     */
    public int findBottomLeftValue(TreeNode root) {

        // 创建一个队列，用于广度优先搜索 (BFS)，LinkedList 实现了 Queue 接口
        Queue<TreeNode> que = new LinkedList<TreeNode>();

        // 创建一个列表的列表，用于存储每一层的节点值，方便后续获取最后一层和最左边的值
        List<List<Integer>> rets = new LinkedList();

        // 将根节点加入队列，开始 BFS
        que.offer(root);

        // 当队列不为空时，继续 BFS 遍历
        while (!que.isEmpty()) {

            // 获取当前队列的大小，即当前层的节点数量
            int size = que.size();

            // 创建一个新的列表，用于存储当前层的节点值
            List<Integer> linelist = new LinkedList();

            // 遍历当前层的所有节点 (数量为 size)
            for (int i = 0; i < size; i++) {

                // 创建一个 TreeNode 类型的变量 node，用于接收从队列中取出的节点
                TreeNode node = new TreeNode();

                // 从队列中取出一个节点，并赋值给 node
                node = que.poll();

                // 将当前节点的值添加到当前层的值列表 linelist 中
                linelist.add(node.val);

                // 如果当前节点的左子节点不为空，则将左子节点加入队列，以便下一层遍历
                if (node.left != null) {
                    que.offer(node.left);
                }

                // 如果当前节点的右子节点不为空，则将右子节点加入队列，以便下一层遍历
                if (node.right != null) {
                    que.offer(node.right);
                }
            }

            // 当遍历完当前层的所有节点后，将当前层的节点值列表 linelist 添加到结果列表 rets 中
            rets.add(linelist);
        }

        // BFS 结束后，rets 列表中存储了每一层的节点值列表
        // 最底层的值存储在 rets 的最后一个列表中，最左边的值是该列表的第一个元素
        // rets.getLast() 获取最后一个列表 (最底层的节点值列表)
        // getFirst() 获取最后一个列表的第一个元素 (最底层最左边的节点值)
        return rets.getLast().getFirst();
    }
}
```

**代码的详细讲解说明，结合示例：**

让我们结合示例 **示例 2: `root = [1,2,3,4,null,5,6,null,null,7]`** 来详细讲解代码的执行流程和解题思路。

**示例 2 二叉树结构:**

```
         1
       /  \
      2    3
     / \  / \
    4  null 5 6
   / \
  7  null
```

**1. 初始化:**

   - `que` 队列初始化为空。
   - `rets` 列表初始化为空。
   - 根节点 `1` 加入队列 `que`。

**2. 开始 BFS 循环 (`while (!que.isEmpty())`)**

   **第一轮循环:**
   - `size = que.size() = 1` (当前层只有一个节点 1)。
   - `linelist` 初始化为空列表 `[]`。
   - **For 循环 (i=0; i<size=1):**
     - `node = que.poll() = 1` (从队列取出节点 1)。
     - `linelist.add(node.val) = linelist.add(1)`， `linelist` 变为 `[1]`。
     - `node.left != null` (节点 1 的左子节点 2 不为空)， `que.offer(node.left: 2)`， 节点 2 加入队列 `que`。
     - `node.right != null` (节点 1 的右子节点 3 不为空)， `que.offer(node.right: 3)`， 节点 3 加入队列 `que`。
   - For 循环结束。
   - `rets.add(linelist)`， 将 `linelist` (当前层的值列表 `[1]`) 添加到 `rets`， `rets` 变为 `[[1]]`。

   **第二轮循环:**
   - `size = que.size() = 2` (当前层有两个节点 2 和 3)。
   - `linelist` 初始化为空列表 `[]`。
   - **For 循环 (i=0; i<size=2):**
     - **i=0:**
       - `node = que.poll() = 2` (从队列取出节点 2)。
       - `linelist.add(node.val) = linelist.add(2)`， `linelist` 变为 `[2]`。
       - `node.left != null` (节点 2 的左子节点 4 不为空)， `que.offer(node.left: 4)`， 节点 4 加入队列 `que`。
       - `node.right == null` (节点 2 的右子节点为空)，不执行 `que.offer(node.right)`。
     - **i=1:**
       - `node = que.poll() = 3` (从队列取出节点 3)。
       - `linelist.add(node.val) = linelist.add(3)`， `linelist` 变为 `[2, 3]`。
       - `node.left != null` (节点 3 的左子节点 5 不为空)， `que.offer(node.left: 5)`， 节点 5 加入队列 `que`。
       - `node.right != null` (节点 3 的右子节点 6 不为空)， `que.offer(node.right: 6)`， 节点 6 加入队列 `que`。
   - For 循环结束.
   - `rets.add(linelist)`， 将 `linelist` (当前层的值列表 `[2, 3]`) 添加到 `rets`， `rets` 变为 `[[1], [2, 3]]`。

   **第三轮循环:**
   - `size = que.size() = 3` (当前层有三个节点 4, 5, 6)。
   - `linelist` 初始化为空列表 `[]`。
   - **For 循环 (i=0; i<size=3):**
     - **i=0:**
       - `node = que.poll() = 4` (从队列取出节点 4)。
       - `linelist.add(node.val) = linelist.add(4)`， `linelist` 变为 `[4]`。
       - `node.left != null` (节点 4 的左子节点 7 不为空)， `que.offer(node.left: 7)`， 节点 7 加入队列 `que`。
       - `node.right == null` (节点 4 的右子节点为空)，不执行 `que.offer(node.right)`。
     - **i=1:**
       - `node = que.poll() = 5` (从队列取出节点 5)。
       - `linelist.add(node.val) = linelist.add(5)`， `linelist` 变为 `[4, 5]`。
       - `node.left == null` (节点 5 的左子节点为空)，不执行 `que.offer(node.left)`。
       - `node.right != null` (节点 5 的右子节点为空)， 不为空，但是根据示例，右子节点是 null，所以实际上 `node.right == null`，不执行 `que.offer(node.right)`。 (更正：根据示例图，节点 5 没有左右子节点，都为 null)
     - **i=2:**
       - `node = que.poll() = 6` (从队列取出节点 6)。
       - `linelist.add(node.val) = linelist.add(6)`， `linelist` 变为 `[4, 5, 6]`。
       - `node.left == null` (节点 6 的左右子节点都为空)， 不执行 `que.offer(node.left)` 和 `que.offer(node.right)`。
   - For 循环结束.
   - `rets.add(linelist)`， 将 `linelist` (当前层的值列表 `[4, 5, 6]`) 添加到 `rets`， `rets` 变为 `[[1], [2, 3], [4, 5, 6]]`。

   **第四轮循环:**
   - `size = que.size() = 1` (当前层只有一个节点 7)。
   - `linelist` 初始化为空列表 `[]`。
   - **For 循环 (i=0; i<size=1):**
     - `node = que.poll() = 7` (从队列取出节点 7)。
     - `linelist.add(node.val) = linelist.add(7)`， `linelist` 变为 `[7]`。
     - `node.left == null` 且 `node.right == null` (节点 7 是叶子节点)，不执行 `que.offer(node.left)` 和 `que.offer(node.right)`。
   - For 循环结束.
   - `rets.add(linelist)`， 将 `linelist` (当前层的值列表 `[7]`) 添加到 `rets`， `rets` 变为 `[[1], [2, 3], [4, 5, 6], [7]]`。

   **第五轮循环:**
   - `que.isEmpty() == true`， 循环结束。

**3. 返回结果:**

   - `rets.getLast() = [7]` (获取 `rets` 的最后一个列表，即最底层的节点值列表)。
   - `rets.getLast().getFirst() = 7` (获取最后一个列表的第一个元素，即最底层最左边的节点值)。
   - 返回 `7`。

**最终结果： 7**

**总结：**

代码通过 BFS 层序遍历二叉树，将每一层的节点值保存在 `rets` 列表中。 由于 BFS 保证了从左到右的遍历顺序，并且逐层处理，所以 `rets` 列表中最后一个列表的第一个元素必然是二叉树最底层最左边的节点值。  这种方法直观且易于理解，通过层序遍历可以有效地找到目标节点。












---




















## 力扣700. 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

 

示例 1:

输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]

示例 2:

输入：root = [4,2,7,1,3], val = 5
输出：[]
 

提示：

树中节点数在 [1, 5000] 范围内
1 <= Node.val <= 10^7
root 是二叉搜索树
1 <= val <= 10^7













### 递归法，无注释


```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {

        if( root == null ) {

            return null;
        }


        if( val == root.val ) {

            return root;

        }

        TreeNode result = new TreeNode();

        if( val < root.val ) {

            result = searchBST( root.left, val );

        }

        if( val > root.val ) {

            result = searchBST( root.right,val );

        }


        return result;
        
    }
}


```


命令：
1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明






### 递归法，注释版





Okay, let's break down the provided Java code for LeetCode 700 "Search in a Binary Search Tree" with detailed comments and explanations.

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val; // Node's value
 *     TreeNode left; // Reference to the left child
 *     TreeNode right; // Reference to the right child
 *     TreeNode() {} // Default constructor
 *     TreeNode(int val) { this.val = val; } // Constructor with value
 *     TreeNode(int val, TreeNode left, TreeNode right) { // Constructor with value and children
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

/**
 * LeetCode 700: 二叉搜索树中的搜索
 *
 * 问题描述：
 * 给定一个二叉搜索树 (BST) 的根节点 root 和一个整数值 val。
 * 需要在 BST 中找到节点值等于 val 的节点。如果找到，返回以该节点为根的子树；
 * 如果节点不存在，则返回 null。
 *
 * 解题思路总结 (递归):
 * 利用二叉搜索树 (BST) 的核心性质：
 * 1. 若左子树不空，则左子树上所有节点的值均小于它的根节点的值。
 * 2. 若右子树不空，则右子树上所有节点的值均大于它的根节点的值。
 * 3. 左、右子树也分别为二叉搜索树。
 *
 * 递归地进行搜索：
 * - Base Case 1: 如果当前节点 (root) 为 null，表示在这条路径上没找到，返回 null。
 * - Base Case 2: 如果当前节点的值 root.val 等于目标值 val，表示找到了，返回当前节点 root。
 * - Recursive Step 1: 如果目标值 val 小于当前节点的值 root.val，则目标节点只可能在左子树中，
 *   递归地在左子树中搜索 searchBST(root.left, val)。
 * - Recursive Step 2: 如果目标值 val 大于当前节点的值 root.val，则目标节点只可能在右子树中，
 *   递归地在右子树中搜索 searchBST(root.right, val)。
 * 最终返回递归调用的结果。
 */
class Solution {
    /**
     * 在给定的二叉搜索树 (BST) 中搜索值为 val 的节点。
     * @param root BST 的根节点
     * @param val 要搜索的目标值
     * @return 如果找到，返回值为 val 的节点（及其子树）；否则返回 null。
     */
    public TreeNode searchBST(TreeNode root, int val) {

        // Base Case 1: 如果当前节点为 null
        // 这意味着我们沿着一条路径到达了叶子节点的末端，或者树本身就是空的。
        // 在这种情况下，目标值 val 在这条路径上不存在，返回 null。
        if( root == null ) {
            return null;
        }

        // Base Case 2: 如果当前节点的值等于目标值 val
        // 我们找到了目标节点！根据题目要求，返回以该节点为根的子树，即返回当前节点 root。
        if( val == root.val ) {
            return root;
        }

        // 注意：虽然这里初始化了 result，但在递归逻辑中它会被覆盖。
        // 如果 val 不等于 root.val，那么 result 最终会接收来自左子树或右子树搜索的结果。
        // 一个更简洁的写法是直接在 if/else if 中 return 递归调用的结果。
        TreeNode result = null; // 初始化 result 为 null，以防万一 val 既不小于也不大于 root.val（虽然这种情况已被上面的 if 处理）

        // Recursive Step 1: 如果目标值 val 小于当前节点的值 root.val
        // 利用 BST 的性质，目标值只可能存在于左子树中。
        // 递归调用 searchBST 在左子树 (root.left) 中继续搜索 val。
        // 将递归调用的结果（找到的节点或 null）赋值给 result。
        if( val < root.val ) {
            result = searchBST( root.left, val );
        }

        // Recursive Step 2: 如果目标值 val 大于当前节点的值 root.val
        // 利用 BST 的性质，目标值只可能存在于右子树中。
        // 递归调用 searchBST 在右子树 (root.right) 中继续搜索 val。
        // 将递归调用的结果（找到的节点或 null）赋值给 result。
        if( val > root.val ) {
            result = searchBST( root.right, val );
        }

        // 返回搜索结果。
        // 如果在某个递归步骤中找到了节点 (val == root.val)，该节点会被层层返回。
        // 如果搜索完所有相关路径都没有找到 (最终遇到 null)，null 会被层层返回。
        // result 变量存储了从相关子树（左或右）返回的结果。
        return result;

        /*
         * 更简洁的写法（避免显式使用 result 变量）:
         *
         * if (root == null || root.val == val) {
         *     return root; // Base cases: null or found
         * } else if (val < root.val) {
         *     return searchBST(root.left, val); // Recurse left
         * } else { // val > root.val
         *     return searchBST(root.right, val); // Recurse right
         * }
         */
    }
}
```

**结合示例和代码进行详细讲解说明**

**核心思想:** 二叉搜索树的结构允许我们非常高效地进行查找。每次将目标值 `val` 与当前节点 `root.val` 比较，就能确定下一步应该去左子树还是右子树搜索，或者已经找到了目标。这排除了树的很大一部分，使得搜索路径非常直接。

**代码逻辑逐步分析 (以示例 1: `root = [4,2,7,1,3], val = 2` 为例):**

1.  **初始调用**: `searchBST(node 4, 2)`
    *   `root` (node 4) 不为 `null`。
    *   `val` (2) 不等于 `root.val` (4)。
    *   `val` (2) 小于 `root.val` (4)。
    *   进入 `if (val < root.val)` 分支。
    *   **递归调用**: `searchBST(node 2, 2)` (node 2 是 node 4 的左子节点)。

2.  **递归调用 1**: `searchBST(node 2, 2)`
    *   `root` (node 2) 不为 `null`。
    *   `val` (2) 等于 `root.val` (2)。
    *   进入 `if (val == root.val)` 分支。
    *   **返回**: `node 2` (找到了目标节点)。

3.  **返回结果**:
    *   上一步返回的 `node 2` 被赋值给第一层调用中的 `result` 变量。
    *   第一层调用 `searchBST(node 4, 2)` 的最后一行 `return result;` 执行，返回 `node 2`。

**最终输出**: 返回的是值为 2 的节点，其子树结构是 `[2, 1, 3]`。

**代码逻辑逐步分析 (以示例 2: `root = [4,2,7,1,3], val = 5` 为例):**

1.  **初始调用**: `searchBST(node 4, 5)`
    *   `root` (node 4) 不为 `null`。
    *   `val` (5) 不等于 `root.val` (4)。
    *   `val` (5) 大于 `root.val` (4)。
    *   进入 `if (val > root.val)` 分支。
    *   **递归调用**: `searchBST(node 7, 5)` (node 7 是 node 4 的右子节点)。

2.  **递归调用 1**: `searchBST(node 7, 5)`
    *   `root` (node 7) 不为 `null`。
    *   `val` (5) 不等于 `root.val` (7)。
    *   `val` (5) 小于 `root.val` (7)。
    *   进入 `if (val < root.val)` 分支。
    *   **递归调用**: `searchBST(null, 5)` (node 7 没有左子节点，所以 `root.left` 是 `null`)。

3.  **递归调用 2**: `searchBST(null, 5)`
    *   `root` (当前是 `null`) 等于 `null`。
    *   进入 `if (root == null)` 分支。
    *   **返回**: `null`。

4.  **返回结果**:
    *   上一步返回的 `null` 被赋值给 `递归调用 1` 中的 `result` 变量。
    *   `递归调用 1` (`searchBST(node 7, 5)`) 的最后一行 `return result;` 执行，返回 `null`。
    *   这个返回的 `null` 被赋值给 `初始调用` 中的 `result` 变量。
    *   `初始调用` (`searchBST(node 4, 5)`) 的最后一行 `return result;` 执行，返回 `null`。

**最终输出**: 返回 `null`，表示值为 5 的节点在树中不存在。输出为 `[]`。

这个递归方法简洁地利用了 BST 的性质，每次比较都能有效地缩小搜索范围，直到找到目标或到达搜索路径的尽头。








---















## 

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 贪心算法






## 力扣455. 分发饼干
已解答
简单

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

 
示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。
所以你应该输出 1。

示例 2:

输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出 2。
 

提示：

1 <= g.length <= 3 * 10^4
0 <= s.length <= 3 * 10^4
1 <= g[i], s[j] <= 2^31 - 1
 

注意：本题与 2410. 运动员和训练师的最大匹配数 题相同。



### 无注释



```java


class Solution {
    public int findContentChildren(int[] g, int[] s) {

        int cnt=0;

        int index_bis = s.length-1;

        Arrays.sort( g );

        Arrays.sort( s );


        for( int index_child = g.length-1; index_child >=0; index_child-- ) {


            if( index_bis >= 0 && s[index_bis] >= g[ index_child ] ) {

                index_bis--;

                cnt++;

            }

        }

        return cnt;
         
    }
}



```











### 注释版

命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明





好的，我们来为你在 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\数据结构与算法学习记录.md"></mcfile> 中 LeetCode 455 "分发饼干" 问题的 Java 代码添加详细注释，并结合示例进行讲解。

```java
/**
 * LeetCode 455: 分发饼干
 *
 * 问题描述：
 * 给定孩子们的胃口值数组 g 和饼干尺寸数组 s。
 * 如果 s[j] >= g[i]，则饼干 j 可以满足孩子 i。
 * 每个孩子最多只能得到一块饼干。目标是满足尽可能多的孩子。
 *
 * 解题思路总结 (贪心算法):
 * 核心思想：为了满足尽可能多的孩子，应该优先用较大的饼干满足胃口较大的孩子，
 * 或者优先用较小的饼干满足胃口较小的孩子。这样可以最大化饼干的利用效率。
 *
 * 策略一 (优先满足胃口大的孩子):
 * 1. 对孩子的胃口 g 和饼干的尺寸 s 都进行升序排序。
 * 2. 从胃口最大的孩子和尺寸最大的饼干开始，进行反向遍历。
 * 3. 使用一个指针 `index_bis` 指向当前最大的饼干，一个指针 `index_child` 指向当前胃口最大的孩子。
 * 4. 如果当前最大的饼干 `s[index_bis]` 能够满足当前胃口最大的孩子 `g[index_child]` (即 `s[index_bis] >= g[index_child]`)：
 *    - 说明这个饼干可以成功分发给这个孩子。
 *    - 满足的孩子数量 `cnt` 加 1。
 *    - 两个指针都向前移动 (`index_bis--`, `index_child--`)，考虑下一个胃口次大的孩子和下一个尺寸次大的饼干。
 * 5. 如果当前最大的饼干不能满足当前胃口最大的孩子：
 *    - 说明这个饼干对于当前孩子来说太小了，它也无法满足任何胃口比当前孩子更大的孩子（因为已经排序）。
 *    - 为了尝试满足当前孩子，我们需要一个更大的饼干，但当前已经是最大的了。
 *    - 因此，只能放弃当前孩子，将 `index_child` 向前移动 (`index_child--`)，尝试用当前的饼干去满足胃口更小的孩子。
 *    - `index_bis` 不动，因为这个饼干可能还能满足后续胃口更小的孩子。
 *    - (注：你的代码实现是：如果满足，两个指针都移动；如果不满足，只移动孩子指针。这等价于优先用大饼干满足大胃口)
 * 6. 重复步骤 4 和 5，直到孩子指针或饼干指针越界。
 *
 * 策略二 (优先满足胃口小的孩子，代码中未采用但同样有效):
 * 1. 对 g 和 s 升序排序。
 * 2. 使用两个指针，一个指向最小胃口的孩子，一个指向最小尺寸的饼干。
 * 3. 如果当前最小的饼干能满足当前最小胃口的孩子，则两个指针都向后移动，计数加一。
 * 4. 如果当前最小的饼干不能满足当前最小胃口的孩子，则只移动饼干指针，尝试用下一个更大的饼干来满足当前孩子。
 *
 * 你的代码采用了策略一的变种实现。
 */
class Solution {
    /**
     * 计算最多能满足多少个孩子的胃口
     * @param g 孩子们的胃口值数组
     * @param s 饼干的尺寸数组
     * @return 最多能满足的孩子数量
     */
    public int findContentChildren(int[] g, int[] s) {

        // 用于记录满足的孩子数量
        int cnt = 0;

        // 对孩子胃口数组进行升序排序
        Arrays.sort(g);
        // 对饼干尺寸数组进行升序排序
        Arrays.sort(s);

        // 初始化指向最大饼干的指针 (s 数组的最后一个元素)
        int index_bis = s.length - 1;

        // 从胃口最大的孩子开始反向遍历 (g 数组的最后一个元素)
        for (int index_child = g.length - 1; index_child >= 0; index_child--) {

            // 检查是否还有饼干 (index_bis >= 0)
            // 并且 当前最大的饼干尺寸是否能满足当前孩子的胃口
            if (index_bis >= 0 && s[index_bis] >= g[index_child]) {
                // 如果满足条件：
                // 1. 将这个最大的饼干分给这个孩子
                // 2. 移动饼干指针，考虑下一个尺寸次大的饼干
                index_bis--;
                // 3. 满足的孩子数量加 1
                cnt++;
                // 4. (for 循环会自动将 index_child--，移动到下一个胃口次大的孩子)
            }
            // else: 如果当前最大的饼干无法满足当前孩子，或者已经没有饼干了
            //       饼干指针 index_bis 不动 (或者已经 < 0)
            //       (for 循环会自动将 index_child--，移动到下一个胃口次大的孩子，尝试用同一个大饼干满足小一点的胃口)
        }

        // 返回最终满足的孩子数量
        return cnt;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 1: `g = [1, 2, 3]`, `s = [1, 1]`**

1.  **排序:**
    *   `g` 排序后: `[1, 2, 3]`
    *   `s` 排序后: `[1, 1]`
2.  **初始化:**
    *   `cnt = 0`
    *   `index_bis = s.length - 1 = 1` (指向 `s[1] = 1`)
3.  **循环 (从 `index_child = g.length - 1 = 2` 开始):**
    *   **`index_child = 2` (孩子胃口 `g[2] = 3`):**
        *   `index_bis = 1` (饼干尺寸 `s[1] = 1`)
        *   检查 `index_bis >= 0` (True) 且 `s[1] >= g[2]` (即 `1 >= 3`)? False.
        *   条件不满足，`index_bis` 保持 1，`cnt` 保持 0。`index_child` 减为 1。
    *   **`index_child = 1` (孩子胃口 `g[1] = 2`):**
        *   `index_bis = 1` (饼干尺寸 `s[1] = 1`)
        *   检查 `index_bis >= 0` (True) 且 `s[1] >= g[1]` (即 `1 >= 2`)? False.
        *   条件不满足，`index_bis` 保持 1，`cnt` 保持 0。`index_child` 减为 0。
    *   **`index_child = 0` (孩子胃口 `g[0] = 1`):**
        *   `index_bis = 1` (饼干尺寸 `s[1] = 1`)
        *   检查 `index_bis >= 0` (True) 且 `s[1] >= g[0]` (即 `1 >= 1`)? True.
        *   条件满足：
            *   `index_bis` 减为 0。
            *   `cnt` 增为 1。
        *   `index_child` 减为 -1。
4.  **循环结束 (`index_child < 0`)**
5.  **返回 `cnt = 1`**

**输出:**

`1`

这个过程展示了贪心策略如何工作：优先尝试用最大的饼干满足胃口最大的孩子。如果最大的饼干满足不了，就尝试用这个饼干去满足胃口次大的孩子，直到找到一个能被满足的孩子，或者饼干用完/孩子遍历完。









---






## 力扣376. 摆动序列
已解答
中等

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

 

示例 1：

输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

示例 2：

输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

示例 3：

输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
 

提示：

1 <= nums.length <= 1000
0 <= nums[i] <= 1000





### 贪心算法，无注释




```java




class Solution {
    public int wiggleMaxLength(int[] nums) {


        int preDiff = 0;

        int curDiff = 0;

        int result=1;



        for( int i=0; i <= nums.length-2; i++ ) {


            curDiff = nums[i+1] - nums[i];


            if( ( preDiff >=0 && curDiff < 0 ) || ( preDiff <=0 && curDiff > 0 ) ) {

                result++;

                preDiff = curDiff;

            }



        }


        return result;


        
    }
}



```









### 贪心算法，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明










好的，我们来为你在 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\数据结构与算法学习记录.md"></mcfile> 中 LeetCode 376 "摆动序列" 问题的贪心算法 Java 代码添加详细注释，并结合示例进行讲解。


局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。

整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。



```java
/**
 * LeetCode 376: 摆动序列
 *
 * 问题描述：
 * 找到给定整数数组 nums 中最长摆动子序列的长度。
 * 摆动序列是指连续数字之间的差严格地在正数和负数之间交替。
 *
 * 解题思路总结 (贪心算法):
 * 核心思想：寻找序列中的“峰”和“谷”，即局部最大值和局部最小值。最长摆动子序列的长度等于峰和谷的数量（或者说，等于序列趋势变化的次数加 1）。
 *
 * 策略：
 * 1. 统计序列中趋势变化的次数。趋势变化指的是从上升变为下降，或从下降变为上升。
 * 2. 初始化最长摆动子序列的长度 `result = 1` (至少包含一个元素)。
 * 3. 记录前一对元素的差值 `preDiff` (初始化为 0)。
 * 4. 遍历数组，计算当前一对元素的差值 `curDiff = nums[i+1] - nums[i]`。
 * 5. 判断是否发生了趋势变化：
 *    - 如果 `preDiff` 是非负的（之前是上升或持平），而 `curDiff` 是负的（当前是下降），则发生了一次趋势变化（遇到了峰）。
 *    - 如果 `preDiff` 是非正的（之前是下降或持平），而 `curDiff` 是正的（当前是上升），则发生了一次趋势变化（遇到了谷）。
 * 6. 如果发生了趋势变化，则 `result` 加 1，并将 `curDiff` 赋值给 `preDiff` 作为下一次比较的基准。
 * 7. 如果 `curDiff` 为 0，或者 `curDiff` 与 `preDiff` 同号，说明趋势没有改变（或者序列持平），此时不增加 `result`，也不更新 `preDiff`（或者说，更新 `preDiff` 为 `curDiff` 也可以，因为我们需要的是下一个有效的拐点差值）。代码中的实现是只有在发生有效拐点时才更新 `preDiff`。
 * 8. 遍历结束后，`result` 即为最长摆动子序列的长度。
 *
 * 特殊情况处理：
 * - 数组长度小于 2 时，本身就是摆动序列，长度为 `nums.length`。代码中初始化 `result = 1`，并在循环中处理，可以覆盖 `nums.length = 1` 的情况。如果 `nums.length = 0`，需要额外处理（但题目限制 `nums.length >= 1`）。
 * - 序列中有连续相等的元素（差值为 0）：这些元素不影响摆动性，贪心策略会自动忽略它们，直到遇到非零差值。
 */
class Solution {
    /**
     * 计算最长摆动子序列的长度
     * @param nums 输入的整数数组
     * @return 最长摆动子序列的长度
     */
    public int wiggleMaxLength(int[] nums) {

        // 处理边界情况：如果数组长度小于 2，则整个数组都是摆动序列
        if (nums.length < 2) {
            return nums.length;
        }

        // 记录前一对元素的差值，初始化为 0
        int preDiff = 0;
        // 记录当前一对元素的差值
        int curDiff = 0;
        // 记录最长摆动子序列的长度，初始化为 1 (至少包含第一个元素)
        int result = 1;

        // 遍历数组，从第一个元素到倒数第二个元素
        // i 的范围是 0 到 nums.length - 2
        for (int i = 0; i <= nums.length - 2; i++) {

            // 计算当前元素与下一个元素的差值
            curDiff = nums[i + 1] - nums[i];

            // 判断是否出现峰或谷 (趋势变化)
            // 条件：
            // 1. (preDiff >= 0 && curDiff < 0): 前一个差值非负 (上升或持平)，当前差值负 (下降) -> 峰
            // 2. (preDiff <= 0 && curDiff > 0): 前一个差值非正 (下降或持平)，当前差值正 (上升) -> 谷
            // 注意：curDiff == 0 的情况不会被统计，因为我们需要严格的正负交替
            if ((preDiff >= 0 && curDiff < 0) || (preDiff <= 0 && curDiff > 0)) {
                // 如果出现了峰或谷，摆动序列长度加 1
                result++;
                // 更新 preDiff 为当前的 curDiff，作为下一次判断的基础
                // 只有在找到有效的峰或谷时才更新 preDiff
                preDiff = curDiff;
            }
            // else if (curDiff != 0): 如果 curDiff 和 preDiff 同号，或者 preDiff 为 0 但 curDiff 不为 0
            //      这种情况下趋势没有反转，虽然 preDiff 可能需要更新为 curDiff 以反映当前趋势，
            //      但为了只在拐点处计数，我们只在 if 条件满足时更新 preDiff。
            //      如果 curDiff == 0，则忽略，不更新 result 也不更新 preDiff。
            //      (另一种写法是在 curDiff != 0 时就更新 preDiff，但 result 只在 if 条件满足时增加)
        }

        // 返回最终计算得到的最长摆动子序列长度
        return result;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 1: `nums = [1, 7, 4, 9, 2, 5]`**

1.  **初始化:** `preDiff = 0`, `curDiff = 0`, `result = 1`. `nums.length = 6`.
2.  **循环:**
    *   `i = 0`: `curDiff = nums[1] - nums[0] = 7 - 1 = 6`.
        *   `preDiff = 0`, `curDiff = 6`. 满足 `(preDiff <= 0 && curDiff > 0)`.
        *   `result` 变为 2. `preDiff` 变为 6.
    *   `i = 1`: `curDiff = nums[2] - nums[1] = 4 - 7 = -3`.
        *   `preDiff = 6`, `curDiff = -3`. 满足 `(preDiff >= 0 && curDiff < 0)`.
        *   `result` 变为 3. `preDiff` 变为 -3.
    *   `i = 2`: `curDiff = nums[3] - nums[2] = 9 - 4 = 5`.
        *   `preDiff = -3`, `curDiff = 5`. 满足 `(preDiff <= 0 && curDiff > 0)`.
        *   `result` 变为 4. `preDiff` 变为 5.
    *   `i = 3`: `curDiff = nums[4] - nums[3] = 2 - 9 = -7`.
        *   `preDiff = 5`, `curDiff = -7`. 满足 `(preDiff >= 0 && curDiff < 0)`.
        *   `result` 变为 5. `preDiff` 变为 -7.
    *   `i = 4`: `curDiff = nums[5] - nums[4] = 5 - 2 = 3`.
        *   `preDiff = -7`, `curDiff = 3`. 满足 `(preDiff <= 0 && curDiff > 0)`.
        *   `result` 变为 6. `preDiff` 变为 3.
3.  **循环结束.**
4.  **返回 `result = 6`**.

**示例 2: `nums = [1, 17, 5, 10, 13, 15, 10, 5, 16, 8]`**

1.  **初始化:** `preDiff = 0`, `curDiff = 0`, `result = 1`.
2.  **循环:**
    *   `i = 0`: `curDiff = 17 - 1 = 16`. `(0 <= 0 && 16 > 0)` -> `result = 2`, `preDiff = 16`.
    *   `i = 1`: `curDiff = 5 - 17 = -12`. `(16 >= 0 && -12 < 0)` -> `result = 3`, `preDiff = -12`.
    *   `i = 2`: `curDiff = 10 - 5 = 5`. `(-12 <= 0 && 5 > 0)` -> `result = 4`, `preDiff = 5`.
    *   `i = 3`: `curDiff = 13 - 10 = 3`. `(5 >= 0 && 3 > 0)` -> 条件不满足 (同号)。`result = 4`, `preDiff = 5`.
    *   `i = 4`: `curDiff = 15 - 13 = 2`. `(5 >= 0 && 2 > 0)` -> 条件不满足 (同号)。`result = 4`, `preDiff = 5`.
    *   `i = 5`: `curDiff = 10 - 15 = -5`. `(5 >= 0 && -5 < 0)` -> `result = 5`, `preDiff = -5`.
    *   `i = 6`: `curDiff = 5 - 10 = -5`. `(-5 <= 0 && -5 < 0)` -> 条件不满足 (同号)。`result = 5`, `preDiff = -5`.
    *   `i = 7`: `curDiff = 16 - 5 = 11`. `(-5 <= 0 && 11 > 0)` -> `result = 6`, `preDiff = 11`.
    *   `i = 8`: `curDiff = 8 - 16 = -8`. `(11 >= 0 && -8 < 0)` -> `result = 7`, `preDiff = -8`.
3.  **循环结束.**
4.  **返回 `result = 7`**.

**示例 3: `nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]`**

1.  **初始化:** `preDiff = 0`, `curDiff = 0`, `result = 1`.
2.  **循环:**
    *   `i = 0`: `curDiff = 2 - 1 = 1`. `(0 <= 0 && 1 > 0)` -> `result = 2`, `preDiff = 1`.
    *   `i = 1`: `curDiff = 3 - 2 = 1`. `(1 >= 0 && 1 > 0)` -> 条件不满足 (同号)。`result = 2`, `preDiff = 1`.
    *   `i = 2`: `curDiff = 4 - 3 = 1`. `(1 >= 0 && 1 > 0)` -> 条件不满足 (同号)。`result = 2`, `preDiff = 1`.
    *   ... (后续所有 `curDiff` 均为 1)
3.  **循环结束.**
4.  **返回 `result = 2`**. (摆动序列可以是 `[1, 2]` 或 `[1, 3]` ... `[1, 9]`, `[2, 3]` ... `[8, 9]`, 最长为 2)

这个贪心算法通过只关注序列趋势的变化点（峰和谷）来有效地计算最长摆动子序列的长度。

















## 力扣53. 最大子数组和
已解答
中等

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

示例 2：

输入：nums = [1]
输出：1

示例 3：

输入：nums = [5,4,-1,7,8]
输出：23
 

提示：

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4










### 贪心算法，无注释


```java




class Solution {
    public int maxSubArray(int[] nums) {
        /**
        局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
        全局最优：选取最大“连续和”。
        局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。
        */


        int sum=0;

        int maxSum = Integer.MIN_VALUE;

        for( int i=0; i < nums.length; i++ ) {

            sum += nums[i];

            if( sum > maxSum ) {

                maxSum = sum;


            }

            if( sum < 0 ) {

                sum = 0;

            }



        }


        return maxSum;
        
    }
}






```









### 贪心算法，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明






好的，我们来为你在 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\数据结构与算法学习记录.md"></mcfile> 中 LeetCode 53 "最大子数组和" 问题的贪心算法 Java 代码添加详细注释，并结合示例进行讲解。

```java
/**
 * LeetCode 53: 最大子数组和
 *
 * 问题描述：
 * 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
 *
 * 解题思路总结 (贪心算法):
 * 核心思想：遍历数组，维护一个当前的连续子数组和 `sum`。
 *
 * 策略：
 * 1. 初始化当前连续和 `sum = 0`，以及全局最大和 `maxSum = Integer.MIN_VALUE` (确保能正确处理全是负数的情况)。
 * 2. 遍历数组中的每个元素 `nums[i]`：
 *    a. 将当前元素加到 `sum` 上：`sum += nums[i]`。
 *    b. 更新全局最大和：如果当前的 `sum` 大于 `maxSum`，则更新 `maxSum = sum`。
 *    c. **贪心选择的关键**：如果 `sum` 变为负数 (`sum < 0`)，说明以当前元素结尾的这段连续子数组的和已经是负值了。
 *       对于后续的元素来说，再加上这个负的 `sum` 只会让总和变得更小。因此，我们应该放弃之前的负和子数组，
 *       从下一个元素开始重新计算连续和。所以，将 `sum` 重置为 0。
 * 3. 遍历结束后，`maxSum` 中存储的就是整个数组中最大子数组的和。
 *
 * 局部最优与全局最优：
 * - 局部最优：在每一步，如果当前连续和 `sum` 为负，就将其丢弃并从 0 开始重新累加。这是因为负的 `sum` 对后续求和没有贡献，保留它不是当前步骤的最优选择。
 * - 全局最优：通过不断维护和更新 `maxSum`，确保记录了整个遍历过程中出现过的最大的连续子数组和。局部最优的决策（丢弃负和）保证了我们不会错过可能的最大和。
 */
class Solution {
    /**
     * 计算最大子数组和
     * @param nums 输入的整数数组
     * @return 最大子数组的和
     */
    public int maxSubArray(int[] nums) {
        // 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
        // 全局最优：选取最大“连续和”。
        // 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

        // 用于记录当前的连续子数组和
        int sum = 0;
        // 用于记录遍历过程中遇到的最大子数组和，初始化为整数最小值以正确处理负数数组
        int maxSum = Integer.MIN_VALUE;

        // 遍历数组中的每一个元素
        for (int i = 0; i < nums.length; i++) {
            // 将当前元素累加到当前的连续和 sum 中
            sum += nums[i];

            // 更新最大和：如果当前的连续和 sum 比已记录的最大和 maxSum 更大
            if (sum > maxSum) {
                // 则更新 maxSum 为当前的 sum
                maxSum = sum;
            }

            // 贪心选择：如果当前的连续和 sum 变成了负数
            if (sum < 0) {
                // 说明从之前的某个起点到当前元素的这段子数组的和为负，
                // 它对于后续子数组的和只会起到负面作用。
                // 因此，放弃这段子数组，将 sum 重置为 0，准备从下一个元素开始重新计算连续和。
                sum = 0;
            }
        }

        // 遍历结束后，maxSum 中存储的就是整个数组的最大子数组和
        return maxSum;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 1: `nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`**

1.  **初始化:** `sum = 0`, `maxSum = Integer.MIN_VALUE`.
2.  **循环:**
    *   `i = 0` (`nums[0] = -2`):
        *   `sum = 0 + (-2) = -2`.
        *   `sum (-2) > maxSum (MIN_VALUE)`? Yes. `maxSum` 变为 -2.
        *   `sum (-2) < 0`? Yes. `sum` 变为 0.
    *   `i = 1` (`nums[1] = 1`):
        *   `sum = 0 + 1 = 1`.
        *   `sum (1) > maxSum (-2)`? Yes. `maxSum` 变为 1.
        *   `sum (1) < 0`? No.
    *   `i = 2` (`nums[2] = -3`):
        *   `sum = 1 + (-3) = -2`.
        *   `sum (-2) > maxSum (1)`? No.
        *   `sum (-2) < 0`? Yes. `sum` 变为 0.
    *   `i = 3` (`nums[3] = 4`):
        *   `sum = 0 + 4 = 4`.
        *   `sum (4) > maxSum (1)`? Yes. `maxSum` 变为 4.
        *   `sum (4) < 0`? No.
    *   `i = 4` (`nums[4] = -1`):
        *   `sum = 4 + (-1) = 3`.
        *   `sum (3) > maxSum (4)`? No.
        *   `sum (3) < 0`? No.
    *   `i = 5` (`nums[5] = 2`):
        *   `sum = 3 + 2 = 5`.
        *   `sum (5) > maxSum (4)`? Yes. `maxSum` 变为 5.
        *   `sum (5) < 0`? No.
    *   `i = 6` (`nums[6] = 1`):
        *   `sum = 5 + 1 = 6`.
        *   `sum (6) > maxSum (5)`? Yes. `maxSum` 变为 6.
        *   `sum (6) < 0`? No.
    *   `i = 7` (`nums[7] = -5`):
        *   `sum = 6 + (-5) = 1`.
        *   `sum (1) > maxSum (6)`? No.
        *   `sum (1) < 0`? No.
    *   `i = 8` (`nums[8] = 4`):
        *   `sum = 1 + 4 = 5`.
        *   `sum (5) > maxSum (6)`? No.
        *   `sum (5) < 0`? No.
3.  **循环结束.**
4.  **返回 `maxSum = 6`**.

**输出:**

`6`

这个过程清晰地展示了贪心算法如何工作：它只关注当前的连续和 `sum`。一旦 `sum` 变为负数，就意味着继续累加这个负和是没有意义的（对于寻找最大和而言），因此果断将其重置为 0，相当于开始了新的子数组求和。同时，`maxSum` 始终记录着整个过程中出现过的最大 `sum` 值。














## 力扣122. 买卖股票的最佳时机 II
已解答
中等

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

 

示例 1：

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。

示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。

示例 3：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
 

提示：

1 <= prices.length <= 3 * 10^4
0 <= prices[i] <= 10^4





### 贪心算法，无注释


贪心算法
局部最优：收集每天的正利润，
全局最优：求得最大利润。


```java

class Solution {
    public int maxProfit(int[] prices) {


        int sumProfit=0;


        for( int i=1; i < prices.length; i++ ) {

            
            sumProfit += Math.max( prices[i]-prices[i-1], 0 );

        }

        return sumProfit;
        
    }
}


```











### 贪心算法，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明






好的，我们来为你在 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\数据结构与算法学习记录.md"></mcfile> 中 LeetCode 122 "买卖股票的最佳时机 II" 问题的贪心算法 Java 代码添加详细注释，并结合示例进行讲解。

```java
/**
 * LeetCode 122: 买卖股票的最佳时机 II
 *
 * 问题描述：
 * 给定一个整数数组 prices，其中 prices[i] 是某支股票在第 i 天的价格。
 * 可以在每一天选择买入和/或卖出股票。任何时候最多只能持有一股股票。
 * 可以在同一天买入并立即卖出。目标是计算能获得的最大利润。
 *
 * 解题思路总结 (贪心算法):
 * 核心思想：将总利润分解为每天的利润。只要今天的价格高于昨天的价格，就认为昨天买入、今天卖出是有利可图的，并将这部分利润累加到总利润中。
 *
 * 策略：
 * 1. 遍历价格数组，从第二天开始 (i = 1)。
 * 2. 计算当天的价格 `prices[i]` 与前一天价格 `prices[i-1]` 的差值 `diff = prices[i] - prices[i-1]`。
 * 3. 如果差值 `diff` 大于 0，说明今天卖出比昨天卖出（或者说，昨天买入今天卖出）可以获得正利润。将这个正利润累加到总利润 `sumProfit` 中。
 * 4. 如果差值 `diff` 小于或等于 0，说明今天价格不比昨天高，今天卖出没有利润（相对于昨天买入），所以不进行操作（或者说，累加 0）。
 * 5. 遍历结束后，`sumProfit` 就是可以获得的最大总利润。
 *
 * 局部最优与全局最优：
 * - 局部最优：在每一天，只要价格上涨，就获取这部分上涨的利润 (`prices[i] - prices[i-1]`)。
 * - 全局最优：通过累加所有上涨区间的利润，最终得到的就是整个时间段内的最大利润。因为可以无限次交易，所以任何一个上涨的差价都可以单独获取。例如，对于 [1, 2, 5]，贪心算法会计算 (2-1) + (5-2) = 1 + 3 = 4，这等价于在 1 买入，在 5 卖出的总利润。
 */
class Solution {
    /**
     * 计算买卖股票可以获得的最大利润 (允许多次交易)
     * @param prices 股票每天的价格数组
     * @return 最大利润
     */
    public int maxProfit(int[] prices) {

        // 初始化总利润为 0
        int sumProfit = 0;

        // 遍历价格数组，从第二天 (i=1) 开始，比较当天与前一天的价格
        for (int i = 1; i < prices.length; i++) {

            // 计算当天的价格与前一天价格的差值
            // 如果差值大于 0，说明今天卖出比昨天卖出（或昨天买入今天卖出）有利润
            // Math.max(prices[i] - prices[i-1], 0) 会取正的差值，如果是负数或 0 则取 0
            // 相当于只累加所有正利润（价格上涨的部分）
            sumProfit += Math.max(prices[i] - prices[i - 1], 0);

        }

        // 返回累加的总利润
        return sumProfit;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 1: `prices = [7, 1, 5, 3, 6, 4]`**

1.  **初始化:** `sumProfit = 0`.
2.  **循环:**
    *   `i = 1`: `prices[1] = 1`, `prices[0] = 7`. `diff = 1 - 7 = -6`. `Math.max(-6, 0) = 0`. `sumProfit = 0 + 0 = 0`.
    *   `i = 2`: `prices[2] = 5`, `prices[1] = 1`. `diff = 5 - 1 = 4`. `Math.max(4, 0) = 4`. `sumProfit = 0 + 4 = 4`. (捕捉到 1 -> 5 的利润)
    *   `i = 3`: `prices[3] = 3`, `prices[2] = 5`. `diff = 3 - 5 = -2`. `Math.max(-2, 0) = 0`. `sumProfit = 4 + 0 = 4`.
    *   `i = 4`: `prices[4] = 6`, `prices[3] = 3`. `diff = 6 - 3 = 3`. `Math.max(3, 0) = 3`. `sumProfit = 4 + 3 = 7`. (捕捉到 3 -> 6 的利润)
    *   `i = 5`: `prices[5] = 4`, `prices[4] = 6`. `diff = 4 - 6 = -2`. `Math.max(-2, 0) = 0`. `sumProfit = 7 + 0 = 7`.
3.  **循环结束.**
4.  **返回 `sumProfit = 7`**.

**输出:**

`7`

**示例 2: `prices = [1, 2, 3, 4, 5]`**

1.  **初始化:** `sumProfit = 0`.
2.  **循环:**
    *   `i = 1`: `prices[1] = 2`, `prices[0] = 1`. `diff = 2 - 1 = 1`. `Math.max(1, 0) = 1`. `sumProfit = 0 + 1 = 1`.
    *   `i = 2`: `prices[2] = 3`, `prices[1] = 2`. `diff = 3 - 2 = 1`. `Math.max(1, 0) = 1`. `sumProfit = 1 + 1 = 2`.
    *   `i = 3`: `prices[3] = 4`, `prices[2] = 3`. `diff = 4 - 3 = 1`. `Math.max(1, 0) = 1`. `sumProfit = 2 + 1 = 3`.
    *   `i = 4`: `prices[4] = 5`, `prices[3] = 4`. `diff = 5 - 4 = 1`. `Math.max(1, 0) = 1`. `sumProfit = 3 + 1 = 4`.
3.  **循环结束.**
4.  **返回 `sumProfit = 4`**.

**输出:**

`4`

这个贪心策略非常巧妙，它将整个过程分解为每天的决策。只要第二天比第一天价格高，就假设在第一天买入，第二天卖出，并累加这个利润。这等同于捕捉了所有价格上涨区间的总和，因为任何一段连续上涨（如 1 -> 5）的利润，都可以被分解为每天小幅上涨的利润之和（(2-1) + (3-2) + (4-3) + (5-4) = 4）。





















## 力扣55. 跳跃游戏
已解答
中等

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
 

提示：

1 <= nums.length <= 10^4
0 <= nums[i] <= 10^5








### 贪心算法，无注释

局部最优解：每次取最大跳跃步数（取最大覆盖范围），
整体最优解：最后得到整体最大覆盖范围，看是否能到终点。




```java


class Solution {
    public boolean canJump(int[] nums) {


        int cover=0;

        if( nums.length == 1 ) {

            return true;
        }

        for( int i=0; i <= cover; i++ ) {


            cover = Math.max( i + nums[i], cover );

            if( cover >= nums.length-1 ) {

                return true;
            }

        }


        return false;
        
    }
}


```








### 贪心算法，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明






好的，我们来为你在 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\数据结构与算法学习记录.md"></mcfile> 中 LeetCode 55 "跳跃游戏" 问题的贪心算法 Java 代码添加详细注释，并结合示例进行讲解。

```java
/**
 * LeetCode 55: 跳跃游戏
 *
 * 问题描述：
 * 给定一个非负整数数组 nums，你最初位于数组的第一个下标。
 * 数组中的每个元素代表你在该位置可以跳跃的最大长度。
 * 判断你是否能够到达最后一个下标。
 *
 * 解题思路总结 (贪心算法):
 * 核心思想：维护一个变量 `cover`，表示当前能够到达的最远距离（下标）。
 * 遍历数组，不断更新这个最远距离。如果在遍历过程中，发现当前位置 `i` 已经超出了 `cover` 的范围，
 * 说明无法到达当前位置，也就无法到达终点。如果在任何时候 `cover` 能够覆盖到数组的最后一个下标，
 * 则说明可以到达终点。
 *
 * 策略：
 * 1. 初始化 `cover = 0`。
 * 2. 遍历数组，但有一个重要的条件：只遍历当前能够到达的位置，即 `i <= cover`。
 *    如果 `i > cover`，说明从起点无论如何也跳不到 `i` 这个位置，后续的位置更不可能到达。
 * 3. 在遍历过程中，对于每个可到达的位置 `i`，计算从该位置出发能到达的最远距离 `i + nums[i]`。
 * 4. 更新 `cover`：`cover = Math.max(cover, i + nums[i])`。取当前 `cover` 和从 `i` 出发能到达的最远距离中的较大者，
 *    这体现了贪心的思想——总是尽可能地扩展能够覆盖的范围。
 * 5. 在每次更新 `cover` 后，检查 `cover` 是否已经大于或等于数组的最后一个下标 (`nums.length - 1`)。
 *    如果是，说明已经可以到达终点，直接返回 `true`。
 * 6. 如果循环正常结束（即 `i` 超过了 `cover`），说明无法到达最后一个下标，返回 `false`。
 *
 * 局部最优与全局最优：
 * - 局部最优：在当前可达范围内，每一步都计算并更新能到达的最远距离 (`cover`)。
 * - 全局最优：通过不断更新局部最优（最远覆盖范围），最终判断这个最远范围是否能覆盖终点。如果能，则全局最优解（能到达终点）达成。
 */
class Solution {
    /**
     * 判断是否能从起点跳到数组的最后一个下标
     * @param nums 非负整数数组，nums[i] 代表在 i 位置能跳跃的最大长度
     * @return 如果能到达最后一个下标，返回 true；否则返回 false
     */
    public boolean canJump(int[] nums) {

        // cover 表示当前能够跳跃到的最远距离（下标）
        int cover = 0;

        // 处理边界情况：如果数组只有一个元素，那么本身就在终点
        if (nums.length == 1) {
            return true;
        }

        // 遍历数组，注意循环条件是 i <= cover
        // 我们只关心在当前可覆盖范围内的位置 i
        // 如果 i > cover，说明位置 i 本身就无法到达，更不用说从 i 再往后跳了
        for (int i = 0; i <= cover; i++) {

            // 贪心选择：更新能够到达的最远距离
            // cover 被更新为 当前 cover 和 从位置 i 出发能跳到的最远距离 (i + nums[i]) 中的较大值
            cover = Math.max(i + nums[i], cover);

            // 检查是否已经能够覆盖到数组的最后一个下标
            if (cover >= nums.length - 1) {
                // 如果可以，直接返回 true
                return true;
            }
        }

        // 如果循环结束，说明在遍历完所有可达的位置后，
        // cover 仍然未能覆盖到最后一个下标
        return false;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 1: `nums = [2, 3, 1, 1, 4]`**

1.  **初始化:** `cover = 0`. `nums.length = 5`. 最后一个下标是 4.
2.  **循环 (条件 `i <= cover`):**
    *   `i = 0`: `0 <= cover (0)`? Yes.
        *   `cover = Math.max(0 + nums[0], cover) = Math.max(0 + 2, 0) = 2`. `cover` 变为 2.
        *   `cover (2) >= nums.length - 1 (4)`? No.
    *   `i = 1`: `1 <= cover (2)`? Yes.
        *   `cover = Math.max(1 + nums[1], cover) = Math.max(1 + 3, 2) = 4`. `cover` 变为 4.
        *   `cover (4) >= nums.length - 1 (4)`? Yes. **返回 `true`**.

**输出:**

`true`

**示例 2: `nums = [3, 2, 1, 0, 4]`**

1.  **初始化:** `cover = 0`. `nums.length = 5`. 最后一个下标是 4.
2.  **循环 (条件 `i <= cover`):**
    *   `i = 0`: `0 <= cover (0)`? Yes.
        *   `cover = Math.max(0 + nums[0], cover) = Math.max(0 + 3, 0) = 3`. `cover` 变为 3.
        *   `cover (3) >= nums.length - 1 (4)`? No.
    *   `i = 1`: `1 <= cover (3)`? Yes.
        *   `cover = Math.max(1 + nums[1], cover) = Math.max(1 + 2, 3) = 3`. `cover` 保持 3.
        *   `cover (3) >= nums.length - 1 (4)`? No.
    *   `i = 2`: `2 <= cover (3)`? Yes.
        *   `cover = Math.max(2 + nums[2], cover) = Math.max(2 + 1, 3) = 3`. `cover` 保持 3.
        *   `cover (3) >= nums.length - 1 (4)`? No.
    *   `i = 3`: `3 <= cover (3)`? Yes.
        *   `cover = Math.max(3 + nums[3], cover) = Math.max(3 + 0, 3) = 3`. `cover` 保持 3.
        *   `cover (3) >= nums.length - 1 (4)`? No.
    *   `i = 4`: `4 <= cover (3)`? No. 循环条件不满足，循环结束。
3.  **循环结束后，返回 `false`**.

**输出:**

`false`

这个贪心算法的关键在于 `for` 循环的条件 `i <= cover` 和 `cover` 的更新逻辑。它确保了我们只在确实可达的范围内进行探索，并且总是尝试将探索的边界推向最远。如果这个最远边界最终能覆盖终点，那么问题就有解。














## 力扣45. 跳跃游戏 II
已解答
中等

给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

0 <= j <= nums[i] 
i + j < n
返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

 

示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

示例 2:

输入: nums = [2,3,0,1,4]
输出: 2
 

提示:

1 <= nums.length <= 10^4
0 <= nums[i] <= 1000
题目保证可以到达 nums[n-1]







### 贪心算法，无注释


局部最优：在当前一步能覆盖的范围内，找到下一步能跳到的最远距离。
全局最优：通过每次都选择能跳到最远距离的策略，最终以最少的步数到达终点。



```java


class Solution {
    public int jump(int[] nums) {


        int curDistance=0;

        int nextDistance=0;


        int steps = 0;

        for( int i=0; i <= nums.length-2; i++ ) {


            nextDistance = Math.max( i + nums[i], nextDistance );

            if( i == curDistance ) {

                steps++;

                curDistance = nextDistance;

            }


        }


        return steps;
        
    }
}




```






### 贪心算法，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明




好的，我们来为你在 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\算法学习记录\数据结构与算法学习记录.md"></mcfile> 中 LeetCode 45 "跳跃游戏 II" 问题的贪心算法 Java 代码添加详细注释，并结合示例进行讲解。

```java
/**
 * LeetCode 45: 跳跃游戏 II
 *
 * 问题描述：
 * 给定一个非负整数数组 nums，你最初位于数组的第一个下标 nums[0]。
 * 数组中的每个元素 nums[i] 代表你在该位置可以跳跃的最大长度。
 * 返回到达数组最后一个下标 nums[n - 1] 的最小跳跃次数。题目保证可以到达终点。
 *
 * 解题思路总结 (贪心算法):
 * 核心思想：在每一步跳跃时，都选择能够使下一步跳跃范围最远的位置。
 * 我们不需要关心具体跳到哪个位置，只需要关心当前这一步能覆盖的最远距离，以及在当前覆盖范围内，下一步能跳到的最远距离。
 *
 * 策略：
 * 1. 维护三个变量：
 *    - `steps`: 当前已经跳跃的次数。
 *    - `curDistance`: 使用当前 `steps` 次跳跃能够到达的最远下标。
 *    - `nextDistance`: 在当前 `curDistance` 覆盖的范围内，再跳一步能够到达的最远下标。
 * 2. 初始化 `steps = 0`, `curDistance = 0`, `nextDistance = 0`。
 * 3. 遍历数组，从下标 0 到 `nums.length - 2` (因为当 `i` 到达 `nums.length - 1` 时，我们已经到达终点，不需要再跳了)。
 * 4. 在遍历过程中，对于每个位置 `i`：
 *    a. 更新 `nextDistance`：`nextDistance = Math.max(i + nums[i], nextDistance)`。这表示在当前 `steps` 次跳跃能到达的所有位置 (`0` 到 `curDistance`) 中，再跳一步所能到达的最远距离。
 *    b. **贪心选择的关键**：检查当前位置 `i` 是否已经到达了当前跳跃次数 `steps` 所能覆盖的最远边界 `curDistance`。即 `if (i == curDistance)`。
 *       - 如果到达边界，说明必须进行下一次跳跃才能继续前进。
 *       - 此时，增加跳跃次数 `steps++`。
 *       - 更新当前能到达的最远距离 `curDistance = nextDistance`。这个 `nextDistance` 是在上一次跳跃覆盖范围内计算出的、下一步能到达的最远距离。
 *       - 如果更新后的 `curDistance` 已经覆盖了终点 (`curDistance >= nums.length - 1`)，可以提前结束循环（虽然不加这个判断，代码也能正确运行，因为循环条件是 `i <= nums.length - 2`）。
 * 5. 循环结束后，`steps` 就是到达终点的最小跳跃次数。
 *
 * 局部最优与全局最优：
 * - 局部最优：在当前一步能覆盖的范围内，找到下一步能跳到的最远距离。
 * - 全局最优：通过每次都选择能跳到最远距离的策略，最终以最少的步数到达终点。
 */
class Solution {
    /**
     * 计算到达数组最后一个下标的最小跳跃次数
     * @param nums 非负整数数组，nums[i] 代表在 i 位置能跳跃的最大长度
     * @return 最小跳跃次数
     */
    public int jump(int[] nums) {

        // 如果数组长度为 1 或 0，不需要跳跃
        if (nums.length <= 1) {
            return 0;
        }

        // 当前跳跃次数能覆盖的最远距离下标
        int curDistance = 0;
        // 在当前覆盖范围内，下一步能跳到的最远距离下标
        int nextDistance = 0;
        // 记录跳跃的步数
        int steps = 0;

        // 遍历数组，注意范围是 0 到 nums.length - 2
        // 因为当 i = nums.length - 1 时，已经到达终点，不需要再决策了
        // 循环的目的是确定到达终点前最后一次跳跃发生在哪里
        for (int i = 0; i <= nums.length - 2; i++) {

            // 更新下一步能跳到的最远距离
            // 在当前位置 i，能跳到的最远距离是 i + nums[i]
            // 我们需要维护从 [0, curDistance] 这个范围内所有点出发，下一步能跳到的最远距离
            nextDistance = Math.max(i + nums[i], nextDistance);

            // 判断是否到达当前步数能覆盖的最远距离的边界
            // 如果 i == curDistance，意味着我们已经走完了当前这一步能覆盖的所有范围
            // 必须进行下一步跳跃
            if (i == curDistance) {
                // 增加步数
                steps++;
                // 更新当前步数能覆盖的最远距离为之前计算好的 nextDistance
                curDistance = nextDistance;

                // 优化：如果当前能覆盖的距离已经到达或超过终点，可以提前结束
                // 因为题目保证能到达终点，所以这次跳跃后肯定能到达
                // if (curDistance >= nums.length - 1) {
                //     break; // 可以加上这句提前结束循环
                // }
            }
        }

        // 返回总的跳跃步数
        return steps;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 1: `nums = [2, 3, 1, 1, 4]`**

1.  **初始化:** `curDistance = 0`, `nextDistance = 0`, `steps = 0`. `nums.length = 5`. 循环范围 `i = 0` to `3`.
2.  **循环:**
    *   `i = 0`:
        *   `nextDistance = Math.max(0 + nums[0], 0) = Math.max(2, 0) = 2`.
        *   `i (0) == curDistance (0)`? Yes.
            *   `steps` 变为 1.
            *   `curDistance` 变为 `nextDistance (2)`.
    *   `i = 1`:
        *   `nextDistance = Math.max(1 + nums[1], 2) = Math.max(1 + 3, 2) = 4`.
        *   `i (1) == curDistance (2)`? No.
    *   `i = 2`:
        *   `nextDistance = Math.max(2 + nums[2], 4) = Math.max(2 + 1, 4) = 4`.
        *   `i (2) == curDistance (2)`? Yes.
            *   `steps` 变为 2.
            *   `curDistance` 变为 `nextDistance (4)`. (此时 `curDistance >= nums.length - 1`, 如果有优化判断会提前结束)
    *   `i = 3`:
        *   `nextDistance = Math.max(3 + nums[3], 4) = Math.max(3 + 1, 4) = 4`.
        *   `i (3) == curDistance (4)`? No.
3.  **循环结束 (i > nums.length - 2).**
4.  **返回 `steps = 2`**.

**输出:**

`2`

**示例 2: `nums = [2, 3, 0, 1, 4]`**

1.  **初始化:** `curDistance = 0`, `nextDistance = 0`, `steps = 0`. `nums.length = 5`. 循环范围 `i = 0` to `3`.
2.  **循环:**
    *   `i = 0`:
        *   `nextDistance = Math.max(0 + nums[0], 0) = Math.max(2, 0) = 2`.
        *   `i (0) == curDistance (0)`? Yes.
            *   `steps` 变为 1.
            *   `curDistance` 变为 `nextDistance (2)`.
    *   `i = 1`:
        *   `nextDistance = Math.max(1 + nums[1], 2) = Math.max(1 + 3, 2) = 4`.
        *   `i (1) == curDistance (2)`? No.
    *   `i = 2`:
        *   `nextDistance = Math.max(2 + nums[2], 4) = Math.max(2 + 0, 4) = 4`.
        *   `i (2) == curDistance (2)`? Yes.
            *   `steps` 变为 2.
            *   `curDistance` 变为 `nextDistance (4)`. (此时 `curDistance >= nums.length - 1`, 如果有优化判断会提前结束)
    *   `i = 3`:
        *   `nextDistance = Math.max(3 + nums[3], 4) = Math.max(3 + 1, 4) = 4`.
        *   `i (3) == curDistance (4)`? No.
3.  **循环结束 (i > nums.length - 2).**
4.  **返回 `steps = 2`**.

**输出:**

`2`

这个贪心算法的关键在于理解 `curDistance` 和 `nextDistance` 的作用。`curDistance` 标记了当前这一“步”能走到的最远边界，而 `nextDistance` 则是在探索这一步能覆盖的所有位置时，为“下一步”寻找的最优起跳点（能跳得最远的点）。当 `i` 走到 `curDistance` 时，就意味着这一步的探索结束，必须迈出下一步（`steps++`），并将下一步的边界设为之前找到的最优值 (`curDistance = nextDistance`)。



























































## 力扣1005. K 次取反后最大化的数组和
已解答
简单

给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：

选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
重复这个过程恰好 k 次。可以多次选择同一个下标 i 。

以这种方式修改数组后，返回数组 可能的最大和 。

 

示例 1：

输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。

示例 2：

输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。

示例 3：

输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
 

提示：

1 <= nums.length <= 10^4
-100 <= nums[i] <= 100
1 <= k <= 10^4







### Java中如何进行排序？




在 Java 中进行排序主要依赖于标准库提供的类和方法。最常用的排序方式是使用 `java.util.Arrays` 类对数组进行排序，以及使用 `java.util.Collections` 类或 `java.util.List` 接口对集合（特别是 List）进行排序。

对于对象的排序，Java 提供了两种主要的机制来定义排序规则：

1.  **`Comparable` 接口:** 用于定义对象的**自然排序**（natural ordering）。如果一个类的对象本身就知道如何与同类型的其他对象进行比较，就可以实现此接口。
2.  **`Comparator` 接口:** 用于定义**外部排序规则**。当你需要按照不同于自然排序的方式对对象进行排序，或者对象所属的类没有实现 `Comparable` 接口时，可以使用 `Comparator`。

下面详细介绍如何在 Java 中进行排序：

**1. 对基本类型数组进行排序**

使用 `java.util.Arrays.sort()` 方法。这是最简单的情况。

```java
import java.util.Arrays;

public class PrimitiveSortExample {
    public static void main(String[] args) {
        // 整型数组
        int[] intArray = {5, 2, 8, 1, 9};
        System.out.println("原始整型数组: " + Arrays.toString(intArray));

        // 对整型数组进行升序排序
        Arrays.sort(intArray);
        System.out.println("排序后整型数组: " + Arrays.toString(intArray));

        // 浮点型数组
        double[] doubleArray = {3.14, 1.618, 2.718};
        System.out.println("原始浮点型数组: " + Arrays.toString(doubleArray));

        // 对浮点型数组进行升序排序
        Arrays.sort(doubleArray);
        System.out.println("排序后浮点型数组: " + Arrays.toString(doubleArray));
    }
}
```

**2. 对对象数组进行排序**

对于对象数组，`Arrays.sort()` 方法有两种形式：

*   `Arrays.sort(Object[] a)`: 要求数组中的对象实现 `Comparable` 接口，按照对象的自然排序进行排序。
*   `Arrays.sort(Object[] a, Comparator<? super T> c)`: 使用指定的 `Comparator` 对对象进行排序。

**示例 2.1: 使用 `Comparable` 进行自然排序**

假设我们有一个 `Person` 类，我们希望按照姓名进行自然排序。

```java
import java.util.Arrays;

// Person 类实现 Comparable 接口，定义按姓名排序的自然顺序
class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + '}';
    }

    // 实现 compareTo 方法，定义按姓名进行比较
    @Override
    public int compareTo(Person other) {
        // 使用 String 的 compareTo 方法比较姓名
        return this.name.compareTo(other.name);
    }
}

public class ObjectArraySortComparableExample {
    public static void main(String[] args) {
        Person[] people = {
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35)
        };

        System.out.println("原始 Person 数组: " + Arrays.toString(people));

        // 对 Person 数组进行排序 (按姓名，因为 Person 实现了 Comparable)
        Arrays.sort(people);
        System.out.println("按姓名排序后 Person 数组: " + Arrays.toString(people));
    }
}
```

**示例 2.2: 使用 `Comparator` 进行自定义排序**

如果我们想按年龄对 `Person` 对象进行排序，可以使用 `Comparator`。

```java
import java.util.Arrays;
import java.util.Comparator;

// Person 类 (同上，但这里排序不依赖其是否实现 Comparable)
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + '}';
    }
}

public class ObjectArraySortComparatorExample {
    public static void main(String[] args) {
        Person[] people = {
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35)
        };

        System.out.println("原始 Person 数组: " + Arrays.toString(people));

        // 创建一个 Comparator，用于按年龄进行比较 (升序)
        Comparator<Person> ageComparator = new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                // 比较年龄
                return Integer.compare(p1.getAge(), p2.getAge());
                // 或者: return p1.getAge() - p2.getAge(); (注意溢出问题)
            }
        };

        // 使用 Comparator 对 Person 数组进行排序
        Arrays.sort(people, ageComparator);
        System.out.println("按年龄排序后 Person 数组: " + Arrays.toString(people));

        // Java 8+ 可以使用 Lambda 表达式创建 Comparator，更简洁
        // Arrays.sort(people, (p1, p2) -> Integer.compare(p1.getAge(), p2.getAge()));

        // Java 8+ 还可以使用 Comparator.comparing 方法
        // Arrays.sort(people, Comparator.comparing(Person::getAge));
    }
}
```

**3. 对 List 集合进行排序**

对于 `List` 集合（如 `ArrayList`, `LinkedList`），可以使用 `java.util.Collections.sort()` 方法或 Java 8+ 引入的 `List.sort()` 方法。

*   `Collections.sort(List<T> list)`: 要求 List 中的对象实现 `Comparable` 接口，按自然排序。
*   `Collections.sort(List<T> list, Comparator<? super T> c)`: 使用指定的 `Comparator` 排序。
*   `List.sort(Comparator<? super E> c)` (Java 8+): 直接在 List 对象上调用，使用指定的 `Comparator` 排序。

**示例 3.1: 使用 `Collections.sort()` 和 `Comparable`**

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

// Person 类 (同上，实现 Comparable 按姓名排序)
class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + '}';
    }

    @Override
    public int compareTo(Person other) {
        return this.name.compareTo(other.name);
    }
}

public class ListSortComparableExample {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        people.add(new Person("Charlie", 35));

        System.out.println("原始 Person List: " + people);

        // 对 List 进行排序 (按姓名，因为 Person 实现了 Comparable)
        Collections.sort(people);
        System.out.println("按姓名排序后 Person List: " + people);
    }
}
```

**示例 3.2: 使用 `Collections.sort()` 或 `List.sort()` 和 `Comparator`**

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

// Person 类 (同上，不一定需要实现 Comparable)
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + '}';
    }
}

public class ListSortComparatorExample {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        people.add(new Person("Charlie", 35));

        System.out.println("原始 Person List: " + people);

        // 使用 Comparator 按年龄排序 (升序)
        Comparator<Person> ageComparator = new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                return Integer.compare(p1.getAge(), p2.getAge());
            }
        };

        // 方法 1: 使用 Collections.sort()
        // Collections.sort(people, ageComparator);

        // 方法 2: 使用 List.sort() (Java 8+)
        people.sort(ageComparator);

        System.out.println("按年龄排序后 Person List: " + people);

        // Java 8+ 使用 Lambda 表达式和 Comparator.comparing 更简洁
        // people.sort((p1, p2) -> Integer.compare(p1.getAge(), p2.getAge()));
        // people.sort(Comparator.comparing(Person::getAge)); // 按年龄升序
        // people.sort(Comparator.comparing(Person::getAge).reversed()); // 按年龄降序
    }
}
```

**总结：**

*   **基本类型数组:** 使用 `Arrays.sort()`。
*   **对象数组/List:**
    *   如果对象有**自然排序**（实现了 `Comparable`），可以直接使用 `Arrays.sort(Object[])` 或 `Collections.sort(List)`。
    *   如果需要**自定义排序**（或者对象没有实现 `Comparable`），创建并使用 `Comparator`，配合 `Arrays.sort(Object[], Comparator)` 或 `Collections.sort(List, Comparator)` 或 `List.sort(Comparator)` (Java 8+)。
*   Java 8 引入的 Lambda 表达式和 `Comparator` 的静态方法（如 `comparing()`）极大地简化了 `Comparator` 的创建。

底层实现上，`Arrays.sort()` 对基本类型数组通常使用优化的快速排序（如 Dual-Pivot Quicksort），而对对象数组和 List 的排序（通过 `Arrays.sort(Object[])` 或 `Collections.sort(List)`）通常使用 Timsort，这是一种混合排序算法，在实际数据中表现良好。







### 如何根据数组中元素的绝对值大小排序？




在 Java 中，要根据数组元素的绝对值大小进行排序，你需要使用一个自定义的比较器（`Comparator`），因为元素的自然排序是基于其本身的数值，而不是绝对值。

`Comparator` 接口允许你定义自己的排序规则。你可以将这个 `Comparator` 传递给 `Arrays.sort()` 方法（用于对象数组）或 `Collections.sort()` / `List.sort()` 方法（用于 List 集合）。

对于基本类型数组（如 `int[]`），`Arrays.sort()` 没有接受 `Comparator` 的重载方法。你需要先将基本类型数组转换为对应的包装类数组（如 `Integer[]`），然后再使用接受 `Comparator` 的 `Arrays.sort()` 方法。

下面是使用 `Comparator` 根据绝对值大小对 `Integer` 数组和 `List<Integer>` 进行排序的示例：

**示例：使用 Comparator 根据绝对值排序**

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.ArrayList;
import java.lang.Math; // 导入 Math 类用于计算绝对值

public class AbsoluteValueSortExample {

    public static void main(String[] args) {

        // --- 示例 1: 对 Integer 数组进行排序 ---
        Integer[] integerArray = { -5, 2, -8, 1, 9, -3, 4 };
        System.out.println("原始 Integer 数组: " + Arrays.toString(integerArray));

        // 创建一个 Comparator，用于根据元素的绝对值进行比较
        Comparator<Integer> absComparator = new Comparator<Integer>() {
            @Override
            public int compare(Integer a, Integer b) {
                // 计算两个元素的绝对值
                int absA = Math.abs(a);
                int absB = Math.abs(b);

                // 比较绝对值
                // 如果 absA < absB，返回负数，表示 a 应该排在 b 前面
                // 如果 absA > absB，返回正数，表示 a 应该排在 b 后面
                // 如果 absA == absB，返回 0，表示 a 和 b 的相对顺序不重要（对于绝对值排序而言）
                return Integer.compare(absA, absB); // 使用 Integer.compare 避免潜在的溢出问题
                // 或者更简洁的 Lambda 表达式 (Java 8+)
                // return Integer.compare(Math.abs(a), Math.abs(b));
            }
        };

        // 使用自定义的 Comparator 对 Integer 数组进行排序
        Arrays.sort(integerArray, absComparator);
        System.out.println("按绝对值排序后 Integer 数组: " + Arrays.toString(integerArray));
        // 预期输出 (绝对值: 1, 2, 3, 4, 5, 8, 9): [1, 2, -3, 4, -5, -8, 9] 或其他绝对值相同的元素的排列

        System.out.println("--------------------");

        // --- 示例 2: 对 List<Integer> 进行排序 ---
        List<Integer> integerList = new ArrayList<>(Arrays.asList(-10, 6, -1, 7, -4));
        System.out.println("原始 Integer List: " + integerList);

        // 可以复用上面的 absComparator，或者使用 Lambda 表达式创建 Comparator
        Comparator<Integer> absComparatorLambda = (a, b) -> Integer.compare(Math.abs(a), Math.abs(b));

        // 使用自定义的 Comparator 对 List 进行排序
        Collections.sort(integerList, absComparatorLambda);
        // 或者使用 List 接口自带的 sort 方法 (Java 8+)
        // integerList.sort(absComparatorLambda);

        System.out.println("按绝对值排序后 Integer List: " + integerList);
        // 预期输出 (绝对值: 1, 4, 6, 7, 10): [-1, -4, 6, 7, -10] 或其他绝对值相同的元素的排列

        System.out.println("--------------------");

        // --- 示例 3: 对基本类型 int[] 数组进行排序 (需要转换为包装类数组) ---
        int[] intArray = { -50, 20, -80, 10, 90, -30, 40 };
        System.out.println("原始 int 数组: " + Arrays.toString(intArray));

        // 将 int[] 转换为 Integer[]
        Integer[] integerArrayFromInt = new Integer[intArray.length];
        for (int i = 0; i < intArray.length; i++) {
            integerArrayFromInt[i] = intArray[i];
        }

        // 使用自定义的 Comparator 对 Integer 数组进行排序
        Arrays.sort(integerArrayFromInt, absComparatorLambda); // 复用 Lambda Comparator

        // 如果需要，可以将排序后的 Integer[] 转换回 int[]
        for (int i = 0; i < intArray.length; i++) {
            intArray[i] = integerArrayFromInt[i];
        }

        System.out.println("按绝对值排序后 int 数组: " + Arrays.toString(intArray));
        // 预期输出 (绝对值: 10, 20, 30, 40, 50, 80, 90): [10, 20, -30, 40, -50, -80, 90] 或其他排列
    }
}
```

**解释：**

1.  **`Comparator<Integer>`:** 我们创建了一个实现了 `Comparator<Integer>` 接口的匿名内部类（或使用 Lambda 表达式）。这个接口要求实现 `compare(Integer a, Integer b)` 方法。
2.  **`compare(Integer a, Integer b)`:** 这个方法接收两个 `Integer` 对象 `a` 和 `b` 作为输入，并根据我们定义的规则返回一个整数：
    *   如果 `a` 应该排在 `b` 前面，返回负数。
    *   如果 `a` 应该排在 `b` 后面，返回正数。
    *   如果 `a` 和 `b` 的相对顺序不重要，返回 0。
3.  **计算绝对值:** 在 `compare` 方法内部，我们使用 `Math.abs(a)` 和 `Math.abs(b)` 来获取两个数字的绝对值。
4.  **比较绝对值:** 我们使用 `Integer.compare(absA, absB)` 来比较这两个绝对值。`Integer.compare()` 是一个安全的方法，可以避免直接相减可能导致的整数溢出问题。
5.  **`Arrays.sort(Object[], Comparator)`:** 对于对象数组（如 `Integer[]`），调用 `Arrays.sort()` 并传入数组和我们创建的 `absComparator`。
6.  **`Collections.sort(List, Comparator)` 或 `List.sort(Comparator)`:** 对于 List 集合，调用 `Collections.sort()` 或 List 自身的 `sort()` 方法，并传入 List 和 `absComparator`。
7.  **基本类型数组的处理:** 由于 `Arrays.sort(int[], Comparator)` 不存在，我们展示了如何将 `int[]` 转换为 `Integer[]`，排序后再转换回来（如果需要）。在实际开发中，如果频繁需要这种排序，或者数据量很大，可能需要考虑更高效的专门算法，但对于一般情况，这种转换是可行且易于理解的。

通过这种方式，你可以灵活地定义任何基于元素属性（如绝对值、长度、某个字段等）的排序规则。












### 贪心算法，自定义比较器Comparator按绝对值排序，无注释



```java



class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {

        int sum=0;

        Integer[] numsInteger = new Integer[ nums.length ];

        for( int i=0; i < nums.length; i++ ) {

            numsInteger[i] = nums[i];
        }


        Comparator<Integer> absComparator = new Comparator<Integer>() {


            @Override
            public int compare( Integer a, Integer b ) {

                int absA = Math.abs( a );

                int absB = Math.abs( b );

                return Integer.compare( absA,absB );


            }

        };

        
        Arrays.sort( numsInteger, absComparator );


        for( int i=nums.length-1; i >= 0; i-- ) {


            if( k > 0 && numsInteger[i] < 0 ) {

                numsInteger[i] *= -1;

                k--;
            }



        }


        if( k % 2 == 1 ) {

            numsInteger[0] *= -1;

        }


        for( int num : numsInteger ) {

            sum += num;
        }


        return sum;
        
    }




}




```









### 贪心算法，自定义比较器Comparator按绝对值排序，注释版




命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法








好的，我们来为你的 LeetCode 1005 题解代码添加详细的注释和说明。

**代码（带详细注释）：**

```java
/**
 * 解题思路总结 (贪心算法):
 *
 * 目标：经过 k 次取反操作后，使得数组 nums 的元素和最大化。
 *
 * 贪心策略：为了尽可能增大数组和，我们应该优先将负数变为正数。而且，为了让增加的幅度最大，
 * 我们应该优先选择绝对值最大的负数进行取反。
 *
 * 步骤：
 * 1.  按绝对值排序：将数组按照元素的绝对值从大到小进行排序。这样可以方便我们优先处理绝对值大的数。
 *     (注意：代码中是按绝对值从小到大排序，然后从后往前遍历，效果等同于按绝对值从大到小排序后从前往后遍历)。
 * 2.  遍历并取反负数：从绝对值最大的元素开始遍历（即排序后的数组末尾）。如果当前元素是负数且 k > 0，
 *     则将其取反，并将 k 减 1。这样可以确保优先将绝对值大的负数变成正数，最大化每次取反操作带来的增益。
 * 3.  处理剩余的 k：
 *     -   如果 k 仍然大于 0，说明所有负数都已经被取反了（或者原数组就没有负数）。
 *     -   此时，为了让数组和尽可能大，我们必须继续执行取反操作，直到 k 耗尽。
 *     -   每次取反操作都会使数组总和减少。为了让减少的幅度最小，我们应该选择数组中绝对值最小的元素进行取反。
 *     -   由于数组已经按绝对值排序（从小到大），绝对值最小的元素位于数组的第一个位置 (numsInteger[0])。
 *     -   如果 k 是偶数，那么对同一个元素（绝对值最小的元素）执行偶数次取反操作，其值不变，对总和没有影响。
 *     -   如果 k 是奇数，那么对同一个元素（绝对值最小的元素）执行奇数次取反操作，相当于只取反了一次。所以，
 *       当 k 为奇数时，将绝对值最小的元素 (numsInteger[0]) 取反一次。
 * 4.  计算总和：遍历修改后的数组，计算所有元素的和，即为最终结果。
 *
 * 关键点：
 * -   按绝对值排序是贪心策略的核心，确保优先处理影响最大的元素。
 * -   处理剩余 k 的逻辑是关键，要理解为什么选择绝对值最小的元素进行反复取反。
 * -   需要将 int[] 转换为 Integer[] 才能使用自定义 Comparator 进行排序。
 */
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {

        // 初始化最终的数组和
        int sum = 0;

        // 1. 将基本类型 int[] 转换为包装类 Integer[]
        //    因为 Arrays.sort(T[] a, Comparator<? super T> c) 方法需要对象数组
        Integer[] numsInteger = new Integer[nums.length];
        for (int i = 0; i < nums.length; i++) {
            numsInteger[i] = nums[i]; // 自动装箱 int -> Integer
        }

        // 2. 创建一个自定义比较器 Comparator，用于按元素的绝对值进行比较
        Comparator<Integer> absComparator = new Comparator<Integer>() {
            @Override
            public int compare(Integer a, Integer b) {
                // 计算两个元素的绝对值
                int absA = Math.abs(a);
                int absB = Math.abs(b);
                // 比较绝对值，实现升序排序 (绝对值小的在前)
                return Integer.compare(absA, absB);
                // 返回负数表示 a < b (按绝对值)，返回 0 表示相等，返回正数表示 a > b (按绝对值)
            }
        };

        // 3. 使用自定义比较器对 Integer 数组按绝对值升序排序
        Arrays.sort(numsInteger, absComparator);
        // 排序后，数组元素的绝对值从小到大排列，例如 [-1, 2, -3, 4] -> [-1, 2, -3, 4] (绝对值 1, 2, 3, 4)

        // 4. 第一轮贪心：从绝对值最大的元素开始遍历 (即从数组末尾向前遍历)
        //    优先将绝对值大的负数取反
        for (int i = nums.length - 1; i >= 0; i--) {
            // 如果还有取反次数 (k > 0) 并且当前元素是负数
            if (k > 0 && numsInteger[i] < 0) {
                // 将该负数取反 (变为正数)
                numsInteger[i] *= -1;
                // 消耗一次取反次数
                k--;
            }
            // 如果 k 已经用完或者当前元素是正数/零，则不进行操作，继续向前遍历
        }

        // 5. 第二轮贪心：处理剩余的 k
        //    如果 k 还有剩余，并且 k 是奇数
        //    (如果 k 是偶数，对同一个数操作偶数次等于没操作，总和不变)
        if (k % 2 == 1) {
            // 将绝对值最小的元素取反 (数组已按绝对值升序排序，第一个元素 numsInteger[0] 绝对值最小)
            // 这样做是为了让因为必须执行的取反操作而导致的数组总和减少量最小化
            numsInteger[0] *= -1;
        }
        // 如果 k 是偶数，无需任何操作

        // 6. 计算最终数组的总和
        for (int num : numsInteger) {
            sum += num;
        }

        // 返回最大化的数组和
        return sum;
    }
}
```

**结合示例和代码进行详细讲解说明**

**核心思想：** 每次取反操作都应该尽可能地增加数组的总和。

1.  **优先反转负数：** 将一个负数 `-x` (x>0) 变为正数 `x`，数组总和增加 `2x`。显然，`x` 越大（即负数的绝对值越大），增加的幅度就越大。所以贪心策略的第一步是优先将绝对值大的负数变为正数。
2.  **按绝对值排序：** 为了方便找到绝对值大的负数，我们先将数组按绝对值排序。代码中是按绝对值从小到大排序，然后从后往前遍历，这等价于按绝对值从大到小排序后从前往后遍历。
3.  **处理剩余 K：** 当所有负数都变成正数后（或者本来就没有负数），如果 `k` 还有剩余，我们仍然必须执行取反操作。这时，任何取反操作都会使数组总和减少。将正数 `x` 变为负数 `-x`，总和减少 `2x`。为了让减少量最小，我们应该选择绝对值最小的数进行取反。由于数组已按绝对值排序，绝对值最小的数就是 `numsInteger[0]`。
    *   如果剩余的 `k` 是偶数，比如 `k=2`，我们对 `numsInteger[0]` 取反两次，它又变回了原来的值，总和不变。
    *   如果剩余的 `k` 是奇数，比如 `k=1` 或 `k=3`，我们对 `numsInteger[0]` 取反奇数次，相当于只取反了一次。所以只需要在 `k` 为奇数时，将 `numsInteger[0]` 取反一次即可。

**示例 1：`nums = [4, 2, 3], k = 1`**

1.  转为 `Integer[]`: `[4, 2, 3]`
2.  按绝对值排序: `[2, 3, 4]` (绝对值 2, 3, 4)
3.  从后往前遍历 (`i = 2, 1, 0`):
    *   `i = 2`: `numsInteger[2] = 4` (正数)，`k=1`。不操作。
    *   `i = 1`: `numsInteger[1] = 3` (正数)，`k=1`。不操作。
    *   `i = 0`: `numsInteger[0] = 2` (正数)，`k=1`。不操作。
4.  第一轮遍历结束，`k = 1` 仍然大于 0。
5.  处理剩余 `k`：`k % 2 == 1` (1 % 2 == 1)，为奇数。将绝对值最小的 `numsInteger[0]` (即 2) 取反。数组变为 `[-2, 3, 4]`。
6.  计算总和：`-2 + 3 + 4 = 5`。
7.  返回 `5`。

**示例 2：`nums = [3, -1, 0, 2], k = 3`**

1.  转为 `Integer[]`: `[3, -1, 0, 2]`
2.  按绝对值排序: `[0, -1, 2, 3]` (绝对值 0, 1, 2, 3)
3.  从后往前遍历 (`i = 3, 2, 1, 0`):
    *   `i = 3`: `numsInteger[3] = 3` (正数)，`k=3`。不操作。
    *   `i = 2`: `numsInteger[2] = 2` (正数)，`k=3`。不操作。
    *   `i = 1`: `numsInteger[1] = -1` (负数)，`k=3 > 0`。取反 `numsInteger[1]` 变为 `1`。`k` 变为 `2`。数组变为 `[0, 1, 2, 3]`。
    *   `i = 0`: `numsInteger[0] = 0` (零)，`k=2`。不操作。
4.  第一轮遍历结束，`k = 2` 仍然大于 0。
5.  处理剩余 `k`：`k % 2 == 0` (2 % 2 == 0)，为偶数。无需操作。数组仍为 `[0, 1, 2, 3]`。
6.  计算总和：`0 + 1 + 2 + 3 = 6`。
7.  返回 `6`。

**示例 3：`nums = [2, -3, -1, 5, -4], k = 2`**

1.  转为 `Integer[]`: `[2, -3, -1, 5, -4]`
2.  按绝对值排序: `[-1, 2, -3, -4, 5]` (绝对值 1, 2, 3, 4, 5)
3.  从后往前遍历 (`i = 4, 3, 2, 1, 0`):
    *   `i = 4`: `numsInteger[4] = 5` (正数)，`k=2`。不操作。
    *   `i = 3`: `numsInteger[3] = -4` (负数)，`k=2 > 0`。取反 `numsInteger[3]` 变为 `4`。`k` 变为 `1`。数组变为 `[-1, 2, -3, 4, 5]`。
    *   `i = 2`: `numsInteger[2] = -3` (负数)，`k=1 > 0`。取反 `numsInteger[2]` 变为 `3`。`k` 变为 `0`。数组变为 `[-1, 2, 3, 4, 5]`。
    *   `i = 1`: `numsInteger[1] = 2` (正数)，`k=0`。不操作。
    *   `i = 0`: `numsInteger[0] = -1` (负数)，`k=0`。不操作。
4.  第一轮遍历结束，`k = 0`。
5.  处理剩余 `k`：`k` 不大于 0。无需操作。数组仍为 `[-1, 2, 3, 4, 5]`。
6.  计算总和：`-1 + 2 + 3 + 4 + 5 = 13`。
7.  返回 `13`。

通过这些示例，你可以看到代码是如何一步步执行贪心策略，最终得到最大化的数组和的。注释也详细说明了每一步的目的和依据。










### 贪心算法，两次sort排序，无注释



```java



class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {


        int sum=0;


        Arrays.sort( nums );


        for( int i=0; i < nums.length; i++ ) {


            
            if( nums[i] < 0 && k > 0 ) {

                nums[i] *= -1;

                k--;

            }

        }


        if( k % 2 == 1 ) {


            Arrays.sort( nums );

            nums[0] *= -1;


        }



        for( int num : nums ) {

            sum += num;
        }

        return sum;
        
    }
}



```












### 贪心算法，两次sort排序，注释版


命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法





好的，我们来为你的 LeetCode 1005 题解的“最佳解法”代码添加详细的注释和说明。这个解法相比之前使用绝对值排序的版本，在实现上更简洁一些。

**代码（带详细注释）：**

```java
/**
 * 解题思路总结 (贪心算法 - 优化版):
 *
 * 目标：经过 k 次取反操作后，使得数组 nums 的元素和最大化。
 *
 * 贪心策略：
 * 1.  优先将负数变为正数：为了尽可能增大数组和，我们应该优先将负数变为正数。
 * 2.  优先处理最小的负数：将一个负数 `-x` (x>0) 变为正数 `x`，数组总和增加 `2x`。虽然反转绝对值大的负数增加得更多，
 *     但我们最终的目标是让所有数尽可能为正。如果先反转绝对值小的负数，可以更快地消耗掉负数，
 *     为后续处理剩余 k 值（如果 k 耗尽前所有数都已非负）留下绝对值更小的数，从而在必须反转非负数时，
 *     使得总和的减少量最小。因此，先对数组排序，优先处理数值最小（即最负）的数是有效的贪心策略。
 *
 * 步骤：
 * 1.  排序：将数组 `nums` 按升序排序。这样，负数会排在数组前面，并且数值最小（最负）的数在最前面。
 * 2.  遍历并取反负数：从数组开头遍历。如果当前元素是负数 (`nums[i] < 0`) 且还有取反次数 (`k > 0`)，
 *     则将其取反 (`nums[i] *= -1`)，并将 `k` 减 1。持续这个过程，直到遍历完所有负数或者 `k` 耗尽。
 * 3.  处理剩余的 k：
 *     -   经过步骤 2 后，数组中的所有负数（如果有的话）都已经被尽可能地取反了。
 *     -   如果 `k` 仍然大于 0，说明我们必须继续执行取反操作。
 *     -   此时，数组中的所有元素都已非负（或者 `k` 在处理负数时就已耗尽）。
 *     -   每次对非负数取反都会使数组总和减少。为了让减少的幅度最小，我们应该选择数组中**绝对值最小**的元素进行取反。
 *     -   由于步骤 2 可能改变了元素的顺序（负数变正数），我们需要**再次对数组排序**，以确保找到当前数组中绝对值最小的元素（它将位于 `nums[0]`）。
 *     -   如果剩余的 `k` 是偶数 (`k % 2 == 0`)，那么对同一个元素（绝对值最小的元素 `nums[0]`）执行偶数次取反操作，其值不变，对总和没有影响。
 *     -   如果剩余的 `k` 是奇数 (`k % 2 == 1`)，那么对同一个元素（绝对值最小的元素 `nums[0]`）执行奇数次取反操作，相当于只取反了一次。所以，当 `k` 为奇数时，将绝对值最小的元素 `nums[0]` 取反一次。
 * 4.  计算总和：遍历修改后的数组，计算所有元素的和，即为最终结果。
 *
 * 关键点：
 * -   第一次排序是为了优先处理负数，特别是数值最小的负数。
 * -   第二次排序（仅当 k 还有剩余时需要考虑）是为了找到当前数组中绝对值最小的元素，以最小化因必须执行剩余取反操作而造成的损失。
 * -   处理剩余 k 为奇数的情况是关键。
 */
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {

        // 初始化最终的数组和
        int sum = 0;

        // 1. 对原数组进行升序排序
        //    目的是将负数排在前面，方便优先处理
        Arrays.sort(nums); // 例如 [-4, -3, -1, 2, 5]

        // 2. 第一轮贪心：遍历数组，优先将负数取反
        for (int i = 0; i < nums.length; i++) {
            // 如果当前元素是负数，并且还有取反次数
            if (nums[i] < 0 && k > 0) {
                // 将该负数取反
                nums[i] *= -1; // 例如 -4 变为 4
                // 消耗一次取反次数
                k--;
            }
            // 如果当前元素是非负数，或者 k 已经用完，则停止对负数的取反操作
            // 因为数组是排序的，一旦遇到非负数，后面的也都是非负数
            // (虽然取反可能导致顺序变化，但这一轮只关心将负数变正)
            // 优化：可以在遇到第一个非负数时 break 循环，因为后面的肯定也非负
            // if (nums[i] >= 0) break; // 可以加这句优化
        }

        // 3. 第二轮贪心：处理剩余的 k
        //    如果 k 还有剩余 (说明所有负数都已被反转，或者原数组就没有负数)
        //    并且 k 是奇数 (偶数次反转同一个数等于没反转)
        if (k % 2 == 1) {
            // 需要再次排序，找到当前数组中绝对值最小的元素
            // 因为之前的取反操作可能改变了元素的相对大小 (例如 -1 变 1, -4 变 4)
            // 排序后，绝对值最小的元素（现在都是非负数了）就在 nums[0]
            Arrays.sort(nums); // 例如 [1, 2, 3, 4, 5] -> [1, 2, 3, 4, 5] 或 [0, 1, 2, 3] -> [0, 1, 2, 3]
            // 将绝对值最小的元素取反，以最小化总和的损失
            nums[0] *= -1; // 例如将 1 变为 -1, 或将 0 变为 0
        }
        // 如果 k 是偶数，无需任何操作

        // 4. 计算最终数组的总和
        for (int num : nums) {
            sum += num;
        }

        // 返回最大化的数组和
        return sum;
    }
}
```

**结合示例和代码进行详细讲解说明**

**核心思想：** 优先把负数变成正数，如果必须反转非负数，则选择绝对值最小的数进行反转，以最小化损失。

1.  **第一次排序 `Arrays.sort(nums)`：** 目的是把所有负数集中到数组前面，并且数值最小（最负）的在最前面。
2.  **遍历反转负数：** 从头开始遍历，遇到负数就反转，同时消耗 `k`。这样保证了我们优先处理的是数值最小的负数。例如，对于 `[-4, -1, 2]`，先反转 `-4` 成 `4`，再反转 `-1` 成 `1`。
3.  **处理剩余 `k`：**
    *   **`k` 耗尽：** 如果在反转负数的过程中 `k` 变成了 0，那么操作结束，直接计算总和。
    *   **`k` 有剩余：** 这意味着数组里已经没有负数了（或者本来就没有）。我们必须继续反转。为了让总和尽可能大（即损失尽可能小），应该反转当前数组中绝对值最小的数。
    *   **第二次排序 `Arrays.sort(nums)`：** 因为之前的反转可能打乱了绝对值大小的顺序（比如 `-1` 变成 `1`，`-4` 变成 `4`），所以需要再次排序，找到当前绝对值最小的元素，它会在 `nums[0]`。
    *   **`k` 的奇偶性：** 如果剩余的 `k` 是偶数，反复反转 `nums[0]` 偶数次等于没反转，总和不变。如果剩余的 `k` 是奇数，反复反转 `nums[0]` 奇数次等于反转一次，所以只需将 `nums[0]` 反转一次。

**示例 1：`nums = [4, 2, 3], k = 1`**

1.  第一次排序: `[2, 3, 4]`
2.  遍历反转负数: 数组中没有负数。`k` 仍然是 `1`。
3.  处理剩余 `k`: `k = 1` 是奇数。
    *   第二次排序: `[2, 3, 4]` (不变)
    *   反转 `nums[0]`: `nums[0]` (即 2) 变为 `-2`。数组变为 `[-2, 3, 4]`。
4.  计算总和: `-2 + 3 + 4 = 5`。
5.  返回 `5`。

**示例 2：`nums = [3, -1, 0, 2], k = 3`**

1.  第一次排序: `[-1, 0, 2, 3]`
2.  遍历反转负数:
    *   `i = 0`: `nums[0] = -1` (负数)，`k = 3 > 0`。反转 `-1` 为 `1`。`k` 变为 `2`。数组变为 `[1, 0, 2, 3]`。
    *   `i = 1`: `nums[1] = 0` (非负数)。停止或继续遍历，但不会再反转。
3.  处理剩余 `k`: `k = 2` 是偶数。无需操作。数组仍为 `[1, 0, 2, 3]` (或排序后 `[0, 1, 2, 3]`)。
4.  计算总和: `1 + 0 + 2 + 3 = 6`。
5.  返回 `6`。

**示例 3：`nums = [2, -3, -1, 5, -4], k = 2`**

1.  第一次排序: `[-4, -3, -1, 2, 5]`
2.  遍历反转负数:
    *   `i = 0`: `nums[0] = -4` (负数)，`k = 2 > 0`。反转 `-4` 为 `4`。`k` 变为 `1`。数组变为 `[4, -3, -1, 2, 5]`。
    *   `i = 1`: `nums[1] = -3` (负数)，`k = 1 > 0`。反转 `-3` 为 `3`。`k` 变为 `0`。数组变为 `[4, 3, -1, 2, 5]`。
    *   `k` 已经为 0，停止反转。
3.  处理剩余 `k`: `k = 0`。无需操作。数组为 `[4, 3, -1, 2, 5]`。
4.  计算总和: `4 + 3 + (-1) + 2 + 5 = 13`。
5.  返回 `13`。

这个版本的代码通过两次排序（如果需要）和一次遍历，巧妙地实现了贪心策略，逻辑更直接，避免了使用包装类和自定义比较器。





---










## 力扣134. 加油站
已解答
中等

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

 

示例 1:

输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

示例 2:

输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
 

提示:

gas.length == n
cost.length == n
1 <= n <= 10^5
0 <= gas[i], cost[i] <= 10^4

















### 贪心算法，无注释


局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。
全局最优：找到可以跑一圈的起始位置。




```java




class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {


        int curSum=0;

        int totalSum=0;

        int start=0;


        for( int i=0; i < gas.length; i++ ) {


            curSum += gas[i] - cost[i];

            totalSum += gas[i] -cost[i];


            if( curSum < 0 ) {

                start = i + 1;

                curSum = 0;

            }

        }


        if( totalSum < 0 ) {

            return -1;
        }


        return start;


        
    }
}



```

































### 贪心算法，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法







好的，我们来为你的 LeetCode 134 (加油站) 题解代码添加详细的注释和说明。

**代码（带详细注释）：**

```java
/**
 * 解题思路总结 (贪心算法):
 *
 * 目标：找到一个起始加油站的索引，从该站出发可以绕环路行驶一周。如果不存在，返回 -1。
 *
 * 贪心策略：
 * 1.  整体判断：如果所有加油站的总油量 `sum(gas)` 小于总消耗量 `sum(cost)`，那么无论从哪个站出发，
 *     都无法完成环路行驶。可以直接返回 -1。
 * 2.  局部最优寻找起点：我们尝试从索引 0 开始作为起点，并维护一个 `curSum` 变量，表示从当前起点出发
 *     到当前位置 `i` 的净油量（`gas[i] - cost[i]` 的累加和）。
 *     -   如果 `curSum` 在任何时候 `i` 变为负数，说明从当前的 `start` 点出发，无法到达 `i+1`。
 *     -   关键贪心点：如果从 `start` 到 `i` 的 `curSum` 变为负数，那么 `start` 到 `i` 之间的任何一个点
 *       都不能作为有效的起点。因为如果 `start` 到 `j` (`start <= j <= i`) 可以作为起点，那么从 `start`
 *       出发到达 `j` 时油量必然是非负的，而从 `j` 到 `i` 的油量变化是负的（否则 `curSum` 不会小于 0），
 *       所以从 `j` 出发也无法到达 `i+1`。
 *     -   因此，当 `curSum < 0` 时，我们将下一个可能的起点 `start` 更新为 `i + 1`，并将 `curSum` 重置为 0，
 *       重新开始计算净油量。
 * 3.  全局最优验证：遍历结束后，如果 `totalSum` (即 `sum(gas) - sum(cost)`) 大于等于 0，
 *     并且我们找到了一个 `start`，那么这个 `start` 就是唯一解。为什么？因为如果 `totalSum >= 0`，
 *     必然存在解。而我们的贪心策略排除了所有不可能的起点，最后剩下的 `start` 就是那个能走完全程的起点。
 *     （有一个数学证明：如果 `totalSum >= 0`，那么必然存在一个点 `k`，使得从 `k` 出发，到任何 `j` 的
 *     `curSum` 都大于等于 0）。
 *
 * 步骤：
 * 1.  初始化 `curSum = 0` (当前段的净油量)，`totalSum = 0` (总净油量)，`start = 0` (假设起点)。
 * 2.  遍历所有加油站 `i` 从 0 到 `n-1`：
 *     -   计算当前站的净油量 `diff = gas[i] - cost[i]`。
 *     -   累加到 `curSum` 和 `totalSum`。
 *     -   如果 `curSum < 0`：
 *         -   说明从当前 `start` 无法到达 `i+1`。
 *         -   更新 `start = i + 1`。
 *         -   重置 `curSum = 0`。
 * 3.  遍历结束后，检查 `totalSum`：
 *     -   如果 `totalSum < 0`，说明总油量不足以支撑总消耗，返回 -1。
 *     -   否则，返回 `start`。
 *
 * 时间复杂度：O(n)，只需要一次遍历。
 * 空间复杂度：O(1)，只需要常数个额外变量。
 */
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {

        // curSum: 从当前假设的起点 start 到当前位置 i 的净油量累加值
        int curSum = 0;
        // totalSum: 整个环路的总净油量 (总 gas - 总 cost)，用于最终判断是否有解
        int totalSum = 0;
        // start: 假设的有效起始加油站索引，初始为 0
        int start = 0;

        // 遍历所有加油站
        for (int i = 0; i < gas.length; i++) {

            // 计算当前加油站的净油量 (加的油 - 到下一站消耗的油)
            int diff = gas[i] - cost[i];

            // 累加到当前段的净油量
            curSum += diff;
            // 累加到总净油量
            totalSum += diff;

            // 【贪心关键点】如果 curSum < 0
            if (curSum < 0) {
                // 说明从当前的 start 点出发，无法到达 i+1 站
                // 那么从 start 到 i 之间的任何一个点出发，也无法到达 i+1 站
                // 因此，下一个可能的起点只能是 i+1
                start = i + 1;
                // 重置当前段的净油量计算器，因为我们换了新的起点假设
                curSum = 0;
            }
        }

        // 遍历结束后，检查总净油量
        if (totalSum < 0) {
            // 如果总油量小于总消耗量，则无论从哪里出发都无法完成环路
            return -1;
        }

        // 如果 totalSum >= 0，说明必然存在解
        // 并且根据我们的贪心策略，最后得到的 start 就是那个唯一解
        // 因为所有在 start 之前的点都已经被证明无法作为起点走完对应的路段
        return start;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 1: `gas = [1,2,3,4,5], cost = [3,4,5,1,2]`**

*   `n = 5`

| i   | gas[i] | cost[i] | diff | totalSum (before) | totalSum (after) | curSum (before) | curSum (after) | start | curSum < 0? | Action        |
| --- | ------ | ------- | ---- | ----------------- | ---------------- | --------------- | -------------- | ----- | ----------- | ------------- |
| 0   | 1      | 3       | -2   | 0                 | -2               | 0               | -2             | 0     | Yes         | start=1, curSum=0 |
| 1   | 2      | 4       | -2   | -2                | -4               | 0               | -2             | 1     | Yes         | start=2, curSum=0 |
| 2   | 3      | 5       | -2   | -4                | -6               | 0               | -2             | 2     | Yes         | start=3, curSum=0 |
| 3   | 4      | 1       | 3    | -6                | -3               | 0               | 3              | 3     | No          |               |
| 4   | 5      | 2       | 3    | -3                | 0                | 3               | 6              | 3     | No          |               |

**遍历结束：**

1.  `totalSum = 0`。
2.  `totalSum >= 0` 条件满足。
3.  返回 `start` 的最终值 `3`。

**解释：**

*   **i=0:** `curSum` 变为 -2，小于 0。说明从 0 出发无法到达 1。将 `start` 设为 1，`curSum` 重置为 0。
*   **i=1:** `curSum` 变为 -2，小于 0。说明从 1 出发无法到达 2。将 `start` 设为 2，`curSum` 重置为 0。
*   **i=2:** `curSum` 变为 -2，小于 0。说明从 2 出发无法到达 3。将 `start` 设为 3，`curSum` 重置为 0。
*   **i=3:** `curSum` 变为 3，大于等于 0。继续。
*   **i=4:** `curSum` 变为 6，大于等于 0。继续。
*   循环结束。此时 `totalSum = 0`，满足 `>= 0` 的条件。返回最终的 `start` 值 `3`。这表明从索引 3 出发是可行的。

**示例 2: `gas = [2,3,4], cost = [3,4,3]`**

*   `n = 3`

| i   | gas[i] | cost[i] | diff | totalSum (before) | totalSum (after) | curSum (before) | curSum (after) | start | curSum < 0? | Action        |
| --- | ------ | ------- | ---- | ----------------- | ---------------- | --------------- | -------------- | ----- | ----------- | ------------- |
| 0   | 2      | 3       | -1   | 0                 | -1               | 0               | -1             | 0     | Yes         | start=1, curSum=0 |
| 1   | 3      | 4       | -1   | -1                | -2               | 0               | -1             | 1     | Yes         | start=2, curSum=0 |
| 2   | 4      | 3       | 1    | -2                | -1               | 0               | 1              | 2     | No          |               |

**遍历结束：**

1.  `totalSum = -1`。
2.  `totalSum < 0` 条件满足。
3.  返回 `-1`。

**解释：**

*   **i=0:** `curSum` 变为 -1，小于 0。将 `start` 设为 1，`curSum` 重置为 0。
*   **i=1:** `curSum` 变为 -1，小于 0。将 `start` 设为 2，`curSum` 重置为 0。
*   **i=2:** `curSum` 变为 1，大于等于 0。继续。
*   循环结束。此时 `totalSum = -1`，不满足 `>= 0` 的条件。返回 `-1`。这表明不存在可以完成环路行驶的起点。

这个贪心算法通过一次遍历就能够确定是否存在解以及解的起始位置（如果存在），非常高效。关键在于理解 `curSum < 0` 时更新 `start` 和重置 `curSum` 的逻辑，以及最后通过 `totalSum` 判断全局可行性。




---









## 力扣135. 分发糖果
已解答
困难

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

 

示例 1：

输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

示例 2：

输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
 

提示：

n == ratings.length
1 <= n <= 2 * 10^4
0 <= ratings[i] <= 2 * 10^4







### 两次贪心的策略，无注释

一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
一次是从右到左遍历，只比较左边孩子评分比右边大的情况。
这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。





```java


class Solution {
    public int candy(int[] ratings) {
        //两次贪心


        int candies[] = new int[ratings.length];

        int sum=0;

        // for( int candy : candies ) {
        //     /**第一个循环试图将所有孩子的糖果数初始化为1，
        //     但使用增强for循环（for (int candy : candies)）修改值时，
        //     实际修改的是循环变量的副本，而非数组元素本身。
        //     这导致所有candies数组的值仍为0。 */
        //     candy = 1;
        // }

        // 正确写法：使用普通for循环
        Arrays.fill(candies, 1); // 或遍历索引赋值

        /**先确定右边评分大于左边的情况（也就是从前向后遍历）
        局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，
        全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果 */
        for( int i=1; i < candies.length; i++ ) {

            if( ratings[i] > ratings[i-1] ) {

                candies[i] = candies[i-1] + 1;

            }

        }

        /**确定左孩子大于右孩子的情况一定要从后向前遍历
        局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。
        全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。 */
        for( int i=candies.length-2; i >= 0; i-- ) {

            if( ratings[i] > ratings[i+1] ) {

                candies[i] = Math.max( candies[i], candies[i+1] + 1 );

            }

        }


        for( int candy : candies ) {

            sum += candy;
        }


        return sum;

        
    }
}



```















### 两次贪心的策略，注释版

一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
一次是从右到左遍历，只比较左边孩子评分比右边大的情况。
这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法








          
好的，我们来为你的 LeetCode 135 (分发糖果) 题解代码添加详细的注释和说明。

**代码（带详细注释）：**

```java
import java.util.Arrays; // 引入 Arrays 类，用于填充数组

/**
 * 解题思路总结 (LeetCode 135: 分发糖果 - 两次贪心):
 *
 * 目标：给 n 个孩子分发糖果，满足以下条件，并计算最少需要的糖果总数：
 * 1. 每个孩子至少分配到 1 个糖果。
 * 2. 相邻两个孩子评分更高的孩子会获得更多的糖果。
 *
 * 贪心策略：
 * 这个问题的难点在于，一个孩子的糖果数同时受到其左边和右边孩子评分的影响。
 * 直接一次遍历很难同时满足两个方向的比较。因此，采用两次遍历的贪心策略：
 *
 * 1.  第一次遍历（从左到右）：
 *     -   目的：处理所有 `ratings[i] > ratings[i-1]` 的情况。
 *     -   初始化：给每个孩子分配 1 颗糖果。
 *     -   遍历：从左到右遍历孩子。如果当前孩子 `i` 的评分高于左边孩子 `i-1`，
 *       则当前孩子 `i` 的糖果数应该比左边孩子 `i-1` 多一个 (`candies[i] = candies[i-1] + 1`)。
 *     -   结果：这次遍历保证了所有评分递增的相邻孩子对中，右边孩子的糖果数比左边多。
 *
 * 2.  第二次遍历（从右到左）：
 *     -   目的：处理所有 `ratings[i] > ratings[i+1]` 的情况，并修正第一次遍历的结果。
 *     -   遍历：从右到左遍历孩子（从 `n-2` 到 `0`）。如果当前孩子 `i` 的评分高于右边孩子 `i+1`，
 *       则当前孩子 `i` 的糖果数应该比右边孩子 `i+1` 多一个。
 *     -   关键修正：在设置 `candies[i]` 时，需要取 `candies[i]` 的当前值（第一次遍历的结果）
 *       和 `candies[i+1] + 1` 中的较大值 (`candies[i] = Math.max(candies[i], candies[i+1] + 1)`)。
 *       这是因为 `candies[i]` 必须同时满足比左边评分低的孩子多（如果 `ratings[i] > ratings[i-1]`）
 *       和比右边评分低的孩子多（如果 `ratings[i] > ratings[i+1]`）。取 `max` 操作确保了这一点。
 *       例如，如果 `ratings = [1, 3, 2]`：
 *         - 第一次遍历后：`candies = [1, 2, 1]`
 *         - 第二次遍历到 `i=1` (`ratings[1]=3 > ratings[2]=2`)：
 *           需要 `candies[1]` 比 `candies[2]` 多 1，即 `candies[1]` 至少为 `candies[2]+1 = 1+1 = 2`。
 *           当前 `candies[1]` 已经是 2，`Math.max(2, 2)` 结果是 2。
 *       例如，如果 `ratings = [1, 2, 0]`：
 *         - 第一次遍历后：`candies = [1, 2, 1]`
 *         - 第二次遍历到 `i=1` (`ratings[1]=2 > ratings[2]=0`)：
 *           需要 `candies[1]` 比 `candies[2]` 多 1，即 `candies[1]` 至少为 `candies[2]+1 = 1+1 = 2`。
 *           当前 `candies[1]` 已经是 2，`Math.max(2, 2)` 结果是 2。
 *       例如，如果 `ratings = [3, 2, 1]`：
 *         - 第一次遍历后：`candies = [1, 1, 1]`
 *         - 第二次遍历到 `i=1` (`ratings[1]=2 > ratings[2]=1`)：`candies[1] = Math.max(1, 1+1) = 2`。数组变为 `[1, 2, 1]`。
 *         - 第二次遍历到 `i=0` (`ratings[0]=3 > ratings[1]=2`)：`candies[0] = Math.max(1, 2+1) = 3`。数组变为 `[3, 2, 1]`。
 *
 * 3.  计算总和：将最终 `candies` 数组中的所有元素求和，即为最少需要的糖果总数。
 *
 * 为什么这样可行？
 * - 第一次遍历确保了所有向右递增的关系满足。
 * - 第二次遍历确保了所有向左递增（即向右递减）的关系满足，并且通过 `Math.max` 保留了第一次遍历已经满足的向右递增关系。
 * - 最终结果同时满足了两个方向的要求。
 *
 * 时间复杂度：O(n)，因为进行了两次线性遍历。
 * 空间复杂度：O(n)，因为需要一个额外的数组 `candies` 来存储每个孩子的糖果数。
 */
class Solution {
    public int candy(int[] ratings) {
        // 两次贪心

        // 创建一个数组用于存储每个孩子分配到的糖果数
        int candies[] = new int[ratings.length];

        // 初始化最终需要的糖果总数
        int sum = 0;

        // 步骤 1: 初始化每个孩子的糖果数为 1，满足第一个条件
        // 使用 Arrays.fill 比之前的 for-each 循环更简洁且正确
        Arrays.fill(candies, 1);

        // 步骤 2: 第一次遍历（从左到右），处理右边评分大于左边的情况
        // 目标：确保 ratings[i] > ratings[i-1] 时，candies[i] > candies[i-1]
        for (int i = 1; i < candies.length; i++) { // 从第二个孩子开始比较
            // 如果当前孩子评分高于左边孩子
            if (ratings[i] > ratings[i - 1]) {
                // 当前孩子的糖果数 = 左边孩子的糖果数 + 1
                candies[i] = candies[i - 1] + 1;
            }
            // 如果 ratings[i] <= ratings[i-1]，则 candies[i] 保持为 1 (或第一次遍历中可能被更新的值)，
            // 暂时不需要增加，后续可能在第二次遍历中被更新。
        }

        // 步骤 3: 第二次遍历（从右到左），处理左边评分大于右边的情况，并修正结果
        // 目标：确保 ratings[i] > ratings[i+1] 时，candies[i] > candies[i+1]
        // 同时要保留第一次遍历的结果 (即如果 ratings[i] > ratings[i-1]，candies[i] 仍需大于 candies[i-1])
        for (int i = candies.length - 2; i >= 0; i--) { // 从倒数第二个孩子开始比较
            // 如果当前孩子评分高于右边孩子
            if (ratings[i] > ratings[i + 1]) {
                // 当前孩子的糖果数需要满足比右边孩子多 1 的条件。
                // 同时，它也需要满足第一次遍历中可能设置的条件（比左边孩子多）。
                // 因此，取两者中的最大值，以同时满足两个方向的要求。
                candies[i] = Math.max(candies[i], candies[i + 1] + 1);
            }
        }

        // 步骤 4: 计算糖果总数
        // 遍历最终的 candies 数组，累加每个孩子的糖果数
        for (int candy : candies) {
            sum += candy;
        }

        // 返回最少需要的糖果总数
        return sum;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 1：`ratings = [1, 0, 2]`**

1.  **初始化：** `candies = [1, 1, 1]`
2.  **第一次遍历 (左到右):**
    *   `i = 1`: `ratings[1] (0) < ratings[0] (1)`。`candies` 不变: `[1, 1, 1]`。
    *   `i = 2`: `ratings[2] (2) > ratings[1] (0)`。`candies[2] = candies[1] + 1 = 1 + 1 = 2`。`candies` 变为: `[1, 1, 2]`。
3.  **第二次遍历 (右到左):**
    *   `i = 1`: `ratings[1] (0) < ratings[2] (2)`。`candies` 不变: `[1, 1, 2]`。
    *   `i = 0`: `ratings[0] (1) > ratings[1] (0)`。`candies[0] = Math.max(candies[0], candies[1] + 1) = Math.max(1, 1 + 1) = Math.max(1, 2) = 2`。`candies` 变为: `[2, 1, 2]`。
4.  **计算总和：** `sum = 2 + 1 + 2 = 5`。
5.  **返回：** `5`。

**示例 2：`ratings = [1, 2, 2]`**

1.  **初始化：** `candies = [1, 1, 1]`
2.  **第一次遍历 (左到右):**
    *   `i = 1`: `ratings[1] (2) > ratings[0] (1)`。`candies[1] = candies[0] + 1 = 1 + 1 = 2`。`candies` 变为: `[1, 2, 1]`。
    *   `i = 2`: `ratings[2] (2) == ratings[1] (2)`。`candies` 不变: `[1, 2, 1]`。
3.  **第二次遍历 (右到左):**
    *   `i = 1`: `ratings[1] (2) == ratings[2] (2)`。`candies` 不变: `[1, 2, 1]`。
    *   `i = 0`: `ratings[0] (1) < ratings[1] (2)`。`candies` 不变: `[1, 2, 1]`。
4.  **计算总和：** `sum = 1 + 2 + 1 = 4`。
5.  **返回：** `4`。

**示例 3 (复杂情况)：`ratings = [1, 3, 4, 5, 2]`**

1.  **初始化：** `candies = [1, 1, 1, 1, 1]`
2.  **第一次遍历 (左到右):**
    *   `i = 1`: `ratings[1](3) > ratings[0](1)` -> `candies[1] = 1 + 1 = 2`。`[1, 2, 1, 1, 1]`
    *   `i = 2`: `ratings[2](4) > ratings[1](3)` -> `candies[2] = 2 + 1 = 3`。`[1, 2, 3, 1, 1]`
    *   `i = 3`: `ratings[3](5) > ratings[2](4)` -> `candies[3] = 3 + 1 = 4`。`[1, 2, 3, 4, 1]`
    *   `i = 4`: `ratings[4](2) < ratings[3](5)` -> 不变。`[1, 2, 3, 4, 1]`
3.  **第二次遍历 (右到左):**
    *   `i = 3`: `ratings[3](5) > ratings[4](2)` -> `candies[3] = Math.max(candies[3], candies[4] + 1) = Math.max(4, 1 + 1) = Math.max(4, 2) = 4`。`[1, 2, 3, 4, 1]`
    *   `i = 2`: `ratings[2](4) < ratings[3](5)` -> 不变。`[1, 2, 3, 4, 1]`
    *   `i = 1`: `ratings[1](3) < ratings[2](4)` -> 不变。`[1, 2, 3, 4, 1]`
    *   `i = 0`: `ratings[0](1) < ratings[1](3)` -> 不变。`[1, 2, 3, 4, 1]`
4.  **计算总和：** `sum = 1 + 2 + 3 + 4 + 1 = 11`。
5.  **返回：** `11`。

这个两次贪心的策略巧妙地分解了问题，通过两次遍历分别处理了左右两个方向的约束，并用 `Math.max` 合并了结果，最终得到了满足所有条件的最少糖果数。

        



---



































## 力扣860. 柠檬水找零
已解答
简单

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

 

示例 1：

输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。

示例 2：

输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
 

提示：

1 <= bills.length <= 10^5
bills[i] 不是 5 就是 10 或是 20 




### 贪心算法，无注释




```java




class Solution {
    public boolean lemonadeChange(int[] bills) {


        int five=0;
        int ten=0;
        int twenty=0;

        for( int bill : bills ) {


            if( bill == 5 ) {

                five++;

            }


            if( bill == 10 ) {

                if( five <= 0 ) {

                    return false;

                }
                else{

                    five--;
                    ten++;
                }

        
            }

            if( bill == 20 ) {


                if( ten > 0 && five > 0 ) {

                    ten--;
                    five--;
                    twenty++;
                }
                else if( five >= 3 ) {

                    five -= 3;
                    twenty++;

                }
                else {

                    return false;
                }


            }

            
        }

        return true;
        
    }
}






```









### 贪心算法，注释版





命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法










          
好的，我们来为你的 LeetCode 860 (柠檬水找零) 题解代码添加详细的注释和说明。

**代码（带详细注释）：**

```java
/**
 * 解题思路总结 (LeetCode 860: 柠檬水找零 - 贪心算法):
 *
 * 目标：判断是否能给所有顾客正确找零。每杯柠檬水 5 美元，顾客可能支付 5、10 或 20 美元。
 *
 * 贪心策略：
 * 核心思想：在找零时，尽可能保留更多的 5 美元钞票，因为 5 美元钞票的通用性最强（可以找 10 美元和 20 美元的零钱），
 * 而 10 美元钞票只能用于找 20 美元的零钱。
 *
 * 步骤：
 * 1.  初始化：维护三个变量 `five`, `ten`, `twenty` 分别记录当前持有的 5 美元、10 美元和 20 美元钞票的数量，初始都为 0。
 * 2.  遍历账单：按顺序处理每一位顾客支付的账单 `bill`。
 * 3.  处理不同面额：
 *     -   如果 `bill == 5`：无需找零，直接将持有的 5 美元数量 `five` 加 1。
 *     -   如果 `bill == 10`：
 *         -   需要找零 5 美元。检查是否持有至少一张 5 美元 (`five > 0`)。
 *         -   如果有，则消耗一张 5 美元 (`five--`)，增加一张 10 美元 (`ten++`)。
 *         -   如果没有足够的 5 美元，则无法找零，返回 `false`。
 *     -   如果 `bill == 20`：
 *         -   需要找零 15 美元。优先使用 10+5 的组合找零（贪心策略：优先用掉 10 美元，保留 5 美元）。
 *         -   检查是否持有至少一张 10 美元和一张 5 美元 (`ten > 0 && five > 0`)。
 *         -   如果有，则消耗一张 10 美元 (`ten--`) 和一张 5 美元 (`five--`)，增加一张 20 美元 (`twenty++`)。
 *         -   如果无法使用 10+5 组合，则尝试使用 5+5+5 的组合找零。
 *         -   检查是否持有至少三张 5 美元 (`five >= 3`)。
 *         -   如果有，则消耗三张 5 美元 (`five -= 3`)，增加一张 20 美元 (`twenty++`)。
 *         -   如果两种组合都无法满足，则无法找零，返回 `false`。
 * 4.  遍历完成：如果所有顾客都能成功找零，则遍历结束后返回 `true`。
 *
 * 关键点：
 * -   处理 20 美元账单时的贪心选择：优先用 `10+5` 而不是 `5+5+5`，是为了保留更多的 5 美元钞票，以应对后续可能出现的 10 美元账单。
 * -   实时检查：每一步都需要检查是否有足够的零钱，一旦不足立即返回 `false`。
 *
 * 时间复杂度：O(n)，其中 n 是顾客数量（bills 数组的长度），因为只需要遍历一次数组。
 * 空间复杂度：O(1)，只需要常数个变量来存储钞票数量。
 */
class Solution {
    public boolean lemonadeChange(int[] bills) {

        // 初始化持有的 5 美元钞票数量
        int five = 0;
        // 初始化持有的 10 美元钞票数量
        int ten = 0;
        // 初始化持有的 20 美元钞票数量 (虽然 20 美元不能用于找零，但可以记录一下)
        int twenty = 0; // 这个变量实际上在逻辑中没有用到，可以省略

        // 遍历每一位顾客支付的账单
        for (int bill : bills) {

            // 情况一：顾客支付 5 美元
            if (bill == 5) {
                // 无需找零，直接增加一张 5 美元
                five++;
            }

            // 情况二：顾客支付 10 美元
            if (bill == 10) {
                // 需要找零 5 美元，检查是否有 5 美元钞票
                if (five <= 0) {
                    // 没有 5 美元找零，返回 false
                    return false;
                } else {
                    // 有 5 美元，消耗一张 5 美元
                    five--;
                    // 增加一张 10 美元
                    ten++;
                }
            }

            // 情况三：顾客支付 20 美元
            if (bill == 20) {
                // 需要找零 15 美元
                // 贪心策略：优先尝试使用 1 张 10 美元 + 1 张 5 美元找零
                if (ten > 0 && five > 0) {
                    // 消耗一张 10 美元和一张 5 美元
                    ten--;
                    five--;
                    // 增加一张 20 美元 (虽然没用，但可以记录)
                    // twenty++; // 这行可以省略
                }
                // 如果无法使用 10+5 组合，则尝试使用 3 张 5 美元找零
                else if (five >= 3) {
                    // 消耗三张 5 美元
                    five -= 3;
                    // 增加一张 20 美元 (虽然没用，但可以记录)
                    // twenty++; // 这行可以省略
                }
                // 如果两种方式都无法找零
                else {
                    // 无法正确找零，返回 false
                    return false;
                }
            }
        }

        // 如果成功处理了所有顾客的账单，说明可以正确找零
        return true;
    }
}
```

**结合示例和代码进行详细讲解说明**

**核心逻辑：** 模拟收银过程，根据收到的钱和手头的零钱判断是否能完成交易。关键在于处理 10 美元和 20 美元的情况，尤其是 20 美元找零时的贪心选择。

**示例 1：`bills = [5, 5, 5, 10, 20]`**

1.  `bill = 5`: `five = 1`, `ten = 0`。
2.  `bill = 5`: `five = 2`, `ten = 0`。
3.  `bill = 5`: `five = 3`, `ten = 0`。
4.  `bill = 10`: 需要找 5 美元。`five > 0` (3 > 0) 满足。`five` 变为 2，`ten` 变为 1。当前持有 `five=2, ten=1`。
5.  `bill = 20`: 需要找 15 美元。
    *   优先尝试 `10+5`：`ten > 0` (1 > 0) 且 `five > 0` (2 > 0) 满足。
    *   消耗 `ten` 和 `five`：`ten` 变为 0，`five` 变为 1。当前持有 `five=1, ten=0`。
6.  遍历结束，所有顾客都成功找零。返回 `true`。

**示例 2：`bills = [5, 5, 10, 10, 20]`**

1.  `bill = 5`: `five = 1`, `ten = 0`。
2.  `bill = 5`: `five = 2`, `ten = 0`。
3.  `bill = 10`: 需要找 5 美元。`five > 0` (2 > 0) 满足。`five` 变为 1，`ten` 变为 1。当前持有 `five=1, ten=1`。
4.  `bill = 10`: 需要找 5 美元。`five > 0` (1 > 0) 满足。`five` 变为 0，`ten` 变为 2。当前持有 `five=0, ten=2`。
5.  `bill = 20`: 需要找 15 美元。
    *   优先尝试 `10+5`：`ten > 0` (2 > 0) 但 `five > 0` (0 > 0) **不满足**。
    *   尝试 `5+5+5`：`five >= 3` (0 >= 3) **不满足**。
    *   两种方式都无法找零。返回 `false`。

**为什么处理 20 美元时优先用 `10+5`？**

考虑 `bills = [5, 5, 10, 20]`

1.  `bill = 5`: `five = 1`
2.  `bill = 5`: `five = 2`
3.  `bill = 10`: `five = 1`, `ten = 1`
4.  `bill = 20`: 需要找 15 美元。
    *   **如果优先用 `10+5` (代码中的策略):** `ten--`, `five--` -> `five = 0`, `ten = 0`。成功。
    *   **如果优先用 `5+5+5` (假设):** `five >= 3` 不满足。无法找零。

再考虑 `bills = [5, 5, 5, 10, 10, 20]`

1.  `bill = 5`: `five = 1`
2.  `bill = 5`: `five = 2`
3.  `bill = 5`: `five = 3`
4.  `bill = 10`: `five = 2`, `ten = 1`
5.  `bill = 10`: `five = 1`, `ten = 2`
6.  `bill = 20`: 需要找 15 美元。
    *   **优先用 `10+5` (代码中的策略):** `ten--`, `five--` -> `five = 0`, `ten = 1`。成功。
    *   **如果优先用 `5+5+5` (假设):** `five >= 3` 不满足。无法找零。

虽然在这个例子中两种策略结果一样，但在某些情况下（如下一个顾客付 10 美元），保留更多的 5 美元是更优的选择。因此，优先消耗掉通用性较差的 10 美元是正确的贪心策略。

        





---

















## 力扣406. 根据身高重建队列
已解答
中等

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

 

示例 1：

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

示例 2：

输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
 

提示：

1 <= people.length <= 2000
0 <= hi <= 10^6
0 <= ki < people.length
题目数据确保队列可以被重建












### 贪心算法，无注释


按照身高从大到小排序后：
局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性，
全局最优：最后都做完插入操作，整个队列满足题目队列属性

```java


class Solution {
    public int[][] reconstructQueue(int[][] people) {
        


        LinkedList<int[]> queue = new LinkedList<>();


        Comparator<int[]> heightComparator = new Comparator<int[]>() {


            @Override
            public int compare( int[] a, int[] b ) {

                if( a[0] == b[0] ) {
                    return a[1] - b[1];
                }
        
                return b[0] - a[0];

            }

        };


        Arrays.sort( people, heightComparator );


        for( int i=0; i < people.length; i++ ) {

            queue.add( people[i][1], people[i] );

            
        }



        return queue.toArray( new int[ people.length][] );

    }
}







```









###  贪心算法，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法









          
好的，我们来为你的 LeetCode 406 (根据身高重建队列) 题解代码添加详细的注释和说明。

**代码（带详细注释）：**

```java
import java.util.Arrays; // 引入 Arrays 类，用于排序
import java.util.Comparator; // 引入 Comparator 接口，用于自定义排序规则
import java.util.LinkedList; // 引入 LinkedList 类，方便在指定位置插入元素

/**
 * 解题思路总结 (LeetCode 406: 根据身高重建队列 - 贪心算法):
 *
 * 目标：根据每个人的身高 (h) 和前面身高大于等于他的人数 (k)，重建原始队列。
 *
 * 贪心策略：
 * 1.  排序：这是贪心策略的核心。我们需要找到一个合适的排序规则，使得我们能够按照这个顺序，
 *     依次将人插入到最终队列的正确位置。
 *     -   主要按身高降序排序：身高较高的人应该先被放置。因为身高较矮的人插入时，不会影响
 *       身高较高的人的 k 值（因为 k 只计算身高大于或等于自己的人）。先放高个子，可以
 *       确定他们的相对位置，矮个子再插入时，只需要考虑在高个子形成的队列中找到自己的位置。
 *     -   次要按 k 值升序排序：当身高相同时，k 值较小的人应该排在前面。因为 k 值表示前面
 *       有多少个不比自己矮的人。如果身高相同，k 小的意味着他在这些相同身高的人中更靠前。
 *       先插入 k 小的，再插入 k 大的，可以保证 k 大的人插入时，前面已经有了 k 个不比他矮的人。
 *     -   综合排序规则：首先按身高 h 降序排列，如果身高 h 相同，则按 k 升序排列。
 *
 * 2.  插入：按照排序后的顺序，依次将每个人插入到一个新的队列（使用 LinkedList 以方便插入操作）中。
 *     -   插入位置：每个人 `people[i] = [h, k]` 应该被插入到新队列的索引 `k` 处。
 *     -   为什么插入到索引 k 处？因为排序保证了当前插入的人 `p` 之前，所有已经插入队列的人
 *       的身高都大于或等于 `p` 的身高。因此，将 `p` 插入到索引 `k` 的位置，就能确保其前面
 *       正好有 `k` 个身高大于或等于他的人。LinkedList 的 `add(index, element)` 方法
 *       会将元素插入到指定索引，并将该索引及之后的所有元素向后移动一位，正好满足我们的需求。
 *
 * 步骤：
 * 1.  定义一个比较器 `Comparator`，实现上述排序规则（身高降序，k 升序）。
 * 2.  使用该比较器对 `people` 数组进行排序。
 * 3.  创建一个 `LinkedList` 作为结果队列。
 * 4.  遍历排序后的 `people` 数组：
 *     -   对于每个人 `person = [h, k]`，将其插入到 `LinkedList` 的索引 `k` 处：`queue.add(k, person)`。
 * 5.  将 `LinkedList` 转换为 `int[][]` 数组并返回。
 *
 * 时间复杂度：O(n^2)，排序需要 O(n log n)，但 `LinkedList` 的插入操作平均需要 O(n)，总共 n 次插入，所以插入部分是 O(n^2)。因此总复杂度是 O(n^2)。
 * 空间复杂度：O(n)，需要一个 `LinkedList` 来存储结果。
 */
class Solution {
    public int[][] reconstructQueue(int[][] people) {

        // 使用 LinkedList 作为结果队列，因为它支持在指定索引处高效插入元素
        // (虽然理论上插入是 O(n)，但在实际场景中比 ArrayList 在中间插入要快)
        LinkedList<int[]> queue = new LinkedList<>();

        // 定义自定义比较器，用于排序 people 数组
        Comparator<int[]> heightComparator = new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                // a = [h1, k1], b = [h2, k2]

                // 如果身高相同 (a[0] == b[0])
                if (a[0] == b[0]) {
                    // 按 k 值升序排序 (k 小的在前)
                    // 返回 a[1] - b[1]:
                    // 如果 a[1] < b[1]，返回负数，a 排在 b 前面
                    // 如果 a[1] == b[1]，返回 0，相对顺序不变
                    // 如果 a[1] > b[1]，返回正数，b 排在 a 前面
                    return a[1] - b[1];
                }

                // 如果身高不同，按身高降序排序 (身高高的在前)
                // 返回 b[0] - a[0]:
                // 如果 b[0] > a[0]，返回正数，b 排在 a 前面
                // 如果 b[0] == a[0]，返回 0 (这种情况上面已处理)
                // 如果 b[0] < a[0]，返回负数，a 排在 b 前面
                return b[0] - a[0];
            }
        };

        // 使用自定义比较器对 people 数组进行排序
        Arrays.sort(people, heightComparator);
        // 排序后 people 数组示例：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]

        // 遍历排序后的 people 数组
        for (int i = 0; i < people.length; i++) {
            // 获取当前这个人 person = [h, k]
            int[] person = people[i];
            // 将这个人插入到 LinkedList 的索引 k (person[1]) 处
            // queue.add(index, element) 会将 element 插入到指定 index，
            // 原 index 及之后的元素会向后移动。
            // 因为我们是按身高降序处理的，所以当前插入时，队列中已有的元素身高都 >= 当前元素，
            // 插入到索引 k 处，正好满足前面有 k 个身高 >= 自己的人的条件。
            queue.add(person[1], person);
        }

        // 将 LinkedList 转换为 int[][] 数组并返回
        // toArray 需要一个指定类型的空数组（或足够大的数组）作为参数，
        // 以确定返回数组的类型和大小。
        return queue.toArray(new int[people.length][]);
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例：`people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`**

1.  **排序：**
    *   根据比较器（身高降序，k 升序）对 `people` 数组进行排序。
    *   排序结果：`[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]`

2.  **插入：**
    *   初始化一个空的 `LinkedList`: `queue = []`
    *   **处理 `[7,0]`:** `k=0`。插入到索引 0。`queue = [[7,0]]`
    *   **处理 `[7,1]`:** `k=1`。插入到索引 1。`queue = [[7,0], [7,1]]`
    *   **处理 `[6,1]`:** `k=1`。插入到索引 1。`queue = [[7,0], [6,1], [7,1]]` (原索引 1 的 `[7,1]` 后移)
    *   **处理 `[5,0]`:** `k=0`。插入到索引 0。`queue = [[5,0], [7,0], [6,1], [7,1]]` (原索引 0, 1, 2 的元素后移)
    *   **处理 `[5,2]`:** `k=2`。插入到索引 2。`queue = [[5,0], [7,0], [5,2], [6,1], [7,1]]` (原索引 2, 3 的元素后移)
    *   **处理 `[4,4]`:** `k=4`。插入到索引 4。`queue = [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]` (原索引 4 的元素后移)

3.  **转换并返回：**
    *   将 `LinkedList` `[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]` 转换为 `int[][]` 数组。
    *   返回结果：`[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]`

这个过程清晰地展示了贪心策略如何通过先排序再按 k 值插入的方式，逐步构建出满足条件的最终队列。每一步插入都保证了当前插入元素的 k 值约束得到满足，并且由于是按身高降序处理，不会破坏之前已插入元素的 k 值约束。

        




























## 力扣452. 用最少数量的箭引爆气球
已解答
中等

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

 
示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。

示例 2：

输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。

示例 3：

输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。
 

提示:

1 <= points.length <= 10^5
points[i].length == 2
-2^31 <= xstart < xend <= 2^31 - 1






### 贪心算法，无注释

局部最优：当气球出现重叠，一起射，所用弓箭最少。
全局最优：把所有气球射爆所用弓箭最少。




```java


class Solution {
    public int findMinArrowShots(int[][] points) {



        if( points.length == 0 ) {

            return 0;
        }

        Arrays.sort( points,
            ( a,b ) -> { return Integer.compare( a[0], b[0] ); }     
        );
        // 使用lambda表达式构造了一个匿名比较器，用于按照气球左边界升序将气球数组排序
        // 使用Integer内置比较方法，不会溢出，比如points = [[-2147483646,-2147483645],[2147483646,2147483647]]

        int sum=1;
        // points 不为空至少需要一支箭


        for( int i=1; i < points.length; i++ ) {

            if( points[i-1][1] >= points[i][0] ) {
                // 前一个气球右边界大于等于后一个气球左边界，即有重叠，不需加箭

                points[i][1] = Math.min( points[i-1][1], points[i][1] );
                // 更新重叠气球最小右边界

            }
            else {
                // 不重叠，需要新加一支箭

                sum++;
            }


        }


        return sum;
        
    }
}





```















### 贪心算法，注释版

局部最优：当气球出现重叠，一起射，所用弓箭最少。
全局最优：把所有气球射爆所用弓箭最少。



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法









          
好的，我们来为你的 LeetCode 452 (用最少数量的箭引爆气球) 题解代码添加详细的注释和说明。

**代码（带详细注释）：**

```java
import java.util.Arrays; // 引入 Arrays 类，用于排序
import java.util.Comparator; // 引入 Comparator 接口，用于自定义排序规则 (虽然这里用了 lambda 表达式)

/**
 * 解题思路总结 (LeetCode 452: 用最少数量的箭引爆气球 - 贪心算法):
 *
 * 目标：找到引爆所有气球所需的最小弓箭数量。一支箭可以引爆所有它穿过的气球。
 *
 * 贪心策略：
 * 1.  排序：为了尽可能让一支箭引爆更多气球，我们需要找到重叠区间。将气球按照区间的起始点（或结束点）排序是常见的贪心思路。
 *     -   按起始点升序排序：这是本解法采用的策略。先按 `x_start` 对气球进行升序排序。
 * 2.  遍历与合并：
 *     -   初始化箭的数量 `sum = 1`（因为只要有气球，至少需要一支箭）。
 *     -   遍历排序后的气球数组，从第二个气球开始 (`i = 1`)。
 *     -   比较当前气球 `points[i]` 的起始点 `points[i][0]` 与前一个“有效”区间的结束点 `points[i-1][1]`。
 *       这里的 `points[i-1][1]` 实际上代表了当前这支箭能够覆盖到的最右边界。
 *     -   如果 `points[i][0] <= points[i-1][1]`：说明当前气球与前一个区间有重叠，可以被同一支箭引爆。
 *       此时，我们需要更新这支箭能覆盖的最右边界。因为箭必须同时穿过这两个（以及之前可能合并的）气球，
 *       所以新的最右边界是这两个气球结束点的较小值 (`points[i][1] = Math.min(points[i-1][1], points[i][1])`)。
 *       这样做是为了尽可能缩小覆盖范围，以便检查后续的气球是否也能被这支箭覆盖。箭的数量 `sum` 不变。
 *     -   如果 `points[i][0] > points[i-1][1]`：说明当前气球与前一个区间没有重叠，无法被同一支箭引爆。
 *       因此，需要一支新的箭来引爆当前气球（以及后续可能与它重叠的气球）。将箭的数量 `sum` 加 1。
 *       此时，当前气球 `points[i]` 成为了新的“有效”区间的代表，其结束点 `points[i][1]` 成为新的最右边界
 *       （虽然代码里没有显式更新给 `points[i-1][1]`，但下一次循环比较时 `points[i][1]` 会作为新的 `points[i-1][1]` 使用）。
 * 3.  返回结果：遍历结束后，`sum` 就是所需的最小弓箭数。
 *
 * 关键点：
 * -   排序是基础。按起始点排序。
 * -   维护当前箭能覆盖的最小右边界。当遇到重叠气球时，更新这个最小右边界。
 * -   当遇到不重叠的气球时，增加箭的数量。
 * -   使用 `Integer.compare` 进行排序可以避免整数溢出问题。
 *
 * 时间复杂度：O(n log n)，主要是排序的开销。遍历是 O(n)。
 * 空间复杂度：O(log n) 或 O(n)，取决于排序算法使用的额外空间。如果原地排序是 O(log n)，否则可能是 O(n)。
 */
class Solution {
    public int findMinArrowShots(int[][] points) {

        // 处理边界情况：如果没有气球，则不需要箭
        if (points.length == 0) {
            return 0;
        }

        // 1. 排序：按照气球的起始坐标 (x_start) 升序排序
        // 使用 lambda 表达式创建一个匿名 Comparator
        // 使用 Integer.compare(a[0], b[0]) 来比较起始坐标，这种方式可以避免直接相减可能导致的整数溢出问题
        // 例如，当 a[0] 是很大的负数，b[0] 是很大的正数时，b[0] - a[0] 可能溢出
        Arrays.sort(points,
            (a, b) -> { return Integer.compare(a[0], b[0]); }
        );
        // 排序后示例：[[1,6], [2,8], [7,12], [10,16]]

        // 2. 遍历与合并
        // 初始化所需弓箭数量为 1，因为至少需要一支箭（除非 points 为空，上面已处理）
        int sum = 1;

        // 从第二个气球开始遍历 (索引 i = 1)
        for (int i = 1; i < points.length; i++) {

            // 检查当前气球 points[i] 的起始点 points[i][0]
            // 是否在前一支箭能覆盖的最右边界 points[i-1][1] 之内或边界上
            // 注意：这里的 points[i-1][1] 在上一步重叠时可能已经被更新为更小的值
            if (points[i][0] <= points[i - 1][1]) {
                // 有重叠：当前气球可以被同一支箭引爆

                // 更新这支箭能覆盖的最右边界
                // 新的右边界必须是当前气球和之前区间的右边界中较小的一个
                // 这样才能保证这支箭能同时穿过所有这些重叠的气球
                points[i][1] = Math.min(points[i - 1][1], points[i][1]);
                // 箭的数量 sum 不变
            } else {
                // 不重叠：当前气球无法被之前的箭引爆

                // 需要一支新的箭
                sum++;
                // 新的箭从当前气球 points[i] 开始覆盖，其右边界自然是 points[i][1]
                // 在下一次循环中，points[i][1] 将作为 points[i-1][1] 被用来比较
            }
        }

        // 返回最终计算出的最小弓箭数
        return sum;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例：`points = [[10,16],[2,8],[1,6],[7,12]]`**

1.  **排序 (按 `x_start` 升序):**
    `[[1,6], [2,8], [7,12], [10,16]]`

2.  **初始化:** `sum = 1`

3.  **遍历:**
    *   `i = 1`: `points[1] = [2,8]`, `points[0] = [1,6]`
        *   比较: `points[1][0] (2)` <= `points[0][1] (6)` ? **是** (重叠)
        *   更新右边界: `points[1][1] = Math.min(points[0][1], points[1][1]) = Math.min(6, 8) = 6`。
        *   现在 `points` 逻辑上像是 `[[1,6], [2,6], [7,12], [10,16]]` (虽然只更新了 `points[1][1]`)。`sum = 1`。
    *   `i = 2`: `points[2] = [7,12]`, `points[1] = [2,6]` (使用更新后的右边界 6)
        *   比较: `points[2][0] (7)` <= `points[1][1] (6)` ? **否** (不重叠)
        *   需要新箭: `sum++` -> `sum = 2`。
        *   新的有效区间由 `[7,12]` 代表。
    *   `i = 3`: `points[3] = [10,16]`, `points[2] = [7,12]`
        *   比较: `points[3][0] (10)` <= `points[2][1] (12)` ? **是** (重叠)
        *   更新右边界: `points[3][1] = Math.min(points[2][1], points[3][1]) = Math.min(12, 16) = 12`。
        *   现在 `points` 逻辑上像是 `[[1,6], [2,6], [7,12], [10,12]]`。`sum = 2`。

4.  **遍历结束。**

5.  **返回:** `sum = 2`。

这个过程说明，第一支箭在 `x=6` 处射出，可以引爆 `[1,6]` 和 `[2,8]` (因为更新后的右边界是 6)。第二支箭在 `x=12` 处（或 10 到 12 之间任意位置）射出，可以引爆 `[7,12]` 和 `[10,16]` (因为更新后的右边界是 12)。总共需要 2 支箭。

        





---









## 力扣435. 无重叠区间
已解答
中等

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

注意 只在一点上接触的区间是 不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。

 

示例 1:

输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:

输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

示例 3:

输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
 

提示:

1 <= intervals.length <= 10^5
intervals[i].length == 2
-5 * 10^4 <= starti < endi <= 5 * 10^4






### 贪心算法，无注释





```java



class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {



        if( intervals.length == 0 ) {

            return 0;
        }

        Arrays.sort( intervals,
            ( a,b ) -> { return Integer.compare( a[0], b[0] ); }     
        );
        // 使用lambda表达式构造了一个匿名比较器，用于按照区间左边界升序将区间数组排序
        // 使用Integer内置比较方法，不会溢出，比如intervals = [[-2147483646,-2147483645],[2147483646,2147483647]]

        int cnt=0;
        // 用于记录重叠区间数量


        for( int i=1; i < intervals.length; i++ ) {

            if( intervals[i-1][1] > intervals[i][0] ) {
                // 前一个区间右边界大于后一个区间左边界，即有重叠，需要给重叠计数器加一
                // 只在一点上接触的区间是不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。

                cnt++;
                // 重叠计数器加一

                intervals[i][1] = Math.min( intervals[i-1][1], intervals[i][1] );
                // 更新重叠区间最小右边界

            }
            else {
                // 不重叠

            }


        }


        return cnt;


        
    }
}



```








### 贪心算法，注释版




命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法











          
好的，我们来为你的 LeetCode 435 (无重叠区间) 题解代码添加详细的注释和说明。

**代码（带详细注释）：**

```java
import java.util.Arrays; // 引入 Arrays 类，用于排序
// import java.util.Comparator; // Comparator 接口通过 lambda 表达式隐式使用

/**
 * 解题思路总结 (LeetCode 435: 无重叠区间 - 贪心算法):
 *
 * 目标：给定一个区间的集合，找到需要移除区间的最小数量，使得剩余区间互不重叠。
 * 这等价于找到最多能保留多少个互不重叠的区间。移除的数量 = 总区间数 - 最大不重叠区间数。
 *
 * 贪心策略：
 * 1.  排序：按区间的起始点升序排序。这是为了方便我们顺序处理区间，判断重叠情况。
 * 2.  遍历与决策：
 *     -   初始化需要移除的区间数量 `cnt = 0`。
 *     -   从第二个区间开始遍历 (`i = 1`)。
 *     -   比较当前区间 `intervals[i]` 的起始点 `intervals[i][0]` 与上一个“有效”区间的结束点 `intervals[i-1][1]`。
 *       注意：这里的 `intervals[i-1][1]` 可能在之前的迭代中被更新过。
 *     -   如果 `intervals[i-1][1] > intervals[i][0]`：说明当前区间与上一个有效区间重叠了。
 *         -   我们需要移除一个区间。将移除计数器 `cnt` 加 1。
 *         -   【贪心选择】在重叠的两个区间（`intervals[i-1]` 和 `intervals[i]`）中，我们应该保留哪个，移除哪个？
 *           为了给后续的区间留下尽可能大的空间（即让区间的结束点尽可能早），我们应该保留结束点更早的那个区间。
 *           因此，我们将当前“有效”区间的结束点更新为两者中较小的那个：`intervals[i][1] = Math.min(intervals[i-1][1], intervals[i][1])`。
 *           这样，在下一次迭代 (`i+1`) 时，比较的就是这个更新后的、更早结束的右边界，增加了后续区间不重叠的可能性。
 *     -   如果 `intervals[i-1][1] <= intervals[i][0]`：说明当前区间与上一个有效区间不重叠（或仅在端点接触）。
 *         -   我们不需要移除区间。
 *         -   当前区间 `intervals[i]` 成为了新的“有效”区间，其结束点 `intervals[i][1]` 将用于下一次比较。
 *           （代码中没有显式更新 `intervals[i-1][1]`，因为下一次循环 `i` 会变成 `i+1`，自然会用 `intervals[i][1]` 作为比较基准）。
 * 3.  返回结果：遍历结束后，`cnt` 就是需要移除的最小区间数量。
 *
 * 关键点：
 * -   按起始点排序是基础。
 * -   遇到重叠时，移除计数加一，并保留结束点更早的区间（通过更新当前区间的结束点实现）。
 * -   使用 `Integer.compare` 进行排序可以避免整数溢出。
 *
 * 时间复杂度：O(n log n)，主要是排序的开销。遍历是 O(n)。
 * 空间复杂度：O(log n) 或 O(n)，取决于排序算法使用的额外空间。
 */
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {

        // 处理边界情况：如果没有区间，则无需移除
        if (intervals.length == 0) {
            return 0;
        }

        // 1. 排序：按照区间的起始坐标 (start_i) 升序排序
        // 使用 lambda 表达式构造了一个匿名比较器
        // 使用 Integer.compare(a[0], b[0]) 来比较起始坐标，避免整数溢出
        Arrays.sort(intervals,
            (a, b) -> { return Integer.compare(a[0], b[0]); }
        );
        // 排序后示例：[[1,2], [1,3], [2,3], [3,4]]

        // 2. 遍历与决策
        // 初始化需要移除的重叠区间数量
        int cnt = 0;

        // 从第二个区间开始遍历 (索引 i = 1)
        for (int i = 1; i < intervals.length; i++) {

            // 检查上一个有效区间的结束点 intervals[i-1][1]
            // 是否大于当前区间的起始点 intervals[i][0]
            // 注意：题目规定端点接触不算重叠，所以用 >
            if (intervals[i - 1][1] > intervals[i][0]) {
                // 发生重叠

                // 需要移除一个区间，移除计数器加一
                cnt++;

                // 【贪心选择】保留结束点更早的区间
                // 将当前区间的结束点更新为两个重叠区间结束点中的较小值
                // 这样在下一次迭代中，比较的是这个更小的右边界，为后续区间留出更多空间
                intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]);

            } else {
                // 不重叠：当前区间 intervals[i] 成为新的有效区间
                // 无需做任何操作，下一次循环会自动使用 intervals[i][1] 作为比较基准
            }
        }

        // 返回最终计算出的需要移除的最小区间数量
        return cnt;
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例：`intervals = [[1,2],[2,3],[3,4],[1,3]]`**

1.  **排序 (按 `start_i` 升序):**
    `[[1,2], [1,3], [2,3], [3,4]]`

2.  **初始化:** `cnt = 0`

3.  **遍历:**
    *   `i = 1`: `intervals[1] = [1,3]`, `intervals[0] = [1,2]`
        *   比较: `intervals[0][1] (2)` > `intervals[1][0] (1)` ? **是** (重叠)
        *   移除计数: `cnt++` -> `cnt = 1`。
        *   更新右边界: `intervals[1][1] = Math.min(intervals[0][1], intervals[1][1]) = Math.min(2, 3) = 2`。
        *   现在 `intervals` 逻辑上像是 `[[1,2], [1,2], [2,3], [3,4]]` (只更新了 `intervals[1][1]`)。
    *   `i = 2`: `intervals[2] = [2,3]`, `intervals[1] = [1,2]` (使用更新后的右边界 2)
        *   比较: `intervals[1][1] (2)` > `intervals[2][0] (2)` ? **否** (端点接触，不重叠)
        *   `cnt` 不变，仍为 1。
        *   `[2,3]` 成为新的有效区间。
    *   `i = 3`: `intervals[3] = [3,4]`, `intervals[2] = [2,3]`
        *   比较: `intervals[2][1] (3)` > `intervals[3][0] (3)` ? **否** (端点接触，不重叠)
        *   `cnt` 不变，仍为 1。
        *   `[3,4]` 成为新的有效区间。

4.  **遍历结束。**

5.  **返回:** `cnt = 1`。

这个过程说明，我们移除了 `[1,3]`（或者说，在 `[1,2]` 和 `[1,3]` 重叠时，我们保留了结束更早的 `[1,2]` 作为有效区间，相当于移除了 `[1,3]` 的影响），最终需要移除 1 个区间。








---








## 力扣763. 划分字母区间
已解答
中等

提示
给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 "ababcc" 能够被分为 ["abab", "cc"]，但类似 ["aba", "bcc"] 或 ["ab", "ab", "cc"] 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

返回一个表示每个字符串片段的长度的列表。

 

示例 1：
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。

示例 2：

输入：s = "eccbbbbdec"
输出：[10]
 

提示：

1 <= s.length <= 500
s 仅由小写英文字母组成









### 用最远出现距离模拟圈字符，无注释

在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。可以分为如下两步：
- 统计每一个字符最后出现的位置
- 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点


```java


class Solution {
    public List<Integer> partitionLabels(String s) {


        int[] lastIndex = new int[27];

        Arrays.fill( lastIndex,0 );

        int left=0;
        int right=0;

        ArrayList<Integer> result = new ArrayList<Integer>();


        for( int i=0; i < s.length(); i++ ) {


            lastIndex[ s.charAt(i) - 'a' ] = i;
            /**根本原因：在 Java 中，String 对象不是字符数组，不能直接使用 [] 运算符来访问字符串中的单个字符。s[i] 这种语法在 Java 中是无效的。
            解决方案：要获取 Java String 在特定索引处的字符，您需要使用 charAt(int index) 方法。 */
            
        }


        for( int i=0; i < s.length(); i++ ) {
            

            right = Math.max( right, lastIndex[ s.charAt(i) - 'a' ] );

            if( i == right ) {

                result.add( right - left + 1 );

                left = i+1;
            }
            
        }


        return result;

        
    }
}




```













### 用最远出现距离模拟圈字符，注释版


命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法











          
好的，我将为您在 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\算法学习记录\数据结构与算法学习记录.md"></mcfile> 文件中的 LeetCode 763 题解代码添加详细的逐行注释和解题思路总结，并结合示例进行讲解。



**解题思路总结:**

本题的目标是将字符串 `s` 划分为尽可能多的片段，同时保证同一个字母只出现在一个片段中。我们可以采用贪心算法来解决这个问题。核心思想是：遍历字符串，对于遇到的每个字符，找到它在字符串中最后一次出现的位置。这个最后一次出现的位置定义了当前片段必须延伸到的最远边界。当我们遍历到某个索引 `i` 时，如果这个索引 `i` 恰好等于当前片段内所有字符所能到达的最远边界 `right`，那么就意味着从上一个分割点到当前索引 `i` 的子字符串构成了一个有效的片段。因为这个片段包含了所有它内部字符的最后一次出现，后续的字符不会再与这个片段内的字符产生关联。

**算法步骤:**

1.  **统计最后出现位置:** 第一次遍历字符串 `s`，使用一个数组 `lastIndex` (大小为 26，对应 'a' 到 'z') 记录每个小写字母在 `s` 中最后一次出现的索引。
2.  **遍历与划分:** 第二次遍历字符串 `s`，使用两个指针 `left` 和 `right`。
    *   `left` 记录当前片段的起始位置（初始为 0）。
    *   `right` 记录当前遍历过程中遇到的所有字符的最远出现位置（初始为 0）。
    *   在遍历过程中（索引为 `i`），对于当前字符 `s.charAt(i)`，更新 `right = Math.max(right, lastIndex[s.charAt(i) - 'a'])`。这确保了 `right` 始终指向当前片段必须延伸到的最远边界。
    *   **判断分割点:** 如果当前索引 `i` 等于 `right`，说明我们找到了一个片段的结束点。因为索引 `i` 已经到达了从 `left` 到 `i` 范围内所有字符的最远出现位置，后续的字符不可能再属于这个片段了。
    *   **记录片段长度:** 将片段的长度 `right - left + 1` 添加到结果列表 `result` 中。
    *   **更新起始点:** 将下一个片段的起始位置 `left` 更新为 `i + 1`。
3.  **返回结果:** 遍历结束后，返回包含所有片段长度的列表 `result`。





```java
import java.util.ArrayList; // 导入 ArrayList 类，用于存储结果列表
import java.util.Arrays;    // 导入 Arrays 类，用于数组操作 (虽然本代码未使用 Arrays 的方法，但保留导入以备将来可能的使用)
import java.util.List;      // 导入 List 接口

/**
 * LeetCode 763. 划分字母区间
 *
 * 解题思路：
 * 1. 统计每个字符最后出现的位置。
 * 2. 遍历字符串，维护当前片段需要到达的最远边界 right。
 * 3. 当遍历的索引 i 等于 right 时，说明找到了一个片段的分割点。
 * 4. 记录片段长度 (right - left + 1)，并更新下一个片段的起始点 left。
 */
class Solution {
    /**
     * 将字符串 s 划分为尽可能多的片段，使得同一个字母只出现在一个片段中，并返回每个片段的长度列表。
     * @param s 输入的字符串，仅由小写英文字母组成。
     * @return 一个包含每个片段长度的整数列表。
     */
    public List<Integer> partitionLabels(String s) {

        // 创建一个大小为 26 的数组 (因为 s 仅由小写英文字母组成)，用于存储每个字母最后一次出现的索引。
        // 索引 0 对应 'a', 1 对应 'b', ..., 25 对应 'z'。
        int[] lastIndex = new int[26]; // 注意：数组大小为 26 即可，27 会浪费一个空间

        // 第一次遍历：统计每个字符最后出现的位置
        // 遍历字符串 s 中的每个字符
        for (int i = 0; i < s.length(); i++) {
            // 获取当前字符 s.charAt(i)
            // 计算该字符在 lastIndex 数组中对应的索引 (例如 'a' -> 0, 'b' -> 1)
            // 将当前字符的索引 i 存储到 lastIndex 数组的相应位置。
            // 如果一个字符出现多次，这里会不断更新，最终存储的是它最后一次出现的索引。
            lastIndex[s.charAt(i) - 'a'] = i;
        }

        // 初始化结果列表，用于存储每个片段的长度
        ArrayList<Integer> result = new ArrayList<>();
        // 初始化左边界指针 left，表示当前片段的起始索引
        int left = 0;
        // 初始化右边界指针 right，表示当前片段必须延伸到的最远索引
        int right = 0;

        // 第二次遍历：查找分割点并记录片段长度
        // 再次遍历字符串 s 中的每个字符
        for (int i = 0; i < s.length(); i++) {
            // 对于当前字符 s.charAt(i)，查找它最后一次出现的索引 lastIndex[s.charAt(i) - 'a']
            // 更新 right 为 当前 right 和 当前字符最后出现位置 中的较大值。
            // 这确保了 right 始终指向当前片段（从 left 到 i）中所有字符的最远出现位置。
            right = Math.max(right, lastIndex[s.charAt(i) - 'a']);

            // 判断是否到达分割点
            // 如果当前遍历的索引 i 等于 right，说明：
            // 1. 从 left 到 i 的这个子字符串包含了它内部所有字符的最后一次出现。
            // 2. 索引 i 是这个片段的终点。
            // 3. 后续的字符 (i+1 开始) 不可能再属于这个片段了。
            if (i == right) {
                // 计算当前片段的长度：right - left + 1
                // 将片段长度添加到结果列表 result 中
                result.add(right - left + 1);
                // 更新下一个片段的起始位置 left 为当前索引 i 的下一个位置
                left = i + 1;
            }
        }

        // 返回包含所有片段长度的结果列表
        return result;
    }
}
```

**结合示例 `s = "ababcbacadefegdehijhklij"` 进行讲解:**

1.  **统计最后出现位置 (`lastIndex` 数组):**
    *   'a': 8
    *   'b': 5
    *   'c': 7
    *   'd': 14
    *   'e': 15
    *   'f': 11
    *   'g': 13
    *   'h': 19
    *   'i': 22
    *   'j': 23
    *   'k': 20
    *   'l': 21
    *   (其他字母未出现，索引为 0 或未初始化时的默认值)

2.  **遍历与划分:**
    *   `i = 0`, `s[0] = 'a'`. `right = max(0, lastIndex['a']) = max(0, 8) = 8`. `i != right`.
    *   `i = 1`, `s[1] = 'b'`. `right = max(8, lastIndex['b']) = max(8, 5) = 8`. `i != right`.
    *   `i = 2`, `s[2] = 'a'`. `right = max(8, lastIndex['a']) = max(8, 8) = 8`. `i != right`.
    *   `i = 3`, `s[3] = 'b'`. `right = max(8, lastIndex['b']) = max(8, 5) = 8`. `i != right`.
    *   `i = 4`, `s[4] = 'c'`. `right = max(8, lastIndex['c']) = max(8, 7) = 8`. `i != right`.
    *   `i = 5`, `s[5] = 'b'`. `right = max(8, lastIndex['b']) = max(8, 5) = 8`. `i != right`.
    *   `i = 6`, `s[6] = 'a'`. `right = max(8, lastIndex['a']) = max(8, 8) = 8`. `i != right`.
    *   `i = 7`, `s[7] = 'c'`. `right = max(8, lastIndex['c']) = max(8, 7) = 8`. `i != right`.
    *   `i = 8`, `s[8] = 'a'`. `right = max(8, lastIndex['a']) = max(8, 8) = 8`. **`i == right` (8 == 8)**.
        *   找到第一个分割点。片段为 `s[0...8]` ("ababcbaca")。
        *   记录片段长度：`result.add(right - left + 1) = result.add(8 - 0 + 1) = result.add(9)`. `result = [9]`.
        *   更新 `left = i + 1 = 8 + 1 = 9`.
    *   `i = 9`, `s[9] = 'd'`. `right = max(8, lastIndex['d']) = max(8, 14) = 14`. `i != right`. (注意：虽然 `i` 变了，但 `right` 是基于 `lastIndex` 更新的，与之前的 `right` 无关，只看当前字符和之前的最大值)
    *   `i = 10`, `s[10] = 'e'`. `right = max(14, lastIndex['e']) = max(14, 15) = 15`. `i != right`.
    *   `i = 11`, `s[11] = 'f'`. `right = max(15, lastIndex['f']) = max(15, 11) = 15`. `i != right`.
    *   `i = 12`, `s[12] = 'e'`. `right = max(15, lastIndex['e']) = max(15, 15) = 15`. `i != right`.
    *   `i = 13`, `s[13] = 'g'`. `right = max(15, lastIndex['g']) = max(15, 13) = 15`. `i != right`.
    *   `i = 14`, `s[14] = 'd'`. `right = max(15, lastIndex['d']) = max(15, 14) = 15`. `i != right`.
    *   `i = 15`, `s[15] = 'e'`. `right = max(15, lastIndex['e']) = max(15, 15) = 15`. **`i == right` (15 == 15)**.
        *   找到第二个分割点。片段为 `s[9...15]` ("defegde")。
        *   记录片段长度：`result.add(right - left + 1) = result.add(15 - 9 + 1) = result.add(7)`. `result = [9, 7]`.
        *   更新 `left = i + 1 = 15 + 1 = 16`.
    *   `i = 16`, `s[16] = 'h'`. `right = max(15, lastIndex['h']) = max(15, 19) = 19`. `i != right`.
    *   `i = 17`, `s[17] = 'i'`. `right = max(19, lastIndex['i']) = max(19, 22) = 22`. `i != right`.
    *   `i = 18`, `s[18] = 'j'`. `right = max(22, lastIndex['j']) = max(22, 23) = 23`. `i != right`.
    *   `i = 19`, `s[19] = 'h'`. `right = max(23, lastIndex['h']) = max(23, 19) = 23`. `i != right`.
    *   `i = 20`, `s[20] = 'k'`. `right = max(23, lastIndex['k']) = max(23, 20) = 23`. `i != right`.
    *   `i = 21`, `s[21] = 'l'`. `right = max(23, lastIndex['l']) = max(23, 21) = 23`. `i != right`.
    *   `i = 22`, `s[22] = 'i'`. `right = max(23, lastIndex['i']) = max(23, 22) = 23`. `i != right`.
    *   `i = 23`, `s[23] = 'j'`. `right = max(23, lastIndex['j']) = max(23, 23) = 23`. **`i == right` (23 == 23)**.
        *   找到第三个分割点。片段为 `s[16...23]` ("hijhklij")。
        *   记录片段长度：`result.add(right - left + 1) = result.add(23 - 16 + 1) = result.add(8)`. `result = [9, 7, 8]`.
        *   更新 `left = i + 1 = 23 + 1 = 24`.
    *   遍历结束。

3.  **返回结果:** `[9, 7, 8]`。









---



























## 力扣56. 合并区间
已解答
中等

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
 

提示：

1 <= intervals.length <= 10^4

intervals[i].length == 2

0 <= starti <= endi <= 10^4









### 贪心算法，重叠区间问题，无注释




```java




class Solution {
    public int[][] merge(int[][] intervals) {

        if (intervals == null || intervals.length <= 1) {
            // 处理输入为空或只有一个区间的情况
            return intervals;
        }


        LinkedList<int[]> result = new LinkedList<int[]>(); 
        // 使用 LinkedList 来存储合并后的区间
        // LinkedList 方便在末尾添加和获取/修改最后一个元素
        // LinkedList<LinkedList<int>> 类型错误： int 是基本数据类型，不能直接作为泛型参数。您应该使用包装类 Integer 或者更常见的是使用 int[] 来表示一个区间。由于您处理的是 int[] 类型的区间，所以 result 应该声明为 LinkedList<int[]>。

        Arrays.sort( intervals, ( a,b ) -> { return Integer.compare( a[0],b[0] ); }  );
        // 对区间按照起始位置进行排序
        // 使用 Lambda 表达式作为 Comparator，比较两个区间数组 a 和 b 的第一个元素 (起始位置)


        result.add( intervals[0] );


        for( int i=1; i < intervals.length; i++ ) {
            // 遍历排序后的区间

            if( intervals[i][0] <= result.getLast()[1] ) {


                result.getLast()[1] = Math.max( result.getLast()[1], intervals[i][1] );
                // 合并逻辑错误： 在合并重叠区间时，您应该比较当前区间 intervals[i] 的起始位置与 result 中 最后一个已合并区间 的结束位置，而不是与 intervals[i-1] 的结束位置比较。并且更新时，应该更新 result 中最后一个区间的结束位置，而不是创建一个新的区间并替换。
                // Java 中创建数组的语法错误： 在 Java 中，您不能使用 [ element1, element2, ... ] 这种语法来创建一个数组字面量。这种语法在 JavaScript 或 Python 中是有效的，但在 Java 中是无效的。要创建一个新的 int 数组，您需要使用 new int[]{ element1, element2, ... }。

            }
            else {

                result.add( intervals[i] );

            }


        }


        return result.toArray(new int[0][]);
        // 将 LinkedList 转换为 int[][] 数组并返回
        // toArray(T[] a) 方法可以将集合转换为指定类型的数组
        // new int[0][] 创建一个长度为 0 的 int[][] 数组，作为 toArray 方法的参数，
        // 这样 toArray 方法会创建一个新的、大小合适的 int[][] 数组来存储 merged 中的元素

        
    }
}



```









### 贪心算法，重叠区间问题，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法












          
好的，我们来为 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\算法学习记录\数据结构与算法学习记录.md"></mcfile> 文件中 LeetCode 56 "合并区间" 的 Java 代码添加详细的逐行注释、解题思路总结，并结合示例进行讲解。



**解题思路总结:**

本题要求合并所有重叠的区间。我们可以采用贪心算法来解决。核心思想是：

1.  **排序:** 首先将所有区间按照起始位置升序排序。这使得我们可以按顺序处理区间，并且保证当我们考虑一个区间时，所有起始位置比它早的区间都已经被处理过了。
2.  **合并:** 维护一个结果列表 `result`，用于存储合并后的不重叠区间。
    *   将第一个排序后的区间加入 `result`。
    *   遍历剩余的已排序区间：
        *   获取 `result` 中的最后一个区间（即当前已合并的最大区间）`lastMerged`。
        *   获取当前正在遍历的区间 `currentInterval`。
        *   **判断重叠:** 如果 `currentInterval` 的起始位置小于等于 `lastMerged` 的结束位置 (`currentInterval.start <= lastMerged.end`)，说明它们重叠。
        *   **执行合并:** 如果重叠，更新 `lastMerged` 的结束位置为 `max(lastMerged.end, currentInterval.end)`。这样就将 `currentInterval` 合并到了 `lastMerged` 中。
        *   **不重叠:** 如果 `currentInterval` 的起始位置大于 `lastMerged` 的结束位置，说明它们不重叠，`currentInterval` 是一个新的不重叠区间的开始。将 `currentInterval` 加入 `result` 列表。
3.  **返回结果:** 遍历结束后，`result` 列表中存储的就是所有合并后的不重叠区间。将其转换为题目要求的二维数组格式返回。




```java
import java.util.Arrays;      // 导入 Arrays 类，用于数组排序
import java.util.LinkedList; // 导入 LinkedList 类，用于存储合并后的区间

/**
 * LeetCode 56. 合并区间
 *
 * 解题思路：
 * 1. 将区间按起始位置升序排序。
 * 2. 初始化结果列表，并将第一个区间加入。
 * 3. 遍历排序后的区间：
 *    a. 如果当前区间与结果列表最后一个区间重叠，则合并（更新最后一个区间的结束位置）。
 *    b. 如果不重叠，则将当前区间直接加入结果列表。
 * 4. 将结果列表转换为二维数组返回。
 */
class Solution {
    /**
     * 合并所有重叠的区间。
     * @param intervals 一个包含若干区间的二维数组，intervals[i] = [start_i, end_i]。
     * @return 一个不重叠的区间数组，覆盖输入中的所有区间。
     */
    public int[][] merge(int[][] intervals) {

        // 边界情况处理：如果输入为空或只有一个区间，无需合并，直接返回
        if (intervals == null || intervals.length <= 1) {
            return intervals;
        }

        // 1. 排序：按照区间的起始位置 (intervals[i][0]) 升序排序
        // 使用 Lambda 表达式定义比较器：比较两个区间 a 和 b 的第一个元素 a[0] 和 b[0]
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        // 或者使用匿名内部类：
        // Arrays.sort(intervals, new Comparator<int[]>() {
        //     @Override
        //     public int compare(int[] a, int[] b) {
        //         return Integer.compare(a[0], b[0]);
        //     }
        // });

        // 2. 初始化结果列表：使用 LinkedList 存储合并后的区间
        // LinkedList 提供了方便的 getLast() 方法来访问和修改最后一个元素
        LinkedList<int[]> result = new LinkedList<>();
        // 将排序后的第一个区间作为初始合并区间加入结果列表
        result.add(intervals[0]);

        // 3. 遍历与合并：从第二个区间开始遍历排序后的区间
        for (int i = 1; i < intervals.length; i++) {
            // 获取当前正在处理的区间
            int[] currentInterval = intervals[i];
            // 获取结果列表中最后一个已合并的区间
            int[] lastMerged = result.getLast();

            // 判断是否重叠：当前区间的起始位置 <= 最后一个合并区间的结束位置
            if (currentInterval[0] <= lastMerged[1]) {
                // 重叠，需要合并：更新最后一个合并区间的结束位置
                // 新的结束位置取 原结束位置 和 当前区间结束位置 中的较大值
                // 例如：lastMerged=[1,3], currentInterval=[2,6] -> 合并后 lastMerged 变为 [1,6]
                // 例如：lastMerged=[1,6], currentInterval=[2,4] -> 合并后 lastMerged 仍为 [1,6]
                lastMerged[1] = Math.max(lastMerged[1], currentInterval[1]);
                // 注意：这里是直接修改 result 列表中最后一个数组元素的值，因为数组是引用类型
            } else {
                // 不重叠：当前区间与最后一个合并区间没有交集
                // 将当前区间作为一个新的独立区间添加到结果列表中
                result.add(currentInterval);
            }
        }

        // 4. 返回结果：将 LinkedList 转换为 int[][] 数组
        // toArray 方法需要一个指定类型的数组作为参数，用于确定返回数组的类型
        // new int[result.size()][2] 创建了一个正确大小的二维数组
        // 如果传入 new int[0][]，toArray 内部也会自动创建合适大小的数组
        return result.toArray(new int[result.size()][]);
        // return result.toArray(new int[0][]); // 这种写法也可以
    }
}
```

**结合示例 `intervals = [[1,3],[2,6],[8,10],[15,18]]` 进行讲解:**

1.  **排序:**
    *   输入: `[[1,3],[2,6],[8,10],[15,18]]`
    *   按起始位置排序后: `[[1,3],[2,6],[8,10],[15,18]]` (在这个例子中，输入已经是排序好的)

2.  **初始化:**
    *   `result = new LinkedList<>()`
    *   将第一个区间 `[1,3]` 加入 `result`。 `result = [[1,3]]`

3.  **遍历与合并:**
    *   **i = 1:** `currentInterval = [2,6]`. `lastMerged = result.getLast() = [1,3]`.
        *   判断重叠: `currentInterval[0] (2) <= lastMerged[1] (3)` 为 `true`。
        *   合并: `lastMerged[1] = Math.max(lastMerged[1] (3), currentInterval[1] (6)) = 6`.
        *   `result` 中最后一个元素被修改为 `[1,6]`. `result = [[1,6]]`.
    *   **i = 2:** `currentInterval = [8,10]`. `lastMerged = result.getLast() = [1,6]`.
        *   判断重叠: `currentInterval[0] (8) <= lastMerged[1] (6)` 为 `false`。
        *   不重叠: 将 `currentInterval [8,10]` 加入 `result`.
        *   `result = [[1,6], [8,10]]`.
    *   **i = 3:** `currentInterval = [15,18]`. `lastMerged = result.getLast() = [8,10]`.
        *   判断重叠: `currentInterval[0] (15) <= lastMerged[1] (10)` 为 `false`。
        *   不重叠: 将 `currentInterval [15,18]` 加入 `result`.
        *   `result = [[1,6], [8,10], [15,18]]`.

4.  **返回结果:**
    *   将 `result` 转换为二维数组。
    *   返回 `[[1,6], [8,10], [15,18]]`。





---
        











## java中如何把一个int转换为String？




在 Java 中，将一个 `int` 基本数据类型转换为 `String` 对象有几种常用的方法。以下是其中几种：

1.  **使用 `String.valueOf(int i)` 方法 (推荐)**
    这是 `String` 类提供的一个静态方法，专门用于将各种基本数据类型和对象转换为字符串表示。它通常是首选方法，因为它清晰且能处理各种类型。

    ```java
    int number = 123;
    String str = String.valueOf(number);
    System.out.println(str); // 输出: "123"
    ```

2.  **使用 `Integer.toString(int i)` 方法**
    这是 `Integer` 包装类提供的一个静态方法，功能与 `String.valueOf(int)` 类似，实际上 `String.valueOf(int)` 内部就是调用了 `Integer.toString(int)`。同样是标准且推荐的方法。

    ```java
    int number = 456;
    String str = Integer.toString(number);
    System.out.println(str); // 输出: "456"
    ```

3.  **使用字符串连接符 `+`**
    当一个字符串与一个基本数据类型（或其他对象）使用 `+` 连接时，基本数据类型会自动转换为字符串。这是一种非常简洁的方式，尤其是在需要将数字嵌入到其他字符串中时。

    ```java
    int number = 789;
    String str = "" + number; // 将空字符串与 int 相加
    System.out.println(str); // 输出: "789"

    // 也可以直接用于拼接
    String message = "The number is: " + number;
    System.out.println(message); // 输出: "The number is: 789"
    ```
    这种方法虽然简洁，但不如前两种方法直观地表达“转换为字符串”的意图。在性能上，现代 Java 编译器通常会优化这种操作，使其效率接近 `valueOf` 或 `toString`。

4.  **使用 `String.format()` 方法**
    这个方法提供了更灵活的格式化能力，类似于 C 语言的 `printf`。对于简单的 `int` 转 `String`，它显得有些“重”，但如果需要特定的格式（如填充零、指定宽度等），它就很有用。

    ```java
    int number = 10;
    String str = String.format("%d", number); // %d 用于格式化整数
    System.out.println(str); // 输出: "10"

    // 示例：格式化为至少3位，不足前面补零
    String paddedStr = String.format("%03d", number);
    System.out.println(paddedStr); // 输出: "010"
    ```

**总结：**

*   对于简单的 `int` 到 `String` 转换，**`String.valueOf(number)`** 或 **`Integer.toString(number)`** 是最清晰和推荐的方法。
*   使用 **`"" + number`** 也很常见且简洁，尤其适合与其他字符串拼接的场景。
*   **`String.format()`** 适用于需要复杂格式化的情况。

选择哪种方法取决于你的具体需求和个人偏好，但在大多数情况下，使用 `String.valueOf()` 或 `Integer.toString()` 是一个好的实践。






## java中如何把一个String转换为int？




在 Java 中，将一个 `String` 对象转换为 `int` 基本数据类型，最常用的方法是使用 `Integer` 包装类的静态方法 `parseInt()`。

以下是具体的方法和需要注意的地方：

1.  **使用 `Integer.parseInt(String s)` 方法 (推荐)**
    这是将字符串解析为整数的标准方法。它尝试将字符串解释为一个有符号的十进制整数。

    ```java
    String str = "123";
    try {
        // 使用 Integer.parseInt() 方法将字符串转换为 int
        int number = Integer.parseInt(str);
        System.out.println("转换成功，int 值为: " + number); // 输出: 转换成功，int 值为: 123

        String anotherStr = "-45";
        int anotherNumber = Integer.parseInt(anotherStr);
        System.out.println("转换成功，int 值为: " + anotherNumber); // 输出: 转换成功，int 值为: -45

    } catch (NumberFormatException e) {
        // 如果字符串不能被解析为有效的整数，会抛出 NumberFormatException
        System.err.println("转换失败: 字符串格式不正确");
        e.printStackTrace(); // 打印异常堆栈信息，帮助调试
    }
    ```

    **重要注意事项：**
    *   `parseInt()` 方法要求字符串必须是表示一个整数的有效格式。它不能包含非数字字符（除了开头的负号 `-`）。
    *   如果字符串为 `null` 或空字符串 `""`，或者包含非数字字符，或者表示的数字超出了 `int` 类型的范围（-2,147,483,648 到 2,147,483,647），`parseInt()` 方法会抛出 `NumberFormatException` 运行时异常。
    *   因此，在使用 `parseInt()` 时，**强烈建议** 使用 `try-catch` 块来捕获 `NumberFormatException`，以防止程序崩溃。

2.  **使用 `Integer.valueOf(String s)` 方法**
    这个方法与 `parseInt()` 类似，但它返回的是一个 `Integer` **对象**，而不是 `int` 基本数据类型。然而，由于 Java 的自动拆箱 (autoboxing) 特性，你可以将 `Integer` 对象直接赋值给 `int` 变量。

    ```java
    String str = "789";
    try {
        // 使用 Integer.valueOf() 方法将字符串转换为 Integer 对象
        Integer integerObject = Integer.valueOf(str);
        // 由于自动拆箱，可以直接赋值给 int 变量
        int number = integerObject;
        System.out.println("转换成功，int 值为: " + number); // 输出: 转换成功，int 值为: 789

    } catch (NumberFormatException e) {
        // 同样，如果字符串格式不正确，会抛出 NumberFormatException
        System.err.println("转换失败: 字符串格式不正确");
        e.printStackTrace();
    }
    ```
    **注意：** `Integer.valueOf()` 同样会抛出 `NumberFormatException`，所以也需要进行异常处理。在大多数情况下，`parseInt()` 更直接，因为它直接返回基本类型 `int`。

**总结：**

将 `String` 转换为 `int` 的首选方法是使用 `Integer.parseInt(String s)`。务必使用 `try-catch` 块来处理可能发生的 `NumberFormatException`，以确保程序的健壮性。







## 极尽详细全面地讲解Java中String的使用




好的，我们来极尽详细和全面地讲解 Java 中的 `String` 类及其使用。

`String` 是 Java 中使用最频繁的类之一，它代表了 **不可变的字符序列**。理解 `String` 的特性和用法对于 Java 开发至关重要。

### 1. `String` 的本质：不可变的字符序列

*   **定义：** `java.lang.String` 类用于表示字符串。字符串是一系列字符的集合。
*   **不可变性 (Immutability)：** 这是 `String` 最核心的特性。一旦一个 `String` 对象被创建，它的内容（字符序列）就不能被改变。
    *   这意味着所有看起来会修改字符串的方法（如 `concat()`, `replace()`, `substring()` 等）实际上都不会修改原字符串，而是会创建一个 **新的** `String` 对象来存储修改后的结果。
    *   原字符串对象保持不变。
*   **为什么设计成不可变？**
    *   **安全性：** 字符串经常被用作方法参数（如文件名、网络连接地址、数据库查询语句等）。如果字符串是可变的，那么在方法执行过程中，字符串的内容可能会被意外修改，导致安全漏洞。不可变性保证了字符串在传递和使用过程中的内容一致性。
    *   **线程安全：** 不可变对象在多线程环境中是自动线程安全的，因为它们的状态不会改变，无需额外的同步措施。多个线程可以安全地共享同一个 `String` 对象。
    *   **性能优化 (String Pool)：** 不可变性使得 Java 可以实现字符串常量池 (String Pool)，从而节省内存。
    *   **哈希码缓存：** `String` 对象的哈希码 (hash code) 在第一次计算后会被缓存起来。由于字符串是不可变的，其哈希码也不会改变，所以后续获取哈希码时可以直接返回缓存的值，提高了性能（尤其是在 `HashMap` 或 `HashSet` 中作为键使用时）。

### 2. `String` 对象的创建

创建 `String` 对象主要有两种方式：

*   **使用字符串字面量 (String Literal)：**
    ```java
    String s1 = "hello";
    String s2 = "hello";
    ```
    这是最常用和推荐的方式。当使用字符串字面量创建 `String` 对象时，Java 虚拟机会在 **字符串常量池 (String Pool)** 中查找是否已经存在内容相同的字符串。
    *   如果存在，则直接返回该字符串对象的引用。
    *   如果不存在，则在常量池中创建一个新的 `String` 对象，并将该对象的引用返回。
    因此，在上面的例子中，`s1` 和 `s2` 实际上引用的是常量池中的同一个 `String` 对象。

*   **使用 `new` 关键字：**
    ```java
    String s3 = new String("world");
    String s4 = new String("world");
    String s5 = new String("hello"); // 内容与 s1/s2 相同
    ```
    使用 `new` 关键字创建 `String` 对象时，**总会** 在堆内存中创建一个新的 `String` 对象。
    *   即使字符串字面量 `"world"` 或 `"hello"` 已经在常量池中存在，`new String(...)` 也会在堆上创建一个新的对象。
    *   在 `new String("world")` 的情况下，实际上可能创建了两个对象：一个在常量池中（如果之前不存在），一个在堆中。
    因此，`s3` 和 `s4` 引用的是堆中两个不同的 `String` 对象，尽管它们的内容相同。`s5` 引用的是堆中的一个新对象，它与 `s1` 和 `s2` 引用的常量池中的对象是不同的。

*   **从字符数组创建：**
    ```java
    char[] chars = {'J', 'a', 'v', 'a'};
    String s6 = new String(chars); // s6 的内容是 "Java"
    String s7 = new String(chars, 1, 2); // 从索引 1 开始，取 2 个字符，s7 的内容是 "av"
    ```

*   **从字节数组创建：**
    ```java
    byte[] bytes = {72, 101, 108, 108, 111}; // ASCII for "Hello"
    String s8 = new String(bytes); // 使用平台默认编码，可能不是 UTF-8
    String s9 = new String(bytes, java.nio.charset.StandardCharsets.UTF_8); // 指定编码，推荐
    ```
    从字节数组创建字符串时，指定字符编码非常重要，以避免乱码问题。

### 3. 字符串常量池 (String Pool)

*   **位置：** 在 Java 7 之前，字符串常量池位于方法区 (Method Area) 的永久代 (PermGen)。从 Java 7 开始，字符串常量池被移到了堆 (Heap) 中。
*   **作用：** 存储唯一的字符串字面量。当创建字符串字面量时，JVM 会先检查常量池，如果存在相同内容的字符串，则直接复用，避免创建重复对象，从而节省内存。
*   **`intern()` 方法：** `String` 类提供了一个 `intern()` 方法。
    *   调用 `s.intern()` 会检查字符串 `s` 的内容是否已经在常量池中存在。
    *   如果存在，则返回常量池中该字符串的引用。
    *   如果不存在，则将 `s` 对象添加到常量池中，并返回 `s` 对象的引用。
    *   这个方法可以用来强制将堆中的 `String` 对象添加到常量池中，或者获取常量池中对应字符串的引用。

    ```java
    String s1 = "hello"; // "hello" 在常量池
    String s2 = new String("hello"); // s2 在堆，"hello" 字面量可能也在常量池

    System.out.println(s1 == s2); // false (引用不同)

    String s3 = s2.intern(); // s3 获取常量池中 "hello" 的引用

    System.out.println(s1 == s3); // true (引用相同)
    ```

### 4. `String` 的常用方法

`String` 类提供了大量用于操作字符串的方法。由于 `String` 是不可变的，这些方法都不会修改原字符串，而是返回一个新的 `String` 对象（或基本类型、数组等）。

*   **获取信息：**
    *   `length()`: 返回字符串的长度（字符数）。
    *   `isEmpty()`: 判断字符串是否为空（长度为 0）。
    *   `isBlank()` (Java 11+): 判断字符串是否为空或只包含空白字符。
    *   `charAt(int index)`: 返回指定索引处的字符。索引从 0 开始。
    *   `indexOf(int ch)` / `indexOf(String str)`: 返回指定字符或子字符串第一次出现的索引。
    *   `lastIndexOf(int ch)` / `lastIndexOf(String str)`: 返回指定字符或子字符串最后一次出现的索引。
    *   `contains(CharSequence s)`: 判断字符串是否包含指定的字符序列。

*   **截取子字符串：**
    *   `substring(int beginIndex)`: 从指定索引开始截取到字符串末尾。
    *   `substring(int beginIndex, int endIndex)`: 从 `beginIndex` 开始截取到 `endIndex - 1` 处。

*   **连接字符串：**
    *   `concat(String str)`: 将指定字符串连接到原字符串的末尾。
    *   使用 `+` 运算符：这是最常见的方式。例如 `str1 + str2`。在循环中进行大量字符串拼接时，应优先考虑 `StringBuilder` 或 `StringBuffer` 以提高效率。

*   **替换：**
    *   `replace(char oldChar, char newChar)`: 将所有出现的 `oldChar` 替换为 `newChar`。
    *   `replace(CharSequence target, CharSequence replacement)`: 将所有出现的 `target` 字符序列替换为 `replacement`。
    *   `replaceAll(String regex, String replacement)`: 使用正则表达式进行替换所有匹配项。
    *   `replaceFirst(String regex, String replacement)`: 使用正则表达式进行替换第一个匹配项。

*   **去除空白：**
    *   `trim()`: 去除字符串两端的空白字符（ASCII 值小于等于 32 的字符）。
    *   `strip()` (Java 11+): 去除字符串两端的空白字符（包括 Unicode 空白字符）。
    *   `stripLeading()` (Java 11+): 去除字符串开头的空白字符。
    *   `stripTrailing()` (Java 11+): 去除字符串末尾的空白字符。

*   **大小写转换：**
    *   `toLowerCase()`: 将字符串转换为小写。
    *   `toUpperCase()`: 将字符串转换为大写。

*   **分割：**
    *   `split(String regex)`: 根据正则表达式将字符串分割成字符串数组。
    *   `split(String regex, int limit)`: 根据正则表达式分割，并限制结果数组的大小。

*   **连接 (Java 8+)：**
    *   `String.join(CharSequence delimiter, CharSequence... elements)`: 使用指定分隔符连接多个字符序列。
    *   `String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements)`: 使用指定分隔符连接可迭代对象中的字符序列。

*   **与其他类型转换：**
    *   `String.valueOf(各种基本类型或对象)`: 将其他类型转换为字符串。
    *   `Integer.parseInt(String s)` / `Double.parseDouble(String s)` 等：将字符串转换为基本类型（可能抛出 `NumberFormatException`）。

*   **转换为字符数组或字节数组：**
    *   `toCharArray()`: 将字符串转换为字符数组。
    *   `getBytes()`: 使用平台默认编码将字符串转换为字节数组。
    *   `getBytes(String charsetName)` / `getBytes(Charset charset)`: 使用指定编码将字符串转换为字节数组。

*   **比较：**
    *   `equals(Object anObject)`: 比较两个字符串的内容是否相等。这是比较字符串内容是否相同的 **正确** 方法。
    *   `equalsIgnoreCase(String anotherString)`: 比较两个字符串的内容是否相等，忽略大小写。
    *   `compareTo(String anotherString)`: 按字典顺序比较两个字符串。返回负数表示当前字符串小于另一个，正数表示大于，0 表示相等。
    *   `compareToIgnoreCase(String str)`: 按字典顺序比较两个字符串，忽略大小写。

### 5. 字符串比较的陷阱：`==` vs `equals()`

这是 Java 字符串使用中最常见的错误来源。

*   **`==` 运算符：** 比较的是两个变量的 **引用**（内存地址）。只有当两个变量指向内存中的同一个对象时，`==` 才会返回 `true`。
*   **`equals()` 方法：** 比较的是两个字符串对象的 **内容**（字符序列）是否相等。

**示例：**

```java
String s1 = "hello";         // s1 -> 常量池中的 "hello"
String s2 = "hello";         // s2 -> 常量池中的 "hello" (同一个对象)
String s3 = new String("hello"); // s3 -> 堆中的新对象
String s4 = new String("hello"); // s4 -> 堆中的另一个新对象

System.out.println(s1 == s2);       // true (指向同一个常量池对象)
System.out.println(s1 == s3);       // false (s1 在常量池，s3 在堆)
System.out.println(s3 == s4);       // false (s3 和 s4 是堆中不同的对象)

System.out.println(s1.equals(s2));  // true (内容相同)
System.out.println(s1.equals(s3));  // true (内容相同)
System.out.println(s3.equals(s4));  // true (内容相同)
```

**结论：** 永远使用 `equals()` 方法来比较两个字符串的内容是否相等。

### 6. `StringBuilder` 和 `StringBuffer`：可变的字符序列

虽然 `String` 是不可变的，但在需要频繁修改字符串内容（如在循环中拼接字符串）的场景下，不可变性会导致创建大量中间的 `String` 对象，效率低下且浪费内存。

为了解决这个问题，Java 提供了两个可变的字符序列类：`StringBuilder` 和 `StringBuffer`。

*   **`StringBuilder`：**
    *   非线程安全。
    *   性能更高，推荐在单线程环境中使用。
    *   提供了 `append()`, `insert()`, `delete()`, `reverse()` 等方法来直接修改其内部的字符序列。
    *   最后通过 `toString()` 方法转换为 `String` 对象。

*   **`StringBuffer`：**
    *   线程安全（所有公共方法都使用了 `synchronized` 关键字）。
    *   性能略低于 `StringBuilder`。
    *   适用于多线程环境中需要共享同一个可变字符串的场景。
    *   方法与 `StringBuilder` 类似。

**示例 (使用 `StringBuilder` 进行高效拼接)：**

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10; i++) {
    sb.append("Number: ").append(i).append("\n");
}
String result = sb.toString(); // 一次性转换为 String
System.out.println(result);
```

**对比 `String` 拼接 (低效)：**

```java
String result = "";
for (int i = 0; i < 10; i++) {
    result = result + "Number: " + i + "\n"; // 每次循环都会创建新的 String 对象
}
System.out.println(result);
```
在循环中，`result = result + ...` 每次都会创建一个新的 `String` 对象，并将旧对象的内容和新内容复制过去，然后丢弃旧对象。这会产生大量的临时对象，导致垃圾回收负担增加，性能下降。而 `StringBuilder` 或 `StringBuffer` 是在同一个对象上进行修改，效率更高。

### 7. `CharSequence` 接口

`String`, `StringBuilder`, `StringBuffer` 都实现了 `CharSequence` 接口。这个接口代表一个可读的字符序列。许多接受字符串作为参数的方法（如 `String.contains()`, `String.replace()`, `String.split()` 等）都接受 `CharSequence` 类型，这意味着你可以传递 `String`, `StringBuilder`, `StringBuffer` 的实例给这些方法。

### 8. 最佳实践和注意事项

*   **优先使用字符串字面量：** 除非你需要一个全新的对象实例，否则使用 `"..."` 字面量更高效且节省内存，因为它会利用字符串常量池。
*   **始终使用 `equals()` 比较字符串内容：** 避免使用 `==` 比较字符串内容。
*   **在循环中拼接字符串时使用 `StringBuilder`：** 避免在循环中使用 `+` 进行字符串拼接。
*   **注意 `null` 字符串：** 在调用字符串方法之前，检查字符串是否为 `null`，否则会抛出 `NullPointerException`。例如：`if (str != null && !str.isEmpty()) { ... }`。
*   **理解字符编码：** 在处理字节数组与字符串之间的转换时，务必指定正确的字符编码，通常推荐使用 UTF-8。
*   **`trim()` vs `strip()`：** 在 Java 11+ 中，如果需要处理更广泛的 Unicode 空白字符，优先使用 `strip()` 系列方法。
*   **`split()` 的正则表达式：** `split()` 方法的参数是正则表达式，需要注意特殊字符的转义（如 `.` 需要转义为 `\\.`）。

### 总结

Java 的 `String` 类是不可变的字符序列，其不可变性带来了安全性、线程安全和性能优化（通过字符串常量池）。创建 `String` 对象主要通过字面量（利用常量池）或 `new` 关键字（创建新对象）。在比较字符串内容时，务必使用 `equals()` 方法而不是 `==` 运算符。在需要频繁修改或拼接字符串的场景下，应使用可变的 `StringBuilder` 或 `StringBuffer` 类来提高效率。理解这些核心概念和常用方法，是高效使用 Java 字符串的基础。





---









## 力扣738. 单调递增的数字
已解答
中等

当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。

给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。

 

示例 1:

输入: n = 10
输出: 9

示例 2:

输入: n = 1234
输出: 1234

示例 3:

输入: n = 332
输出: 299
 

提示:

0 <= n <= 10^9






### 贪心算法，无注释




```java



class Solution {
    public int monotoneIncreasingDigits(int n) {
        /**my error
        根本原因：
        在 Java 中，String 对象是 不可变的 (Immutable)。这意味着一旦一个 String 对象被创建，它的内容就不能被改变。
        strN.charAt(index) 方法返回的是字符串在指定索引处的 字符的副本（一个 char 类型的值），而不是一个可以被修改的变量引用。你不能对一个临时的返回值进行赋值或使用自增/自减运算符。
        您尝试通过 strN.charAt(i-1)-- 来修改 strN 中索引 i-1 处的字符，以及通过 strN.charAt(i) = 9 来修改 strN 中索引 i 处的字符。这在 Java 中是不允许的，因为 String 的内容是不可变的。
        解决方案
        要解决这个问题，您需要使用一个 可变的 数据结构来存储和修改字符序列。在 Java 中，最适合用于这种场景的是 char[] (字符数组) 或 StringBuilder。
        将 String 转换为 char[] 是一个常见的做法，因为可以直接通过索引访问和修改数组中的元素。
        步骤如下：
        1.将输入的整数 n 转换为 String。
        2.将这个 String 转换为 char[] 数组。
        3.在 char[] 数组上执行您的修改逻辑（递减字符、将字符设置为 '9'）。
        4.将修改后的 char[] 数组转换回 String。
        5.将最终的 String 转换回 int 并返回。
        */


        String strN = Integer.toString( n );


        int flag = strN.length();

        char[] arrayN = strN.toCharArray();

        for( int i = arrayN.length-1; i > 0; i-- ) {


            if( arrayN[i-1] > arrayN[i] ) {

                arrayN[i-1]--;

                flag = i;
            }

        }


        for( int i=flag; i < arrayN.length; i++ ) {

            arrayN[i] = '9';

        }

        String newStrN = new String( arrayN );

        return Integer.parseInt( newStrN );
        
    }
}





```









### 贪心算法，注释版



命令：

1.在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明

3.不需要更改代码逻辑或更改解法












          
好的，我们来为 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\算法学习记录\数据结构与算法学习记录.md"></mcfile> 文件中 LeetCode 738 "单调递增的数字" 的 Java 代码添加详细的逐行注释、解题思路总结，并结合示例进行讲解。



**解题思路总结:**

本题要求找到小于或等于给定整数 `n` 的最大单调递增数字。单调递增意味着从左到右，每一位数字都不小于前一位数字。

我们可以采用贪心算法，从右往左遍历数字的各位。目标是尽可能保持高位的数字不变，只在必要时进行调整。

1.  **从右往左扫描:** 遍历数字的字符串表示（转换为字符数组以便修改）。
2.  **检查递增性:** 比较相邻的两位数字 `arrayN[i-1]` 和 `arrayN[i]`。
3.  **发现违反:** 如果发现 `arrayN[i-1] > arrayN[i]`，说明单调递增性被破坏。为了构造小于等于 `n` 的最大单调递增数，我们需要：
    *   将 `arrayN[i-1]` 减 1。这保证了结果小于 `n`，并且修复了当前位置的递增性。
    *   将从索引 `i` 开始的所有后续数字都设置为 '9'。这是因为，为了使调整后的数字尽可能大，在满足单调递增的前提下，较低的位数应该取最大值 '9'。我们用一个 `flag` 变量记录第一个需要变成 '9' 的位置。
4.  **构造结果:** 将修改后的字符数组转换回整数。

这种从右往左的贪心策略确保了我们在第一次发现违反递增性时进行调整，并且这个调整使得最终结果是满足条件的最大值。因为我们只在必要时减小了高位数字，并将后续所有低位设置为最大可能的 '9'。

```java
/**
 * LeetCode 738. 单调递增的数字
 *
 * 解题思路：
 * 贪心算法。从右往左遍历数字的每一位。
 * 如果发现左边的数字大于右边的数字 (违反单调递增)，则将左边的数字减 1，
 * 并将该位置右边的所有数字都置为 9。这样可以保证得到小于等于原数 n 的最大单调递增数。
 * 使用一个 flag 标记从哪个位置开始需要将数字置为 9。
 */
class Solution {
    /**
     * 计算小于或等于 n 的最大单调递增数字。
     * @param n 非负整数。
     * @return 小于或等于 n 的最大单调递增数字。
     */
    public int monotoneIncreasingDigits(int n) {
        // 将整数 n 转换为字符串，方便按位处理
        String strN = Integer.toString(n);
        // 将字符串转换为字符数组，因为 String 是不可变的，我们需要修改数字的位
        char[] arrayN = strN.toCharArray();

        // flag 用于标记从哪个索引开始（包含该索引），后面的所有数字都需要设置为 '9'
        // 初始化为数组长度，表示默认情况下不需要改变任何数字为 '9'
        int flag = arrayN.length;

        // 从右往左遍历字符数组 (比较 arrayN[i-1] 和 arrayN[i])
        // 注意循环条件 i > 0，避免索引越界
        for (int i = arrayN.length - 1; i > 0; i--) {
            // 检查是否违反单调递增条件 (左边 > 右边)
            if (arrayN[i - 1] > arrayN[i]) {
                // 如果违反，将左边的数字减 1
                // 注意：字符 '0' 到 '9' 的 ASCII 值是连续的，可以直接进行减法操作
                arrayN[i - 1]--;
                // 更新 flag，标记从当前位置 i 开始，后面的数字都需要设置为 '9'
                // 因为 arrayN[i-1] 减小了，为了使结果最大化，其后的所有位都应取 9
                flag = i;
            }
        }

        // 将从 flag 标记的位置开始的所有数字设置为 '9'
        for (int i = flag; i < arrayN.length; i++) {
            arrayN[i] = '9';
        }

        // 将修改后的字符数组转换回字符串
        String newStrN = new String(arrayN);
        // 将字符串转换回整数并返回
        return Integer.parseInt(newStrN);
    }
}
```

**结合示例 `n = 332` 进行讲解:**

1.  **转换:** `n = 332` -> `strN = "332"` -> `arrayN = ['3', '3', '2']`. `flag = 3`.
2.  **第一次遍历 (从右往左):**
    *   `i = 2`: 比较 `arrayN[1] ('3')` 和 `arrayN[2] ('2')`.
        *   `'3' > '2'` 为 `true`。违反单调递增。
        *   将 `arrayN[1]` 减 1：`arrayN[1]` 变为 `'2'`. `arrayN` 变为 `['3', '2', '2']`.
        *   更新 `flag = i = 2`.
    *   `i = 1`: 比较 `arrayN[0] ('3')` 和 `arrayN[1] ('2')`.
        *   `'3' > '2'` 为 `true`。违反单调递增。
        *   将 `arrayN[0]` 减 1：`arrayN[0]` 变为 `'2'`. `arrayN` 变为 `['2', '2', '2']`.
        *   更新 `flag = i = 1`.
3.  **第二次遍历 (将 `flag` 及之后的位设为 '9'):**
    *   `flag = 1`. 循环从 `i = 1` 开始。
    *   `i = 1`: `arrayN[1] = '9'`. `arrayN` 变为 `['2', '9', '2']`.
    *   `i = 2`: `arrayN[2] = '9'`. `arrayN` 变为 `['2', '9', '9']`.
4.  **转换回结果:**
    *   `arrayN = ['2', '9', '9']` -> `newStrN = "299"`.
    *   `Integer.parseInt("299")` -> `299`.
5.  **返回:** `299`.

**结合示例 `n = 10` 进行讲解:**

1.  **转换:** `n = 10` -> `strN = "10"` -> `arrayN = ['1', '0']`. `flag = 2`.
2.  **第一次遍历 (从右往左):**
    *   `i = 1`: 比较 `arrayN[0] ('1')` 和 `arrayN[1] ('0')`.
        *   `'1' > '0'` 为 `true`。违反单调递增。
        *   将 `arrayN[0]` 减 1：`arrayN[0]` 变为 `'0'`. `arrayN` 变为 `['0', '0']`.
        *   更新 `flag = i = 1`.
3.  **第二次遍历 (将 `flag` 及之后的位设为 '9'):**
    *   `flag = 1`. 循环从 `i = 1` 开始。
    *   `i = 1`: `arrayN[1] = '9'`. `arrayN` 变为 `['0', '9']`.
4.  **转换回结果:**
    *   `arrayN = ['0', '9']` -> `newStrN = "09"`.
    *   `Integer.parseInt("09")` -> `9`.
5.  **返回:** `9`.

**结合示例 `n = 1234` 进行讲解:**

1.  **转换:** `n = 1234` -> `strN = "1234"` -> `arrayN = ['1', '2', '3', '4']`. `flag = 4`.
2.  **第一次遍历 (从右往左):**
    *   `i = 3`: `'3' <= '4'`. 不违反。
    *   `i = 2`: `'2' <= '3'`. 不违反。
    *   `i = 1`: `'1' <= '2'`. 不违反。
    *   循环结束，`flag` 仍然是 `4`.
3.  **第二次遍历 (将 `flag` 及之后的位设为 '9'):**
    *   `flag = 4`. 循环条件 `i = 4; i < arrayN.length (4)` 不满足，循环不执行。
4.  **转换回结果:**
    *   `arrayN = ['1', '2', '3', '4']` -> `newStrN = "1234"`.
    *   `Integer.parseInt("1234")` -> `1234`.
5.  **返回:** `1234`.










---
        
















# 动态规划


## 动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

























## 力扣509. 斐波那契数

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

 

示例 1：

输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1

示例 2：

输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2

示例 3：

输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
 

提示：

0 <= n <= 30






### 动态规划法，无注释

```java
class Solution {
    public int fib(int n) {
        // 动态规划

        if( n == 0 ) {
            return 0;
        }

        if( n == 1 ) {
            return 1;
        }


        List<Integer> F = new ArrayList<Integer>(n+1);

        F.add(0);

        F.add(1);

        for( int i=2; i <= n; i++ ) {

            F.add( F.get(i-1) + F.get(i-2) );

        }


        return F.get( n );


        
    }
}
```












---



















## 力扣70. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
 

提示：

1 <= n <= 45


### 动态规划法，无注释

```java
class Solution {
    public int climbStairs(int n) {

        if( n == 1 ) {

            return 1;
        }

        if( n == 2 ) {

            return 2;
        }


        int[] step = new int[n+1];

        step[1] = 1;

        step[2] = 2;


        for( int i = 3; i <= n; i++ ) {

            step[i] = step[i-1] + step[i-2];

        }



        return step[n];





        
    }
}

```





动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：
1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明





### 动态规划法，注释版



思考流程：

1. **理解题目：** 爬楼梯问题，每次可以爬 1 阶或 2 阶，求到达 n 阶楼顶的不同方法数。

2. **识别动态规划特征：**
    * **最优子结构：** 到达 n 阶的方法数取决于到达 n-1 阶和 n-2 阶的方法数。这是一个典型的最优子结构。
    * **重叠子问题：** 计算到 n 阶的方法数时，会多次计算到 n-1, n-2, n-3... 阶的方法数。存在重叠子问题。

3. **动态规划五部曲思考：**

    * **1. `dp` 数组及下标含义：**  `dp[i]` 表示爬到第 `i` 阶楼梯的不同方法数。 索引 `i` 代表楼梯的阶数，值 `dp[i]` 代表方法数。

    * **2. 递推公式：**  要到达第 `i` 阶，最后一步可以从第 `i-1` 阶爬 1 阶上来，或者从第 `i-2` 阶爬 2 阶上来。  因此，`dp[i] = dp[i-1] + dp[i-2]`。 这就是斐波那契数列的递推公式。

    * **3. `dp` 数组初始化：**
        * `dp[0]`：爬到 0 阶楼梯的方法数？  题目是从 1 阶开始，0 阶可能没有实际意义。但为了递推的完整性，可以考虑 `dp[0] = 0` (或者不使用 `dp[0]`)。
        * `dp[1]`：爬到 1 阶楼梯的方法数？ 只有一种方法：爬 1 阶。所以 `dp[1] = 1`。
        * `dp[2]`：爬到 2 阶楼梯的方法数？ 有两种方法：1+1, 2。所以 `dp[2] = 2`。
        * 这样，初始化 `dp[1] = 1` 和 `dp[2] = 2` 是最合适的，可以直接作为递推的起点。  如果使用 0 索引，可以初始化 `dp[0]=1` (到达 0 阶算一种方法，表示起点)，`dp[1]=1`。但代码实现上从 `dp[1]` 开始更自然。

    * **4. 遍历顺序：**  要计算 `dp[i]`，需要先知道 `dp[i-1]` 和 `dp[i-2]`。 因此，遍历顺序应该从前向后，从 `i = 3` 遍历到 `n`。

    * **5. 举例推导 `dp` 数组：**
        * `n = 1`: `dp[1] = 1`。 方法：1
        * `n = 2`: `dp[2] = 2`。 方法：1+1, 2
        * `n = 3`: `dp[3] = dp[2] + dp[1] = 2 + 1 = 3`。 方法：1+1+1, 1+2, 2+1
        * `n = 4`: `dp[4] = dp[3] + dp[2] = 3 + 2 = 5`。 方法：1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2

4. **代码实现（基于五部曲）：**  直接将五部曲的思考转化为代码。 初始化 `dp[1]` 和 `dp[2]`，循环计算 `dp[i]`，返回 `dp[n]`。  特殊处理 `n=1` 和 `n=2` 的情况可以简化代码逻辑。

5. **代码注释：**  按照要求，详细添加类注释（解题思路总结）和行注释（动态规划五部曲步骤）。

6. **话术组织：** 准备面试回答，按照动态规划五部曲的步骤，清晰地解释解题思路。 结合示例和代码进行讲解。

7. **最终代码审查：** 检查代码逻辑是否正确，注释是否清晰，话术是否流畅易懂。 确保代码可以正常运行，没有 bug，注释详细，讲解到位。

通过以上思考流程，可以系统地分析和解决爬楼梯问题，并产出高质量的代码和清晰的讲解。尤其动态规划五部曲，是解决 DP 问题的有效方法论。

<ctrl23>好的，非常棒！你的代码已经实现了爬楼梯问题的动态规划解法，并且思路清晰。现在，我将结合动态规划五部曲，在你的代码中添加详细的逐行注释和类注释，并进行详细讲解，使其更易于理解和复习。

```java
/**
 * 解题思路总结：
 *
 * 1.  问题分析：
 *     -   我们需要计算爬到 n 阶楼梯的不同方法数。
 *     -   每次可以爬 1 阶或 2 阶。
 *     -   这是一个典型的动态规划问题，因为它具有最优子结构和重叠子问题。
 *
 * 2.  动态规划五部曲：
 *     -   (1) 确定 dp 数组以及下标的含义：
 *         -   dp[i] 表示爬到第 i 阶楼梯的不同方法数。
 *         -   下标 i 代表楼梯的阶数，dp[i] 的值代表方法数。
 *     -   (2) 确定递推公式：
 *         -   要到达第 i 阶楼梯，最后一步可能是从第 i-1 阶爬 1 阶，或者从第 i-2 阶爬 2 阶。
 *         -   因此，爬到第 i 阶的方法数等于爬到第 i-1 阶的方法数加上爬到第 i-2 阶的方法数。
 *         -   递推公式：dp[i] = dp[i-1] + dp[i-2]
 *     -   (3) dp 数组如何初始化：
 *         -   根据题意，爬到第 1 阶楼梯只有 1 种方法（爬 1 阶），所以 dp[1] = 1。
 *         -   爬到第 2 阶楼梯有 2 种方法（1+1 阶，或者 2 阶），所以 dp[2] = 2。
 *         -   dp[0] 可以初始化为 0，虽然实际问题中 0 阶楼梯可能没有意义，但在代码实现中，为了数组下标统一，我们通常会保留 dp[0] 的位置，但本题中我们从 dp[1] 和 dp[2] 开始初始化更自然。
 *     -   (4) 确定遍历顺序：
 *         -   由于 dp[i] 依赖于 dp[i-1] 和 dp[i-2]，所以我们需要从前向后遍历，即从 i = 3 遍历到 n。
 *     -   (5) 举例推导 dp 数组：
 *         -   例如，当 n = 4 时：
 *             -   dp[1] = 1
 *             -   dp[2] = 2
 *             -   dp[3] = dp[2] + dp[1] = 2 + 1 = 3
 *             -   dp[4] = dp[3] + dp[2] = 3 + 2 = 5
 *         -   因此，爬到 4 阶楼梯有 5 种方法。
 *
 * 3.  代码实现：
 *     -   使用数组 `step[]` 作为 dp 数组，`step[i]` 存储爬到第 i 阶的方法数。
 *     -   根据递推公式和初始化条件，使用循环计算 dp 数组的值。
 *     -   最终返回 `step[n]`，即爬到第 n 阶的方法数。
 *
 * 4.  时间复杂度和空间复杂度：
 *     -   时间复杂度：O(n)，因为我们只需要遍历一次从 3 到 n 的循环来计算 dp 数组。
 *     -   空间复杂度：O(n)，因为我们使用了一个大小为 n+1 的 dp 数组来存储中间结果。
 */
class Solution {
    public int climbStairs(int n) {
        // 1. 【动态规划五部曲之一：确定 dp 数组的含义】
        //    dp数组：step
        //    dp[i] 的含义：表示爬到第 i 阶楼梯的不同方法数

        // 2. 【动态规划五部曲之三：dp 数组如何初始化】
        if (n == 1) {
            // 如果只有 1 阶楼梯，显然只有 1 种方法（爬 1 阶）
            return 1; // 初始化 dp[1] = 1 (虽然代码中没有显式使用 dp 数组的索引 1，但这里是初始化基准情况)
        }
        if (n == 2) {
            // 如果有 2 阶楼梯，显然有 2 种方法（1+1 阶，或者 2 阶）
            return 2; // 初始化 dp[2] = 2 (虽然代码中没有显式使用 dp 数组的索引 2，但这里是初始化基准情况)
        }

        // 创建 dp 数组，数组大小为 n+1，step[i] 存储爬到第 i 阶的方法数
        int[] step = new int[n + 1];

        // 初始化 dp 数组的初始值
        step[1] = 1; // 【动态规划五部曲之三：dp 数组如何初始化】 dp[1] = 1，爬到第 1 阶有 1 种方法
        step[2] = 2; // 【动态规划五部曲之三：dp 数组如何初始化】 dp[2] = 2，爬到第 2 阶有 2 种方法

        // 3. 【动态规划五部曲之四：确定遍历顺序】
        //    从第 3 阶开始遍历到第 n 阶，因为 dp[3] 及以后的值依赖于 dp[1] 和 dp[2]
        for (int i = 3; i <= n; i++) {
            // 4. 【动态规划五部曲之二：确定递推公式】
            //    递推公式：dp[i] = dp[i-1] + dp[i-2]
            //    爬到第 i 阶的方法数 = 爬到第 i-1 阶的方法数 + 爬到第 i-2 阶的方法数
            step[i] = step[i - 1] + step[i - 2];
        }

        // 5. 【动态规划五部曲之一：dp 数组的含义】
        //    dp[n] 的含义是爬到第 n 阶楼梯的不同方法数，即为所求答案
        return step[n]; // 返回 dp[n]，即爬到第 n 阶的方法总数
    }
}
```

**代码详细讲解和示例**

**1. 示例 1：n = 2**

*   **输入：** `n = 2`
*   **输出：** `2`
*   **解释：** 有两种方法可以爬到 2 阶楼顶。
    1.  1 阶 + 1 阶
    2.  2 阶

**代码执行流程（n = 2）：**

1.  进入 `climbStairs(2)` 方法。
2.  `if (n == 1)` 条件不满足。
3.  `if (n == 2)` 条件满足，直接返回 `2`。

**2. 示例 2：n = 3**

*   **输入：** `n = 3`
*   **输出：** `3`
*   **解释：** 有三种方法可以爬到 3 阶楼顶。
    1.  1 阶 + 1 阶 + 1 阶
    2.  1 阶 + 2 阶
    3.  2 阶 + 1 阶

**代码执行流程（n = 3）：**

1.  进入 `climbStairs(3)` 方法。
2.  `if (n == 1)` 条件不满足。
3.  `if (n == 2)` 条件不满足。
4.  创建 `int[] step = new int[4];` (数组大小为 n+1=4)。
5.  `step[1] = 1;` 初始化 `step[1]` 为 1。
6.  `step[2] = 2;` 初始化 `step[2]` 为 2。
7.  进入 `for` 循环，`i` 从 3 开始，到 3 结束。
8.  `i = 3`：`step[3] = step[3 - 1] + step[3 - 2] = step[2] + step[1] = 2 + 1 = 3;` 计算 `step[3]` 为 3。
9.  循环结束。
10. 返回 `step[3]`，值为 `3`。

**3. 示例 3：n = 4**

*   **输入：** `n = 4`
*   **输出：** `5`
*   **解释：** 有五种方法可以爬到 4 阶楼顶。
    1.  1 阶 + 1 阶 + 1 阶 + 1 阶
    2.  1 阶 + 1 阶 + 2 阶
    3.  1 阶 + 2 阶 + 1 阶
    4.  2 阶 + 1 阶 + 1 阶
    5.  2 阶 + 2 阶

**代码执行流程（n = 4）：**

1.  进入 `climbStairs(4)` 方法。
2.  `if (n == 1)` 和 `if (n == 2)` 条件不满足。
3.  创建 `int[] step = new int[5];` (数组大小为 n+1=5)。
4.  `step[1] = 1;` 初始化 `step[1]` 为 1。
5.  `step[2] = 2;` 初始化 `step[2]` 为 2。
6.  进入 `for` 循环，`i` 从 3 开始，到 4 结束。
7.  `i = 3`：`step[3] = step[3 - 1] + step[3 - 2] = step[2] + step[1] = 2 + 1 = 3;` 计算 `step[3]` 为 3。
8.  `i = 4`：`step[4] = step[4 - 1] + step[4 - 2] = step[3] + step[2] = 3 + 2 = 5;` 计算 `step[4]` 为 5。
9.  循环结束。
10. 返回 `step[4]`，值为 `5`。

**动态规划五部曲总结：**

通过代码中的注释和上述讲解，你可以清晰地看到动态规划五部曲是如何应用于解决爬楼梯问题的：

1.  **`dp[i]` 的含义：** 爬到第 `i` 阶的方法数。
2.  **递推公式：** `dp[i] = dp[i-1] + dp[i-2]`。
3.  **初始化：** `dp[1] = 1`, `dp[2] = 2`。
4.  **遍历顺序：** 从前向后，`i` 从 3 到 `n`。
5.  **举例推导：** 通过示例验证 `dp` 数组的正确性。

这种结构化的思考方式可以帮助你更好地理解和应用动态规划来解决类似的问题。你的代码实现非常简洁有效，加上详细的注释后，更易于理解和复习。在面试中，你可以按照动态规划五部曲的步骤，清晰地阐述你的解题思路。








---










































## 力扣746. 使用最小花费爬楼梯

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

示例 2：

输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
 

提示：

2 <= cost.length <= 1000
0 <= cost[i] <= 999




### 无注释

```java

class Solution {
    public int minCostClimbingStairs(int[] cost) {

        int height = cost.length;


        int dp[] = new int[height*2];

        dp[0] = 0;

        dp[1] = 0;

        for( int i=2; i <= height; i++ ) {



            dp[i] = Math.min( dp[i-1] + cost[i-1] , dp[i-2] + cost[i-2] );

        }


        return dp[height];




        
    }
}


```



动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：
1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明








### 注释版




```java
/**
 * 解题思路总结：
 *
 * 1.  问题分析：
 *     -   我们需要计算到达楼梯顶部的最低花费。
 *     -   可以从第 0 阶或第 1 阶开始，无需花费。
 *     -   `cost[i]` 是从第 `i` 个台阶向上爬需要支付的费用。支付费用后，可以选择爬 1 阶或 2 阶。
 *     -   目标是找到到达楼梯顶部的最小总花费。
 *
 * 2.  动态规划五部曲：
 *     -   (1) 确定 dp 数组以及下标的含义：
 *         -   `dp[i]` 表示到达第 `i` 阶楼梯的最低花费。
 *         -   下标 `i` 代表楼梯的阶数，`dp[i]` 的值代表到达该阶的最低花费。
 *         -   这里我们假设楼梯阶数从 0 开始编号，直到 `height - 1`，楼梯顶部可以看作是第 `height` 阶（虚拟阶梯，超出实际阶梯范围）。
 *     -   (2) 确定递推公式：
 *         -   要到达第 `i` 阶楼梯，最后一步可以是从第 `i-1` 阶爬 1 阶上来，或者从第 `i-2` 阶爬 2 阶上来。
 *         -   如果从第 `i-1` 阶爬 1 阶上来，那么到达第 `i` 阶的最低花费是 `dp[i-1] + cost[i-1]`。
 *         -   如果从第 `i-2` 阶爬 2 阶上来，那么到达第 `i` 阶的最低花费是 `dp[i-2] + cost[i-2]`。
 *         -   因此，`dp[i]` 应该是这两种情况的最小值。
 *         -   递推公式：`dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`
 *     -   (3) dp 数组如何初始化：
 *         -   根据题目描述，可以从下标为 0 或下标为 1 的台阶开始爬楼梯，且初始台阶不需要支付费用。
 *         -   因此，到达第 0 阶和第 1 阶的最低花费都为 0。
 *         -   初始化：`dp[0] = 0;`，`dp[1] = 0;`
 *     -   (4) 确定遍历顺序：
 *         -   由于 `dp[i]` 依赖于 `dp[i-1]` 和 `dp[i-2]`, 所以我们需要从前向后遍历，即从 `i = 2` 遍历到 `height`。
 *     -   (5) 举例推导 dp 数组：
 *         -   例如，对于 `cost = [10, 15, 20]`，`height = 3`：
 *             -   `dp[0] = 0`
 *             -   `dp[1] = 0`
 *             -   `dp[2] = Math.min(dp[1] + cost[1], dp[0] + cost[0]) = Math.min(0 + 15, 0 + 10) = 10`
 *             -   `dp[3] = Math.min(dp[2] + cost[2], dp[1] + cost[1]) = Math.min(10 + 20, 0 + 15) = 15`
 *         -   `dp[3] = 15` 即为到达楼梯顶部的最低花费。
 *
 * 3.  代码实现：
 *     -   使用数组 `dp[]` 作为 dp 数组，`dp[i]` 存储到达第 i 阶的最低花费。
 *     -   根据递推公式和初始化条件，使用循环计算 dp 数组的值。
 *     -   最终返回 `dp[height]`，即到达楼梯顶部的最低花费。
 *
 * 4.  时间复杂度和空间复杂度：
 *     -   时间复杂度：O(n)，因为我们只需要遍历一次从 2 到 height 的循环来计算 dp 数组。
 *     -   空间复杂度：O(n)，因为我们使用了一个大小为 height+1 的 dp 数组来存储中间结果。
 */
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int height = cost.length; // 获取楼梯的阶数，也即 cost 数组的长度

        // 1. 【动态规划五部曲之一：确定 dp 数组的含义】
        //    dp 数组：dp
        //    dp[i] 的含义：表示到达第 i 阶楼梯的最低花费

        // 创建 dp 数组，数组大小为 height + 1，dp[i] 存储到达第 i 阶的最低花费
        int[] dp = new int[height + 1];

        // 2. 【动态规划五部曲之三：dp 数组如何初始化】
        //    dp[0] = 0，到达第 0 阶的最低花费为 0 (起始阶梯)
        dp[0] = 0;
        //    dp[1] = 0，到达第 1 阶的最低花费为 0 (起始阶梯)
        dp[1] = 0;

        // 3. 【动态规划五部曲之四：确定遍历顺序】
        //    从第 2 阶开始遍历到第 height 阶，因为 dp[2] 及以后的值依赖于 dp[0] 和 dp[1]
        for (int i = 2; i <= height; i++) {
            // 4. 【动态规划五部曲之二：确定递推公式】
            //    递推公式：dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
            //    到达第 i 阶的最低花费 = min (从 i-1 阶爬 1 阶的花费 + 到达 i-1 阶的最低花费,
            //                                从 i-2 阶爬 2 阶的花费 + 到达 i-2 阶的最低花费)
            //    注意：cost 数组的索引是从 0 开始的，所以 cost[i-1] 代表从第 i-1 阶向上爬需要支付的费用
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        // 5. 【动态规划五部曲之一：dp 数组的含义】
        //    dp[height] 的含义是到达第 height 阶楼梯（楼梯顶部）的最低花费，即为所求答案
        return dp[height]; // 返回 dp[height]，即到达楼梯顶部的最低花费
    }
}
```

**代码详细讲解和示例**

**1. 示例 1：`cost = [10, 15, 20]`**

*   **输入：** `cost = [10, 15, 20]`
*   **输出：** `15`
*   **解释：**  选择从下标为 1 的台阶开始（花费 0），然后向上爬两个台阶到达楼梯顶部，总花费为 `15`。

**代码执行流程（`cost = [10, 15, 20]`）：**

1.  `height = cost.length;`，`height` 为 3。
2.  `int[] dp = new int[height + 1];`，创建 `dp` 数组，大小为 4。
3.  `dp[0] = 0;`，`dp[1] = 0;` 初始化 `dp[0]` 和 `dp[1]` 为 0。
4.  进入 `for` 循环，`i` 从 2 开始，到 3 结束。
5.  `i = 2`：
    *   `dp[2] = Math.min(dp[2 - 1] + cost[2 - 1], dp[2 - 2] + cost[2 - 2]);`
    *   `dp[2] = Math.min(dp[1] + cost[1], dp[0] + cost[0]);`
    *   `dp[2] = Math.min(0 + 15, 0 + 10);`
    *   `dp[2] = 10;`
6.  `i = 3`：
    *   `dp[3] = Math.min(dp[3 - 1] + cost[3 - 1], dp[3 - 2] + cost[3 - 2]);`
    *   `dp[3] = Math.min(dp[2] + cost[2], dp[1] + cost[1]);`
    *   `dp[3] = Math.min(10 + 20, 0 + 15);`
    *   `dp[3] = 15;`
7.  循环结束。
8.  返回 `dp[3]`，值为 `15`。

**2. 示例 2：`cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]`**

*   **输入：** `cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]`
*   **输出：** `6`
*   **解释：** 选择从下标为 0 的台阶开始（花费 0），按照示例中的步骤爬楼梯，总花费为 `6`。

**代码执行流程（`cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]`）：**

代码会按照递推公式 `dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])` 逐步计算 `dp` 数组的值。最终 `dp[10]` 的值会是 `6`，与示例输出一致。你可以手动按照代码逻辑推导 `dp` 数组的每一个值，来验证代码的正确性。

**动态规划五部曲总结：**

通过代码中的注释和上述讲解，你可以清晰地看到动态规划五部曲是如何应用于解决最小花费爬楼梯问题的。代码实现简洁高效，加上详细的注释，使得代码易于理解和复习。在面试或学习过程中，这种结构化的动态规划解题思路是非常有帮助的。
















---























## 力扣62. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：

输入：m = 3, n = 7
输出：28

示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下

示例 3：

输入：m = 7, n = 3
输出：28

示例 4：

输入：m = 3, n = 3
输出：6
 

提示：

1 <= m, n <= 100
题目数据保证答案小于等于 2 * 10^9





### 无注释

```java

class Solution {
    public int uniquePaths(int m, int n) {


        int dp[][] = new int[m][n];

        for( int i=0; i < m; i++ ) {

            dp[i][0] = 1;
        }

        for( int j=0; j < n; j++ ) {

            dp[0][j] = 1;
        }

        for( int i=1; i < m; i++ ) {

            for( int j=1; j < n; j++ ) {

                dp[i][j] = dp[i-1][j] + dp[i][j-1];

            }

        }


        return dp[m-1][n-1];




        
    }
}


```


动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：
1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明








### 注释版




```java
/**
 * 解题思路总结：
 *
 * 1.  问题分析：
 *     -   我们需要计算从网格左上角到右下角的唯一路径数量。
 *     -   机器人只能向下或向右移动。
 *     -   这是一个典型的动态规划问题，因为它具有最优子结构和重叠子问题。
 *
 * 2.  动态规划五部曲：
 *     -   (1) 确定 dp 数组以及下标的含义：
 *         -   `dp[i][j]` 表示从网格的左上角 (0, 0) 到达单元格 (i, j) 的不同路径数量。
 *         -   下标 `i` 代表行索引，下标 `j` 代表列索引。
 *     -   (2) 确定递推公式：
 *         -   要到达单元格 (i, j)，机器人只能从上方单元格 (i-1, j) 向下移动一步，或者从左侧单元格 (i, j-1) 向右移动一步。
 *         -   因此，到达单元格 (i, j) 的路径数量等于到达单元格 (i-1, j) 的路径数量加上到达单元格 (i, j-1) 的路径数量。
 *         -   递推公式：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
 *     -   (3) dp 数组如何初始化：
 *         -   对于第一行 (`i = 0`)，机器人只能从左侧移动过来，因此到达第一行任何单元格都只有 1 条路径（一直向右移动）。即 `dp[0][j] = 1` (对于所有 `0 <= j < n`)。
 *         -   对于第一列 (`j = 0`)，机器人只能从上方移动过来，因此到达第一列任何单元格都只有 1 条路径（一直向下移动）。即 `dp[i][0] = 1` (对于所有 `0 <= i < m`)。
 *         -   起始单元格 `dp[0][0]` 实际上也应该初始化为 1，但由于我们的初始化策略已经覆盖了第一行和第一列，所以不需要显式设置 `dp[0][0]`，它会被后续的初始化覆盖，或者可以认为在初始化第一行/列时已经隐含了 `dp[0][0] = 1`。
 *     -   (4) 确定遍历顺序：
 *         -   由于 `dp[i][j]` 依赖于 `dp[i-1][j]` 和 `dp[i][j-1]`，我们需要确保在计算 `dp[i][j]` 之前，`dp[i-1][j]` 和 `dp[i][j-1]` 已经被计算出来。
 *         -   因此，我们可以使用双重循环，外层循环遍历行 `i` 从 1 到 `m-1`，内层循环遍历列 `j` 从 1 到 `n-1`。在计算 `dp[i][j]` 之前，第一行和第一列的 `dp` 值已经初始化，并且 `dp[i-1][j]` 和 `dp[i][j-1]` 在之前的循环中已经被计算出来。
 *     -   (5) 举例推导 dp 数组：
 *         -   例如，当 `m = 3, n = 2` 时：
 *             -   初始化：
 *                 -   `dp[0][0] = 1, dp[0][1] = 1` (第一行初始化)
 *                 -   `dp[1][0] = 1, dp[2][0] = 1` (第一列初始化)
 *             -   计算：
 *                 -   `dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2`
 *                 -   `dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3`
 *         -   `dp[2][1] = 3` 即为到达右下角的总路径数。
 *
 * 3.  代码实现：
 *     -   使用二维数组 `dp[][]` 作为 dp 数组，`dp[i][j]` 存储到达单元格 (i, j) 的路径数。
 *     -   根据初始化条件，初始化第一行和第一列的 `dp` 值。
 *     -   根据递推公式，使用双重循环计算剩余单元格的 `dp` 值。
 *     -   最终返回 `dp[m-1][n-1]`，即到达右下角单元格 (m-1, n-1) 的路径数。
 *
 * 4.  时间复杂度和空间复杂度：
 *     -   时间复杂度：O(m*n)，因为我们需要遍历整个 m x n 的网格来计算 dp 数组。
 *     -   空间复杂度：O(m*n)，因为我们使用了一个 m x n 的二维数组来存储中间结果。
 */
class Solution {
    public int uniquePaths(int m, int n) {
        // 1. 【动态规划五部曲之一：确定 dp 数组的含义】
        //    dp 数组：dp
        //    dp[i][j] 的含义：表示从左上角到达单元格 (i, j) 的不同路径数量

        // 创建 dp 数组，大小为 m x n，dp[i][j] 存储到达单元格 (i, j) 的路径数
        int[][] dp = new int[m][n];

        // 2. 【动态规划五部曲之三：dp 数组如何初始化】
        //    初始化第一列：对于第一列的每个单元格，只有 1 种路径可以到达（从上方一直向下走）
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1; // 初始化第一列的所有单元格为 1
        }

        //    初始化第一行：对于第一行的每个单元格，只有 1 种路径可以到达（从左侧一直向右走）
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1; // 初始化第一行的所有单元格为 1
        }

        // 3. 【动态规划五部曲之四：确定遍历顺序】
        //    从第 1 行第 1 列 (索引都为 1) 开始遍历到右下角，因为 dp[i][j] 依赖于其上方和左方的单元格
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 4. 【动态规划五部曲之二：确定递推公式】
                //    递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1]
                //    到达单元格 (i, j) 的路径数 = 到达上方单元格 (i-1, j) 的路径数 + 到达左侧单元格 (i, j-1) 的路径数
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        // 5. 【动态规划五部曲之一：dp 数组的含义】
        //    dp[m-1][n-1] 的含义是到达右下角单元格 (m-1, n-1) 的不同路径数量，即为所求答案
        return dp[m - 1][n - 1]; // 返回 dp[m-1][n-1]，即到达右下角的总路径数
    }
}
```

**代码详细讲解和示例**

**1. 示例 1：`m = 3, n = 7`**

*   **输入：** `m = 3, n = 7`
*   **输出：** `28`
*   **解释：**  这是一个 3 行 7 列的网格。代码将计算从左上角到右下角的唯一路径数。

**代码执行流程（`m = 3, n = 7`）：**

1.  `int[][] dp = new int[m][n];`，创建 `dp` 数组，大小为 3x7。
2.  初始化第一列 `dp[i][0] = 1` (对于 `i = 0, 1, 2`)。
3.  初始化第一行 `dp[0][j] = 1` (对于 `j = 0, 1, 2, 3, 4, 5, 6`)。
4.  进入双重 `for` 循环，`i` 从 1 到 2，`j` 从 1 到 6。
5.  循环计算 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`，例如：
    *   `dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2`
    *   `dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3`
    *   ...
    *   `dp[2][6] = dp[1][6] + dp[2][5]` (最后计算右下角的值)
6.  循环结束后，返回 `dp[m-1][n-1]`，即 `dp[2][6]`，其值为 `28`。

**2. 示例 2：`m = 3, n = 2`**

*   **输入：** `m = 3, n = 2`
*   **输出：** `3`
*   **解释：**  这是一个 3 行 2 列的网格。代码将计算从左上角到右下角的唯一路径数，结果为 `3`，对应示例中的三种路径。

**代码执行流程（`m = 3, n = 2`）：**

1.  `int[][] dp = new int[m][n];`，创建 `dp` 数组，大小为 3x2。
2.  初始化第一列 `dp[i][0] = 1` (对于 `i = 0, 1, 2`)。
3.  初始化第一行 `dp[0][j] = 1` (对于 `j = 0, 1`)。
4.  进入双重 `for` 循环，`i` 从 1 到 2，`j` 从 1 到 1。
5.  循环计算 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`，例如：
    *   `dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2`
    *   `dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3`
6.  循环结束后，返回 `dp[m-1][n-1]`，即 `dp[2][1]`，其值为 `3`。

**3. 示例 3 和 4：`m = 7, n = 3` 和 `m = 3, n = 3`**

你可以按照上述示例的流程，手动推导 `dp` 数组的值，来验证代码在示例 3 和示例 4 中的正确性。例如，对于 `m = 3, n = 3`，最终 `dp[2][2]` 的值会是 `6`，与示例输出一致。

**动态规划五部曲总结：**

通过代码注释和示例讲解，你可以看到如何使用动态规划五部曲来解决不同路径问题。代码实现简洁，效率高，易于理解。这种动态规划方法可以有效地计算网格中不同路径的数量。










---





















## 63. 不同路径 II

给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 2 * 109。

 

示例 1：

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

示例 2：

输入：obstacleGrid = [[0,1],[0,0]]
输出：1
 

提示：

m == obstacleGrid.length
n == obstacleGrid[i].length
1 <= m, n <= 100
obstacleGrid[i][j] 为 0 或 1




### 无注释

```java

class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {


        int m = obstacleGrid.length;

        int n = obstacleGrid[0].length;


        int dp[][] = new int[m][n];

        for( int i=0; i < m && obstacleGrid[i][0] == 0; i++ ) {

            dp[i][0] = 1;
        }

        for( int j=0; j < n && obstacleGrid[0][j] == 0; j++ ) {

            dp[0][j] = 1;
        }

        for( int i=1; i < m; i++ ) {

            for( int j=1; j < n; j++ ) {

                if( obstacleGrid[i][j] == 1 ) {

                    continue;
                }

                dp[i][j] = dp[i-1][j] + dp[i][j-1];

            }

        }


        return dp[m-1][n-1];

        
    }
}

```


动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：
1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明





### 注释版




```java
/**
 * 解题思路总结：
 *
 * 1.  问题分析：
 *     -   我们需要计算从网格左上角到右下角的唯一路径数量，但这次网格中包含了障碍物。
 *     -   机器人仍然只能向下或向右移动，并且不能通过障碍物单元格。
 *     -   这仍然是一个动态规划问题，是“不同路径”问题的进阶版本，需要考虑障碍物的影响。
 *
 * 2.  动态规划五部曲：
 *     -   (1) 确定 dp 数组以及下标的含义：
 *         -   `dp[i][j]` 表示从网格的左上角 (0, 0) 到达单元格 (i, j) 的不同路径数量，考虑了障碍物。
 *         -   下标 `i` 代表行索引，下标 `j` 代表列索引。
 *     -   (2) 确定递推公式：
 *         -   如果单元格 `(i, j)` 本身是障碍物（`obstacleGrid[i][j] == 1`），则无法到达该单元格，路径数为 0，即 `dp[i][j] = 0`。
 *         -   如果单元格 `(i, j)` 不是障碍物（`obstacleGrid[i][j] == 0`），则到达单元格 `(i, j)` 的路径数量仍然等于从上方单元格 `(i-1, j)` 向下移动一步到达，加上从左侧单元格 `(i, j-1)` 向右移动一步到达的路径数量。
 *         -   递推公式：
 *             -   如果 `obstacleGrid[i][j] == 1`，则 `dp[i][j] = 0`
 *             -   如果 `obstacleGrid[i][j] == 0`，则 `dp[i][j] = dp[i-1][j] + dp[i][j-1]` (需要注意边界情况，例如 `i-1 < 0` 或 `j-1 < 0` 时)
 *     -   (3) dp 数组如何初始化：
 *         -   我们需要考虑障碍物对第一行和第一列初始化的影响。
 *         -   对于第一列 (`j = 0`)，从上到下遍历，如果遇到障碍物，则该单元格及其下方的所有单元格都无法到达（路径数为 0），因为从上方无法绕过障碍物。在遇到障碍物之前的单元格，路径数仍然为 1。
 *         -   对于第一行 (`i = 0`)，从左到右遍历，如果遇到障碍物，则该单元格及其右侧的所有单元格都无法到达（路径数为 0），因为从左侧无法绕过障碍物。在遇到障碍物之前的单元格，路径数仍然为 1。
 *         -   如果起始单元格 `(0, 0)` 本身就是障碍物，则直接返回 0，因为无法从起点出发。
 *     -   (4) 确定遍历顺序：
 *         -   与“不同路径”问题类似，`dp[i][j]` 依赖于 `dp[i-1][j]` 和 `dp[i][j-1]`，因此我们需要从前向后遍历，可以使用双重循环，外层循环遍历行 `i` 从 0 到 `m-1`，内层循环遍历列 `j` 从 0 到 `n-1`。
 *     -   (5) 举例推导 dp 数组：
 *         -   例如，对于 `obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]`：
 *             -   初始化第一列：`dp[0][0] = 1, dp[1][0] = 1, dp[2][0] = 1` (因为第一列没有障碍物)
 *             -   初始化第一行：`dp[0][0] = 1, dp[0][1] = 1, dp[0][2] = 1` (因为第一行没有障碍物)
 *             -   计算：
 *                 -   `dp[1][1]`，`obstacleGrid[1][1] == 1`，所以 `dp[1][1] = 0`
 *                 -   `dp[1][2] = dp[0][2] + dp[1][1] = 1 + 0 = 1`
 *                 -   `dp[2][1] = dp[1][1] + dp[2][0] = 0 + 1 = 1`
 *                 -   `dp[2][2] = dp[1][2] + dp[2][1] = 1 + 1 = 2`
 *         -   `dp[2][2] = 2` 即为到达右下角的总路径数。
 *
 * 3.  代码实现：
 *     -   使用二维数组 `dp[][]` 作为 dp 数组，`dp[i][j]` 存储到达单元格 (i, j) 的路径数。
 *     -   根据初始化条件，初始化第一行和第一列的 `dp` 值，需要考虑障碍物。
 *     -   根据递推公式，使用双重循环计算剩余单元格的 `dp` 值，跳过障碍物单元格。
 *     -   最终返回 `dp[m-1][n-1]`，即到达右下角单元格 (m-1, n-1) 的路径数。
 *
 * 4.  时间复杂度和空间复杂度：
 *     -   时间复杂度：O(m*n)，因为我们需要遍历整个 m x n 的网格来计算 dp 数组。
 *     -   空间复杂度：O(m*n)，因为我们使用了一个 m x n 的二维数组来存储中间结果。
 */
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // 获取网格的行数 m 和列数 n
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;

        // 如果起点就是障碍物，直接返回 0，因为无法从起点出发
        if (obstacleGrid[0][0] == 1) {
            return 0;
        }

        // 1. 【动态规划五部曲之一：确定 dp 数组的含义】
        //    dp 数组：dp
        //    dp[i][j] 的含义：表示从左上角到达单元格 (i, j) 的不同路径数量 (考虑障碍物)

        // 创建 dp 数组，大小为 m x n，dp[i][j] 存储到达单元格 (i, j) 的路径数
        // 在 Java 中，使用 new int[m][n] 创建的二维整型数组 dp 会自动将所有元素初始化为 0
        int[][] dp = new int[m][n];

        // 2. 【动态规划五部曲之三：dp 数组如何初始化】
        //    初始化第一列：对于第一列，只有当 obstacleGrid[i][0] == 0 时，dp[i][0] 才能为 1，
        //    并且一旦遇到障碍物，后续的 dp[i][0] (包括当前行) 都应该为 0，因为无法从上方绕过障碍物
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1; // 如果当前单元格不是障碍物，则路径数为 1
        }
        // 注意：如果 obstacleGrid[0][0] == 1，则上面的循环不会执行，第一列的 dp 值保持默认的 0

        //    初始化第一行：对于第一行，只有当 obstacleGrid[0][j] == 0 时，dp[0][j] 才能为 1，
        //    并且一旦遇到障碍物，后续的 dp[0][j] (包括当前列) 都应该为 0，因为无法从左侧绕过障碍物
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1; // 如果当前单元格不是障碍物，则路径数为 1
        }
        // 注意：如果 obstacleGrid[0][0] == 1，则上面的循环不会执行，第一行的 dp 值保持默认的 0

        // 3. 【动态规划五部曲之四：确定遍历顺序】
        //    从第 1 行第 1 列 (索引都为 1) 开始遍历到右下角，因为 dp[i][j] 依赖于其上方和左方的单元格
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 检查当前单元格是否是障碍物
                if (obstacleGrid[i][j] == 1) {
                    // 如果是障碍物，则无法到达，路径数为 0
                    dp[i][j] = 0;
                    continue; // 跳过当前循环，继续下一个单元格
                }

                // 4. 【动态规划五部曲之二：确定递推公式】
                //    递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1]
                //    到达单元格 (i, j) 的路径数 = 到达上方单元格 (i-1, j) 的路径数 + 到达左侧单元格 (i, j-1) 的路径数
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        // 5. 【动态规划五部曲之一：dp 数组的含义】
        //    dp[m-1][n-1] 的含义是到达右下角单元格 (m-1, n-1) 的不同路径数量 (考虑障碍物)，即为所求答案
        return dp[m - 1][n - 1]; // 返回 dp[m-1][n-1]，即到达右下角的总路径数
    }
}
```

**代码详细讲解和示例**

**1. 示例 1：`obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]`**

*   **输入：** `obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]`
*   **输出：** `2`
*   **解释：** 网格中间有一个障碍物。代码将计算从左上角到右下角避开障碍物的唯一路径数。

**代码执行流程（`obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]`）：**

1.  `m = 3, n = 3`。
2.  检查起点 `obstacleGrid[0][0] == 1`，不是，继续。
3.  初始化第一列：
    *   `i = 0`: `obstacleGrid[0][0] == 0`, `dp[0][0] = 1`。
    *   `i = 1`: `obstacleGrid[1][0] == 0`, `dp[1][0] = 1`。
    *   `i = 2`: `obstacleGrid[2][0] == 0`, `dp[2][0] = 1`。
    第一列 `dp` 值为 `[1, 1, 1]`。
4.  初始化第一行：
    *   `j = 0`: `obstacleGrid[0][0] == 0`, `dp[0][0] = 1` (已初始化)。
    *   `j = 1`: `obstacleGrid[0][1] == 0`, `dp[0][1] = 1`。
    *   `j = 2`: `obstacleGrid[0][2] == 0`, `dp[0][2] = 1`。
    第一行 `dp` 值为 `[1, 1, 1]`。
5.  双重循环计算：
    *   `i = 1, j = 1`: `obstacleGrid[1][1] == 1`，`dp[1][1] = 0`。
    *   `i = 1, j = 2`: `obstacleGrid[1][2] == 0`，`dp[1][2] = dp[0][2] + dp[1][1] = 1 + 0 = 1`。
    *   `i = 2, j = 1`: `obstacleGrid[2][1] == 0`，`dp[2][1] = dp[1][1] + dp[2][0] = 0 + 1 = 1`。
    *   `i = 2, j = 2`: `obstacleGrid[2][2] == 0`，`dp[2][2] = dp[1][2] + dp[2][1] = 1 + 1 = 2`。
6.  返回 `dp[2][2]`，值为 `2`。

**2. 示例 2：`obstacleGrid = [[0,1],[0,0]]`**

*   **输入：** `obstacleGrid = [[0,1],[0,0]]`
*   **输出：** `1`
*   **解释：**  网格右上角有一个障碍物。代码将计算从左上角到右下角避开障碍物的唯一路径数。

**代码执行流程（`obstacleGrid = [[0,1],[0,0]]`）：**

1.  `m = 2, n = 2`。
2.  检查起点 `obstacleGrid[0][0] == 1`，不是，继续。
3.  初始化第一列：
    *   `i = 0`: `obstacleGrid[0][0] == 0`, `dp[0][0] = 1`。
    *   `i = 1`: `obstacleGrid[1][0] == 0`, `dp[1][0] = 1`。
    第一列 `dp` 值为 `[1, 1]`。
4.  初始化第一行：
    *   `j = 0`: `obstacleGrid[0][0] == 0`, `dp[0][0] = 1` (已初始化)。
    *   `j = 1`: `obstacleGrid[0][1] == 1`，循环终止，第一行 `dp` 值为 `[1, 0]` （因为 `dp[0][1]` 及其后都被设置为默认值 0）。
5.  双重循环计算：
    *   `i = 1, j = 1`: `obstacleGrid[1][1] == 0`，`dp[1][1] = dp[0][1] + dp[1][0] = 0 + 1 = 1`。
6.  返回 `dp[1][1]`，值为 `1`。

**动态规划五部曲总结：**

通过代码注释和示例讲解，你可以看到如何使用动态规划五部曲来解决带障碍物的不同路径问题。代码有效地处理了障碍物，并计算出正确的唯一路径数量。理解动态规划的关键在于正确定义 `dp` 数组的含义、找到递推公式、以及合理地进行初始化和遍历。





```java
int[][] dp = new int[m][n];
```

会设置默认值为0吗？




是的，`int[][] dp = new int[m][n];` 在 Java 中会**自动将 `dp` 数组的所有元素初始化为默认值 `0`**。

**解释:**

在 Java 中，当您使用 `new` 关键字创建一个数组时，数组的元素会被自动初始化为其类型的默认值。对于基本数据类型 `int`，默认值是 `0`。

*   **基本数据类型的默认值:**
    *   `int`, `byte`, `short`, `long`:  `0`
    *   `float`, `double`: `0.0`
    *   `boolean`: `false`
    *   `char`: `\u0000` (null 字符)

*   **引用数据类型 (例如，对象数组) 的默认值:** `null`

**在你的代码 `int[][] dp = new int[m][n];` 中:**

*   `dp` 是一个二维整型数组 (`int[][]`)。
*   `new int[m][n]` 创建了一个 `m` 行 `n` 列的整型数组。
*   由于 `int` 是基本数据类型，Java 会自动将这个数组中的**所有 `m * n` 个 `int` 元素**初始化为 `0`。

**因此，在你的代码中，声明 `int[][] dp = new int[m][n];` 后，`dp` 数组中的所有元素初始值都是 `0`。**  这意味着在代码的后续部分，例如在初始化第一行和第一列之前，`dp` 数组的所有位置都已经是 `0` 了。

**总结:**

在 Java 中，使用 `new int[m][n]` 创建的二维整型数组 `dp` 会自动将所有元素初始化为 `0`。您无需手动循环遍历数组并将其设置为 `0`，除非您需要将其设置为其他初始值。在你的 "不同路径 II" 的代码中，这种默认初始化是符合逻辑的，因为在某些情况下（例如障碍物），路径数确实应该从 0 开始。


---

































## 343. 整数拆分

给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

 

示例 1:

输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:

输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
 

提示:

2 <= n <= 58



### 代码随想录解法学习

```java

class Solution {
    public int integerBreak(int n) {
        //dp[i] 为正整数 i 拆分后的结果的最大乘积
        int[] dp = new int[n+1];
        dp[2] = 1;
        for(int i = 3; i <= n; i++) {
            for(int j = 1; j <= i-j; j++) {
                // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，
                //并且，在本题中，我们分析 dp[0], dp[1]都是无意义的，
                //j 最大到 i-j,就不会用到 dp[0]与dp[1]
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
                // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘
                //而j * dp[i - j]是将 i 拆分成两个以及两个以上的个数,再相乘。
            }
        }
        return dp[n];
    }
}


```


讲解该题目



Okay, it seems there was a mix-up! The request starts asking about Redis Master-Slave failover (Interview Question 38 context) but then provides the "Integer Break" problem (LeetCode 343) and its Java solution, asking for an explanation of *that* specific problem and code.

I will proceed by explaining the **Integer Break** problem and the provided dynamic programming solution, as requested in the latter part of your message.

---

**面试题精讲：LeetCode 343. 整数拆分 (Integer Break)**

**1. 题目描述 (Problem Description)**

给定一个正整数 `n` (n ≥ 2 且 n ≤ 58)，你需要将其**拆分**成**至少两个**正整数的和。目标是找到一种拆分方式，使得这些拆分出的整数的**乘积最大化**。返回这个最大的乘积。

**示例:**

*   **输入:** `n = 2`
*   **输出:** `1`
    *   **解释:** 2 只能拆分为 1 + 1，乘积为 1 × 1 = 1。
*   **输入:** `n = 10`
*   **输出:** `36`
    *   **解释:** 10 可以拆分为 3 + 3 + 4，乘积为 3 × 3 × 4 = 36。这也是 10 能得到的最大乘积。（其他拆分如 2+2+2+2+2 乘积 32，5+5 乘积 25 等都不如 36 大）。

**2. 解题思路：动态规划 (Dynamic Programming Approach)**

这个问题具有典型的**最优子结构**和**重叠子问题**特性，非常适合使用动态规划来解决。

*   **最优子结构:** 要求解整数 `n` 的最大乘积拆分，可以依赖于比 `n` 小的整数 `i` 的最大乘积拆分结果。例如，如果我们将 `n` 拆分为 `j` 和 `n-j`，那么 `n` 的最大乘积可能与 `n-j` 这个子问题的最大乘积有关。
*   **重叠子问题:** 在计算较大 `n` 的拆分时，可能会多次需要计算较小整数 `k` 的最大拆分乘积。例如，计算 `dp[10]` 时可能需要 `dp[7]`, `dp[6]` 等，而计算 `dp[9]` 时也可能需要 `dp[6]`, `dp[5]` 等。

**3. 动态规划方案详解**

我们使用一个 DP 数组（或列表）来存储子问题的解。

*   **a. 状态定义 (DP State Definition):**
    `dp[i]` 表示将正整数 `i` **拆分成至少两个正整数之和**后，这些整数的最大乘积。

*   **b. 基础情况/边界条件 (Base Case):**
    *   `dp[0]` 和 `dp[1]` 没有意义，因为题目要求 `n >= 2` 且必须拆分成至少两个正整数。
    *   `dp[2]`：整数 2 只能拆分为 1 + 1，乘积为 1。所以 `dp[2] = 1`。

*   **c. 状态转移方程 (Recurrence Relation):**
    对于整数 `i` (从 3 到 `n`)，我们要计算 `dp[i]`。我们可以尝试将 `i` 拆分成第一个数 `j` (其中 `1 <= j < i`) 和剩余的数 `i-j`。
    当我们将 `i` 拆分为 `j` 和 `i-j` 时，有两种情况需要考虑来最大化乘积：

    1.  **只拆成两部分:** 直接将 `i` 拆分成 `j` 和 `i-j`，它们的乘积是 `j * (i-j)`。
    2.  **拆分成多于两部分:** 将 `i` 拆分成 `j` 和 `i-j`，但 `i-j` 这部分**继续进行拆分**以获得其最大乘积。根据我们的 DP 定义，`i-j` 拆分成至少两个数的最大乘积是 `dp[i-j]`。所以，这种情况下 `i` 拆分后的总乘积是 `j * dp[i-j]`。

    我们需要在这两种情况中取最大值。同时，`j` 可以取从 1 到 `i-1` 的不同值，我们需要遍历所有可能的 `j`，找到使得上述两种情况的最大值最大的那个 `j`。

    因此，状态转移方程为：
    `dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))`
    其中 `1 <= j < i`。

    **优化:** 在内层循环 `j` 时，我们只需要遍历到 `j <= i - j` (即 `j <= i / 2`) 即可。因为当 `j` 大于 `i / 2` 时，`i-j` 就会小于 `i / 2`，这相当于之前已经考虑过的将 `i` 拆分为 `i-j` 和 `j` 的情况，避免了重复计算。

*   **d. 最终结果 (Final Result):**
    我们要求解的是将整数 `n` 拆分后的最大乘积，根据定义，最终结果就是 `dp[n]`。

**4. 代码实现及逐行注释**

```java
class Solution {
    /**
     * 计算将正整数 n 拆分为至少两个正整数的和，并使这些整数的乘积最大化。
     * @param n 要拆分的正整数 (n >= 2, n <= 58)
     * @return 最大乘积
     */
    public int integerBreak(int n) {
        // dp[i] 定义为：将正整数 i 拆分成至少两个正整数的和后，这些整数的最大乘积。
        int[] dp = new int[n + 1]; // 创建 DP 数组，大小为 n+1，下标对应整数 0 到 n

        // 设置基础情况
        // dp[0] 和 dp[1] 无意义，保持默认值 0 即可。
        // 对于整数 2，只能拆分为 1 + 1，乘积为 1*1 = 1。
        dp[2] = 1;

        // 动态规划计算 dp[i] 从 i = 3 到 n
        for (int i = 3; i <= n; i++) {
            // 内层循环尝试将 i 拆分为 j 和 i-j
            // j 的范围从 1 开始。
            // 优化：j 只需要遍历到 i/2 即可（即 j <= i-j）。
            // 因为当 j > i/2 时，i-j < i/2，这种情况在前面 j 取较小值时已经覆盖了 (对称性)。
            for (int j = 1; j <= i - j; j++) {
                // 现在考虑将 i 拆分为 j 和 i-j 两种情况下的乘积最大化：
                // 情况 1: 就将 i 拆分为 j 和 i-j 两个数，乘积为 j * (i - j)。
                // 情况 2: 将 i 拆分为 j 和 (i-j)。但 (i-j) 继续进行拆分以获得最大乘积，
                //         这个最大乘积根据定义就是 dp[i-j]。所以这种情况乘积为 j * dp[i-j]。
                // 我们需要取这两种情况中的较大者。
                int currentMaxProduct = Math.max(j * (i - j), j * dp[i - j]);

                // dp[i] 需要记录所有可能的拆分 j (从 1 到 i/2) 所能得到的最大乘积。
                // 所以用当前计算出的 currentMaxProduct 更新 dp[i]。
                dp[i] = Math.max(dp[i], currentMaxProduct);
            }
        }

        // 最终结果是 dp[n]，即整数 n 拆分后的最大乘积。
        return dp[n];
    }
}
```

**5. 代码逻辑讲解**

1.  **初始化 `dp` 数组:** 创建一个长度为 `n+1` 的数组 `dp`，用于存储从 0 到 `n` 每个整数拆分后的最大乘积。`dp[i]` 的含义在注释中明确定义。
2.  **设置 `dp[2]`:** 将 `dp[2]` 初始化为 1，这是最小的有效输入的解。
3.  **外层循环 (`for i from 3 to n`)**: 这个循环负责计算 `dp[3], dp[4], ..., dp[n]` 的值。它保证了在计算 `dp[i]` 时，所有小于 `i` 的 `dp` 值（如 `dp[i-j]`）都已经计算好了。
4.  **内层循环 (`for j from 1 to i-j`)**: 对于当前的 `i`，这个循环尝试所有可能的第一个拆分值 `j`。`j <= i-j` 是一个重要的优化，避免了对同一种拆分组合（如 3+7 和 7+3）进行两次计算。
5.  **核心状态转移 (`dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]))`)**:
    *   `j * (i - j)`: 计算将 `i` 仅拆分为 `j` 和 `i-j` 两部分的乘积。
    *   `j * dp[i - j]`: 计算将 `i` 拆分为 `j` 和 `i-j`，并且 `i-j` 继续进行最优拆分（其最大乘积已存储在 `dp[i-j]` 中）的总乘积。这代表了将 `i` 拆分成三个或更多部分的情况（其中第一个部分是 `j`）。
    *   `Math.max(j*(i-j), j*dp[i-j])`: 对于固定的 `j`，在这两种拆分策略中选择乘积更大的那个。
    *   `dp[i] = Math.max(dp[i], ...)`: `dp[i]` 需要记录遍历所有可能的 `j` 时找到的最大乘积。因此，用当前 `j` 算出的最大乘积去更新 `dp[i]` 的值。
6.  **返回 `dp[n]`**: 循环结束后，`dp[n]` 中存储的就是整数 `n` 拆分后的最大乘积，将其返回。

**6. 复杂度分析 (Complexity Analysis)**

*   **时间复杂度 (Time Complexity):** O(n^2)。外层循环运行 `n` 次，内层循环运行最多 `n/2` 次。总的操作次数约为 (1/2 + 2/2 + 3/2 + ... + n/2) ≈ O(n^2)。
*   **空间复杂度 (Space Complexity):** O(n)。我们使用了一个大小为 `n+1` 的 DP 数组来存储中间结果。

**7. 总结 (Summary)**

这个问题通过动态规划得以有效解决。关键在于定义好 `dp[i]` 的含义（拆分 `i` 的最大乘积），找到正确的状态转移方程，该方程需要考虑将 `i` 拆分为 `j` 和 `i-j` 时，`i-j` 部分是否继续拆分这两种情况，并从中取最大值。通过自底向上地填充 DP 表，最终可以得到 `dp[n]` 作为问题的解。该 DP 解法的时间复杂度为 O(n^2)，空间复杂度为 O(n)。






```java
dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
```

为什么max(dp[i], max(j * (i - j), j * dp[i - j]))这里还有dp[i]？






你这个问题问得非常好，这正是理解动态规划状态转移方程的关键！

`dp[i] = Math.max(dp[i], max(j * (i - j), j * dp[i - j]))`

这里的 `dp[i]` 出现在 `Math.max` 的第一个参数位置，是因为我们需要在**所有可能**的拆分方案中找到那个能产生最大乘积的方案。

让我们拆解这个过程：

1.  **外层循环 `i`**: 我们按顺序计算 `dp[3], dp[4], ..., dp[n]`。
2.  **内层循环 `j`**: 对于当前的 `i`，这个循环尝试**所有可能**的第一个拆分点 `j`（从 1 到 `i/2`）。
3.  **`max(j * (i - j), j * dp[i - j])`**: 这部分计算的是，如果我们**确定了第一个拆分出的数是 `j`**，那么将 `i` 拆分后能得到的最大乘积是多少。它考虑了两种策略：
    *   `j * (i - j)`: 把 `i` 就拆成 `j` 和 `i-j` 两部分。
    *   `j * dp[i - j]`: 把 `i` 拆成 `j` 和 `i-j`，并且让 `i-j` 继续按最优方式拆分（其结果是 `dp[i-j]`）。
    这个内部 `max` 选出了**对于当前这个特定 `j`** 的最优拆分策略下的乘积。我们称这个结果为 `current_max_for_this_j`。

4.  **`Math.max(dp[i], current_max_for_this_j)`**: 现在是关键！内层循环会尝试不同的 `j`。
    *   当 `j=1` 时，我们计算出一个 `current_max_for_j=1`。
    *   当 `j=2` 时，我们计算出一个 `current_max_for_j=2`。
    *   ...
    *   当 `j = i/2` 时，我们计算出一个 `current_max_for_j=i/2`。

    `dp[i]` 的最终值应该是**所有这些** `current_max_for_this_j` 中的**最大值**。

    这里的 `dp[i]` 起到了一个 **“擂台”** 或者 **“累积最大值”** 的作用：
    *   在内层循环开始前，`dp[i]` 通常是 0（或者在某些 DP 问题中是负无穷）。
    *   当处理第一个 `j` 时，`dp[i]` 更新为 `Math.max(初始值, current_max_for_j=1)`。
    *   当处理第二个 `j` 时，`dp[i]` 更新为 `Math.max(上一步的dp[i]值, current_max_for_j=2)`。
    *   以此类推...

    每一次 `dp[i] = Math.max(dp[i], ...)` 的操作，都是在**比较“到目前为止找到的最佳方案的乘积（存储在旧的 `dp[i]` 里）”和“当前尝试的这个 `j` 方案能得到的乘积”**，然后将两者中较大的那个**保留**下来，作为新的 `dp[i]` 的值。

    这样，当内层 `j` 循环结束时，`dp[i]` 就自然而然地存储了**遍历完所有可能的第一个拆分点 `j` 后，所能得到的全局最大乘积**。

**简单来说:** `dp[i]` 在 `Math.max` 的第一个参数位置，是为了**在迭代不同的 `j` 时，持续追踪并更新当前找到的最佳乘积**。它保证了我们最终得到的 `dp[i]` 是所有 `j` 可能性中的最大值。











### 动态规划法，无注释



```java


class Solution {
    public int integerBreak(int n) {


        int dp[] = new int[n+1];

        dp[2] = 1;

        for( int i=3; i <= n; i++ ) {

            for( int j=1; j <= i-j ; j++ ) {

                int currentMulti = Math.max( j * (i-j), j * dp[ i-j ] );


                dp[i] = Math.max( dp[i], currentMulti );


            }
        }

        return dp[n];
        
    }
}


```






### 动态规划法，注释版



动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：
1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明






好的，我们来结合动态规划五部曲，详细地解析你提供的 LeetCode 343 "整数拆分" 问题的 Java 代码。

```java
/**
 * LeetCode 343: 整数拆分
 *
 * 问题描述：
 * 给定一个正整数 n (n >= 2, n <= 58)，将其拆分为至少两个正整数的和，
 * 并使这些拆分出的整数的乘积最大化。返回这个最大乘积。
 *
 * 解题思路总结 (动态规划):
 * 这个问题可以通过动态规划解决。我们定义 dp[i] 为将正整数 i 拆分成至少两个正整数之和后，
 * 这些整数的最大乘积。我们的目标是求解 dp[n]。
 *
 * 动态规划五部曲：
 * 1. 状态定义: dp[i] 表示整数 i 拆分后的最大乘积。
 * 2. 状态转移方程:
 *    要计算 dp[i]，我们可以尝试将其拆分为 j 和 i-j (其中 1 <= j < i)。
 *    对于这个拆分，有两种可能获得最大乘积的策略：
 *    a) 将 i 直接拆分为 j 和 i-j 两部分，乘积为 j * (i-j)。
 *    b) 将 i 拆分为 j 和 i-j，但允许 i-j 继续进行拆分以获得其最大乘积 dp[i-j]，
 *       此时的总乘积为 j * dp[i-j]。
 *    我们需要取这两种策略中的最大值。
 *    同时，j 可以取多个值，dp[i] 需要取所有可能的 j 对应的最大乘积中的最大值。
 *    因此，递推公式为: dp[i] = max(dp[i], max(j * (i-j), j * dp[i-j]))，
 *    其中 j 从 1 遍历到 i/2 (优化，避免重复计算)。
 *    这里的第一个 dp[i] 是为了在遍历不同 j 时，持续记录当前找到的最大值。
 * 3. 初始化: dp[2] = 1 (2 只能拆成 1+1，乘积为 1)。dp[0] 和 dp[1] 无意义，
 *    数组默认初始化为 0 即可，因为乘积必然是正数，max 会正确选择。
 * 4. 遍历顺序: 从小到大计算 dp[i] (i 从 3 到 n)。这确保了在计算 dp[i] 时，
 *    所有需要的 dp[i-j] (其中 i-j < i) 已经被计算出来。内层 j 的遍历顺序不影响结果。
 * 5. 最终结果: dp[n]。
 */
class Solution {
    public int integerBreak(int n) {

        // 1. 确定dp数组（dp table）以及下标的含义
        // dp[i] 表示将正整数 i 拆分成至少两个正整数的和后，这些整数的最大乘积。
        // 数组大小为 n+1，以便能访问到 dp[n]。
        int dp[] = new int[n+1];

        // 3. dp数组如何初始化
        // 根据题意，n >= 2。
        // 对于 n = 2，只能拆分为 1 + 1，最大乘积为 1 * 1 = 1。
        // 这是动态规划的基础情况。
        // dp[0] 和 dp[1] 在本题中无意义，因为至少要拆成两个数。
        // 数组其他元素默认初始化为 0，这在 max 比较中是安全的。
        dp[2] = 1;

        // 4. 确定遍历顺序
        // 外层循环：从 i = 3 开始，计算到 n。
        // 必须保证在计算 dp[i] 时，所有小于 i 的 dp 值（如 dp[i-j]）已经计算完毕。
        // 所以 i 必须是从小到大遍历。
        for( int i=3; i <= n; i++ ) {

            // 内层循环：尝试将 i 拆分成 j 和 i-j。
            // j 从 1 开始。
            // 优化：j 遍历到 i/2 (即 j <= i-j) 即可。
            // 因为当 j > i/2 时，i-j < i/2，例如 i=10，拆成 7+3 和 3+7 本质是一样的拆分，
            // 在 j=3 时已经考虑过将 10 拆成 3 和 7 的情况。
            for( int j=1; j <= i-j ; j++ ) {

                // 2. 确定递推公式
                // 对于当前的拆分 j 和 i-j，计算可能的最大乘积：
                // a) 直接将 i 拆分为两部分 j 和 i-j，乘积为 j * (i-j)。
                // b) 将 i 拆分为 j 和 (i-j)，并且让 (i-j) 继续进行最优拆分，
                //    其最大乘积已知为 dp[i-j]。此时总乘积为 j * dp[i-j]。
                // 我们取这两种情况的最大值，作为 "当第一个拆分数为 j 时" 的最优乘积。
                int currentMulti = Math.max( j * (i-j), j * dp[ i-j ] );

                // dp[i] 需要记录的是 *所有不同* 的 j 拆分方式下，能得到的全局最大乘积。
                // 所以，用当前 j 算出的最优乘积(currentMulti) 来更新 dp[i]。
                // Math.max(dp[i], currentMulti) 保证了 dp[i] 始终存储着
                // 遍历到当前 j 为止所找到的最大乘积值。
                dp[i] = Math.max( dp[i], currentMulti );
            }
            // 内层循环结束后，dp[i] 就存储了整数 i 拆分后的最大乘积。
        }

        // 5. 举例推导dp数组 (在注释和下方说明中进行)
        // **举例推导dp数组 (以 n = 4 为例)**
        // *   **初始化**: `dp = [0, 0, 1, 0, 0]` (长度为 5，下标 0 到 4)
        // *   **i = 3**:
        //     *   `j = 1` (`1 <= 3-1`): `i-j = 2`.
        //         *   `currentMulti = Math.max(1 * (3-1), 1 * dp[2]) = Math.max(1 * 2, 1 * 1) = Math.max(2, 1) = 2`。
        //         *   `dp[3] = Math.max(dp[3], currentMulti) = Math.max(0, 2) = 2`。
        //     *   内层循环结束 (`j` 最大只能到 1)。
        //     *   此时 `dp = [0, 0, 1, 2, 0]`。
        // *   **i = 4**:
        //     *   `j = 1` (`1 <= 4-1`): `i-j = 3`.
        //         *   `currentMulti = Math.max(1 * (4-1), 1 * dp[3]) = Math.max(1 * 3, 1 * 2) = Math.max(3, 2) = 3`。
        //         *   `dp[4] = Math.max(dp[4], currentMulti) = Math.max(0, 3) = 3`。
        //     *   `j = 2` (`2 <= 4-2`): `i-j = 2`.
        //         *   `currentMulti = Math.max(2 * (4-2), 2 * dp[2]) = Math.max(2 * 2, 2 * 1) = Math.max(4, 2) = 4`。
        //         *   `dp[4] = Math.max(dp[4], currentMulti) = Math.max(3, 4) = 4`。
        //     *   内层循环结束 (`j` 最大只能到 2)。
        //     *   此时 `dp = [0, 0, 1, 2, 4]`。
        // *   **循环结束 (假设 n=4)**: 返回 `dp[n] = dp[4] = 4`。

        // **以 n = 10 为例 (部分推导，演示核心)**
        // *   ... (计算 dp[3] 到 dp[9]) ...
        // *   **i = 10**:
        //     *   `j = 1`: `i-j=9`. `current = max(1*9, 1*dp[9])`. (需要 `dp[9]` 的值)
        //     *   `j = 2`: `i-j=8`. `current = max(2*8, 2*dp[8]) = max(16, 2*dp[8])`. (需要 `dp[8]` 的值)
        //     *   `j = 3`: `i-j=7`. `current = max(3*7, 3*dp[7]) = max(21, 3*dp[7])`. (需要 `dp[7]` 的值)
        //     *   `j = 4`: `i-j=6`. `current = max(4*6, 4*dp[6]) = max(24, 4*dp[6])`. (需要 `dp[6]` 的值)
        //     *   `j = 5`: `i-j=5`. `current = max(5*5, 5*dp[5]) = max(25, 5*dp[5])`. (需要 `dp[5]` 的值)
        //     *   内层循环结束。
        //     *   `dp[10]` 会是上面所有 `current` 值以及初始 `dp[10]` (0) 中的最大值。经过计算，会发现当 `j=3` 时，`3*dp[7]` (假设 `dp[7]=12`) 是 `3*12=36`；当 `j=4` 时，`4*dp[6]` (假设 `dp[6]=9`) 是 `4*9=36`。 `max(21, 36)` 是 36, `max(24, 36)` 是 36。 比较 `j=1,2,3,4,5` 算出的所有 `current` 值，最大为 36。所以 `dp[10] = 36`。


        // 返回最终结果：整数 n 拆分后的最大乘积。
        return dp[n];
    }
}
```

**结合示例和代码进行详细讲解说明 (动态规划五部曲)**

1.  **确定dp数组（dp table）以及下标的含义**
    *   我们创建一个 `int dp[] = new int[n+1];` 数组。
    *   `dp[i]` 的含义是：将正整数 `i` 拆分成**至少两个**正整数的和之后，这些拆分出的数的**最大乘积**是多少。
    *   例如，`dp[10]` 应该存储将 10 拆分（如 3+3+4, 2+8, 5+5 等）后能得到的最大乘积（也就是 36）。

2.  **确定递推公式**
    *   我们要计算 `dp[i]` (其中 `i >= 3`)。
    *   我们可以尝试将 `i` 拆分成第一部分 `j` (其中 `1 <= j < i`) 和剩余部分 `i-j`。
    *   现在，对于这个拆分 `j + (i-j)`，如何最大化乘积？有两种主要的考虑方式：
        *   **方式一：不再拆分 `i-j`**。就将 `i` 看作是 `j` 和 `i-j` 这两个数的和，它们的乘积是 `j * (i - j)`。
        *   **方式二：继续拆分 `i-j`**。将 `i` 看作是 `j` 加上 `(i-j)` 的最优拆分。根据 `dp` 数组的定义，`(i-j)` 拆分后的最大乘积是 `dp[i-j]`。所以，这种方式下的总乘积是 `j * dp[i-j]`。
    *   对于一个固定的 `j`，我们需要在这两种方式中取较大的那个乘积：`Math.max(j * (i - j), j * dp[i - j])`。
    *   但是，`j` 本身是可以变化的（`j` 可以是 1, 2, 3, ..., 直到 `i/2`）。`dp[i]` 应该是**所有不同 `j` 值**所能带来的最大乘积中的那个**最大值**。
    *   因此，我们需要一个变量来记录遍历不同 `j` 时找到的最大值。这个角色由 `dp[i]` 自身扮演。在内层循环中，`dp[i] = Math.max(dp[i], currentMulti)` 这行代码就是在做这件事：比较之前找到的 `dp[i]` 的最大值和当前 `j` 算出的最大值 `currentMulti`，更新 `dp[i]` 为两者中的较大者。
    *   所以完整的递推逻辑是：对每个 `j` (从 1 到 `i/2`)，计算 `currentMulti = Math.max(j * (i - j), j * dp[i - j])`，然后更新 `dp[i] = Math.max(dp[i], currentMulti)`。

3.  **dp数组如何初始化**
    *   `dp[0]` 和 `dp[1]`：根据题意，拆分需要至少两个正整数，所以 `0` 和 `1` 无法满足条件，它们的 `dp` 值没有意义。Java 中 `int` 数组默认初始化为 0，这对后续计算没有影响。
    *   `dp[2]`: 整数 2 只能拆分为 1 + 1，乘积为 1 * 1 = 1。所以 `dp[2] = 1`。这是我们动态规划的起点（基础情况）。
    *   对于 `i >= 3`，`dp[i]` 在计算前默认为 0。因为我们要求的是最大乘积（必然是正数），`Math.max(0, 正数)` 会正确地取那个正数，所以默认的 0 值是安全的。

4.  **确定遍历顺序**
    *   **外层循环 `i`**: 必须从 `3` 遍历到 `n`。这是因为计算 `dp[i]` 需要用到 `dp[i-j]` 的值，其中 `i-j` 总是小于 `i`。如果 `i` 不是从小到大遍历，当我们计算 `dp[i]` 时，可能它依赖的 `dp[i-j]` 还没有被计算出来。
    *   **内层循环 `j`**: `j` 从 `1` 遍历到 `i/2` (即 `j <= i-j`)。这个顺序是从小到大还是从大到小都无所谓，因为它只是在计算当前的 `dp[i]`，不影响其他 `dp` 值的计算依赖关系。

5.  **举例推导dp数组 (以 n = 4 为例)**
    *   **初始化**: `dp = [0, 0, 1, 0, 0]` (长度为 5，下标 0 到 4)
    *   **i = 3**:
        *   `j = 1` (`1 <= 3-1`): `i-j = 2`.
            *   `currentMulti = Math.max(1 * (3-1), 1 * dp[2]) = Math.max(1 * 2, 1 * 1) = Math.max(2, 1) = 2`。
            *   `dp[3] = Math.max(dp[3], currentMulti) = Math.max(0, 2) = 2`。
        *   内层循环结束 (`j` 最大只能到 1)。
        *   此时 `dp = [0, 0, 1, 2, 0]`。
    *   **i = 4**:
        *   `j = 1` (`1 <= 4-1`): `i-j = 3`.
            *   `currentMulti = Math.max(1 * (4-1), 1 * dp[3]) = Math.max(1 * 3, 1 * 2) = Math.max(3, 2) = 3`。
            *   `dp[4] = Math.max(dp[4], currentMulti) = Math.max(0, 3) = 3`。
        *   `j = 2` (`2 <= 4-2`): `i-j = 2`.
            *   `currentMulti = Math.max(2 * (4-2), 2 * dp[2]) = Math.max(2 * 2, 2 * 1) = Math.max(4, 2) = 4`。
            *   `dp[4] = Math.max(dp[4], currentMulti) = Math.max(3, 4) = 4`。
        *   内层循环结束 (`j` 最大只能到 2)。
        *   此时 `dp = [0, 0, 1, 2, 4]`。
    *   **循环结束 (假设 n=4)**: 返回 `dp[n] = dp[4] = 4`。

    **以 n = 10 为例 (部分推导，演示核心)**
    *   ... (计算 dp[3] 到 dp[9]) ...
    *   **i = 10**:
        *   `j = 1`: `i-j=9`. `current = max(1*9, 1*dp[9])`. (需要 `dp[9]` 的值)
        *   `j = 2`: `i-j=8`. `current = max(2*8, 2*dp[8]) = max(16, 2*dp[8])`. (需要 `dp[8]` 的值)
        *   `j = 3`: `i-j=7`. `current = max(3*7, 3*dp[7]) = max(21, 3*dp[7])`. (需要 `dp[7]` 的值)
        *   `j = 4`: `i-j=6`. `current = max(4*6, 4*dp[6]) = max(24, 4*dp[6])`. (需要 `dp[6]` 的值)
        *   `j = 5`: `i-j=5`. `current = max(5*5, 5*dp[5]) = max(25, 5*dp[5])`. (需要 `dp[5]` 的值)
        *   内层循环结束。
        *   `dp[10]` 会是上面所有 `current` 值以及初始 `dp[10]` (0) 中的最大值。经过计算，会发现当 `j=3` 时，`3*dp[7]` (假设 `dp[7]=12`) 是 `3*12=36`；当 `j=4` 时，`4*dp[6]` (假设 `dp[6]=9`) 是 `4*9=36`。 `max(21, 36)` 是 36, `max(24, 36)` 是 36。 比较 `j=1,2,3,4,5` 算出的所有 `current` 值，最大为 36。所以 `dp[10] = 36`。

通过这五步曲，我们可以清晰地理解动态规划的思考过程和代码实现的对应关系，从而有效地解决这类问题。













---

















## 力扣96. 不同的二叉搜索树

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

 

示例 1：

输入：n = 3
输出：5

示例 2：

输入：n = 1
输出：1
 

提示：

1 <= n <= 19



### 动态规划，无注释

```java

class Solution {
    public int numTrees(int n) {


        int dp[] = new int[n+1];

        dp[0] = 1;

        for( int i=1; i <= n; i++ ) {

            for( int j=1; j <= i; j++ ) {

                dp[i] += dp[j-1] * dp[i-j];

            }

        }


        return dp[n];
        
    }
}


```


动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：
1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明







### 动态规划，注释版





好的，我们来结合动态规划五部曲，详细地解析你提供的 LeetCode 96 "不同的二叉搜索树" 问题的 Java 代码。

```java
/**
 * LeetCode 96: 不同的二叉搜索树
 *
 * 问题描述：
 * 给定一个整数 n，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的
 * 二叉搜索树 (BST) 有多少种？返回满足题意的二叉搜索树的种数。
 *
 * 解题思路总结 (动态规划 - 卡特兰数):
 * 这个问题是经典的卡特兰数应用。我们可以使用动态规划来解决。
 *
 * 动态规划五部曲：
 * 1. 状态定义:
 *    dp[i] 表示用 1 到 i 这 i 个连续整数能组成的不同二叉搜索树的种数。
 *    我们的目标是求解 dp[n]。
 *
 * 2. 状态转移方程:
 *    要计算 dp[i]，我们可以考虑以 1 到 i 中的任意一个数 j 作为根节点。
 *    a. 当 j 作为根节点时，根据 BST 的性质：
 *       - 左子树的节点值是 1 到 j-1，共有 j-1 个节点。构成不同左子树的种数是 dp[j-1]。
 *       - 右子树的节点值是 j+1 到 i，共有 i-j 个节点。构成不同右子树的种数是 dp[i-j]。
 *    b. 对于一个确定的根 j，左子树的形态和右子树的形态是相互独立的。
 *       因此，以 j 为根的 BST 种数是 dp[j-1] * dp[i-j]。
 *    c. dp[i] 是所有可能的根节点 j (从 1 到 i) 对应的 BST 种数之和。
 *    所以，递推公式为: dp[i] = Σ (dp[j-1] * dp[i-j])  其中 j 从 1 遍历到 i。
 *
 * 3. 初始化:
 *    - dp[0] = 1: 表示空树只有一种形态。这是递推公式的基础，因为当 j=1 时需要 dp[0] (左子树为空)，当 j=i 时需要 dp[i-i] = dp[0] (右子树为空)。
 *    - dp[1] = 1: 表示只有一个节点 (值为 1) 时，只有一种 BST 形态 (只有根节点)。这个可以由公式推导：dp[1] = dp[0] * dp[1-1] = dp[0] * dp[0] = 1 * 1 = 1。
 *    数组其余元素可以默认为 0，因为我们会累加计算。
 *
 * 4. 遍历顺序:
 *    我们计算 dp[i] 时需要用到 dp[0] 到 dp[i-1] 的所有值。
 *    因此，外层循环 i 必须从 1 (或 2，如果 dp[1] 也手动初始化) 遍历到 n。
 *    内层循环 j 从 1 遍历到 i，计算所有可能的根节点情况。
 *
 * 5. 最终结果:
 *    dp[n] 即为所求的答案。
 */
class Solution {
    /**
     * 计算由 n 个节点组成的不同二叉搜索树的数量。
     * @param n 节点的数量 (节点值为 1 到 n)
     * @return 不同二叉搜索树的种数
     */
    public int numTrees(int n) {

        // 1. 确定dp数组（dp table）以及下标的含义
        // dp[i] 表示用 i 个不同的节点 (1 到 i) 可以构成多少种不同的二叉搜索树。
        // 数组大小为 n+1，以便存储 dp[0] 到 dp[n]。
        int dp[] = new int[n+1];

        // 3. dp数组如何初始化
        // dp[0] = 1 代表空树有 1 种形态。这是计算的基础。
        // 当根节点为 1 时，左子树节点数为 0，需要 dp[0]。
        // 当根节点为 i 时，右子树节点数为 0，需要 dp[i-i] = dp[0]。
        dp[0] = 1;
        // dp[1] 可以不显式初始化，循环会计算出来 dp[1] = dp[0]*dp[0] = 1。

        // 4. 确定遍历顺序
        // 外层循环 i 从 1 遍历到 n，计算 dp[1], dp[2], ..., dp[n]。
        // 必须从小到大计算，因为 dp[i] 依赖于所有小于 i 的 dp 值。
        for( int i=1; i <= n; i++ ) {

            // 内层循环 j 从 1 遍历到 i，代表尝试将 j 作为包含 i 个节点的树的根节点。
            for( int j=1; j <= i; j++ ) {

                // 2. 确定递推公式
                // 当根节点是 j 时 (j 的范围是 1 到 i)：
                // - 左子树由 [1, ..., j-1] 这 j-1 个节点组成，有 dp[j-1] 种形态。
                // - 右子树由 [j+1, ..., i] 这 i-j 个节点组成，有 dp[i-j] 种形态。
                //   (注意：虽然右子树的值不是从 1 开始，但其构成的不同结构数量只与节点个数有关)
                // 根据乘法原理，以 j 为根的 BST 共有 dp[j-1] * dp[i-j] 种。
                // dp[i] 是所有可能的根节点 j (1 到 i) 的情况之和。
                // 所以，累加所有以 j 为根的 BST 种数。
                dp[i] += dp[j-1] * dp[i-j];
            }
            // 内层循环结束后，dp[i] 就包含了用 i 个节点能构成的所有不同 BST 的种数。
        }

        // 5. 举例推导dp数组 (在下方详细说明中进行)
        // **举例推导dp数组 (以 n = 3 为例)**
        // *   **初始化**: `dp = [1, 0, 0, 0]` (长度为 4，下标 0 到 3)
        // *   **i = 1**:
        //     *   `j = 1`: `dp[1] += dp[1-1] * dp[1-1] = dp[0] * dp[0] = 1 * 1 = 1`。
        //     *   `dp` 变为 `[1, 1, 0, 0]`。
        // *   **i = 2**:
        //     *   `j = 1` (根是 1): `dp[2] += dp[1-1] * dp[2-1] = dp[0] * dp[1] = 1 * 1 = 1`。
        //     *   `j = 2` (根是 2): `dp[2] += dp[2-1] * dp[2-2] = dp[1] * dp[0] = 1 * 1 = 1`。
        //     *   `dp[2]` 最终为 `1 + 1 = 2`。
        //     *   `dp` 变为 `[1, 1, 2, 0]`。
        // *   **i = 3**:
        //     *   `j = 1` (根是 1): `dp[3] += dp[1-1] * dp[3-1] = dp[0] * dp[2] = 1 * 2 = 2`。
        //         *   (左子树 0 节点，右子树 2 节点)
        //     *   `j = 2` (根是 2): `dp[3] += dp[2-1] * dp[3-2] = dp[1] * dp[1] = 1 * 1 = 1`。
        //         *   (左子树 1 节点，右子树 1 节点)
        //     *   `j = 3` (根是 3): `dp[3] += dp[3-1] * dp[3-3] = dp[2] * dp[0] = 2 * 1 = 2`。
        //         *   (左子树 2 节点，右子树 0 节点)
        //     *   `dp[3]` 最终为 `2 + 1 + 2 = 5`。
        //     *   `dp` 变为 `[1, 1, 2, 5]`。
        // *   **循环结束 (n=3)**: 返回 `dp[n] = dp[3] = 5`。

        // 返回最终结果：用 n 个节点构成的不同 BST 的种数。
        return dp[n];
    }
}
```

**结合示例和代码进行详细讲解说明 (动态规划五部曲)**

1.  **确定dp数组（dp table）以及下标的含义**
    *   `int dp[] = new int[n+1];`
    *   `dp[i]` 的含义是：使用 `i` 个连续的、不同的节点（可以认为是 1 到 `i`）能够构建出的**不同结构**的二叉搜索树的数量。
    *   例如，`dp[3]` 存储的是用节点 1, 2, 3 能构建出的不同 BST 的数量。

2.  **确定递推公式**
    *   `dp[i] += dp[j-1] * dp[i-j];` (在内层循环 `j` 中)
    *   这个公式的核心思想是**枚举根节点**。对于一个包含 `i` 个节点的 BST (节点 1 到 `i`)：
        *   我们可以选择节点 `j` (其中 `1 <= j <= i`) 作为根节点。
        *   一旦确定根是 `j`，那么根据 BST 的性质：
            *   所有小于 `j` 的节点 (`1` 到 `j-1`) 必须在左子树中。左子树有 `j-1` 个节点。有多少种方法构建这个左子树？根据 `dp` 数组的定义，就是 `dp[j-1]` 种。
            *   所有大于 `j` 的节点 (`j+1` 到 `i`) 必须在右子树中。右子树有 `i - j` 个节点。有多少种方法构建这个右子树？根据 `dp` 数组的定义，就是 `dp[i-j]` 种。
        *   由于左子树的构建方式和右子树的构建方式是独立的，根据乘法原理，以 `j` 为根节点的 BST 共有 `dp[j-1] * dp[i-j]` 种。
        *   `dp[i]` 是所有可能的根节点 `j` (从 1 到 `i`) 对应的 BST 数量的总和。所以，我们在内层循环中使用 `+=` 来累加所有 `j` 的情况。

3.  **dp数组如何初始化**
    *   `dp[0] = 1;`
    *   这是非常关键的一步。`dp[0]` 代表空树。为什么空树算 1 种？
        *   当根节点是 `j=1` 时，左子树有 `j-1 = 0` 个节点（即空树），右子树有 `i-1` 个节点。此时需要 `dp[0] * dp[i-1]`。如果 `dp[0]` 是 0，乘积就是 0，这显然不对。
        *   当根节点是 `j=i` 时，左子树有 `i-1` 个节点，右子树有 `i-i = 0` 个节点（即空树）。此时需要 `dp[i-1] * dp[0]`。
        *   因此，定义 `dp[0] = 1` 使得递推公式在处理边界情况（左子树或右子树为空）时能够正确工作。
    *   `dp[1]` 会由循环计算得出：`i=1` 时，`j=1`，`dp[1] += dp[1-1] * dp[1-1] = dp[0] * dp[0] = 1 * 1 = 1`。这符合只有一个节点只有一种 BST 的事实。

4.  **确定遍历顺序**
    *   外层循环 `for( int i=1; i <= n; i++ )`：计算 `dp[i]` 需要 `dp[0]` 到 `dp[i-1]` 的所有值（因为内层 `j` 循环会用到 `dp[j-1]` 和 `dp[i-j]`，这两个下标都小于 `i`）。所以 `i` 必须从小到大遍历。
    *   内层循环 `for( int j=1; j <= i; j++ )`：遍历所有可能的根节点 `j`。这个循环的顺序（`j` 从 1 到 `i` 或从 `i` 到 1）不影响 `dp[i]` 的最终累加结果。

5.  **举例推导dp数组 (以 n = 3 为例)**
    *   **初始化**: `dp = [1, 0, 0, 0]` (长度为 4，下标 0 到 3)
    *   **i = 1**:
        *   `j = 1`: `dp[1] += dp[1-1] * dp[1-1] = dp[0] * dp[0] = 1 * 1 = 1`。
        *   `dp` 变为 `[1, 1, 0, 0]`。
    *   **i = 2**:
        *   `j = 1` (根是 1): `dp[2] += dp[1-1] * dp[2-1] = dp[0] * dp[1] = 1 * 1 = 1`。
        *   `j = 2` (根是 2): `dp[2] += dp[2-1] * dp[2-2] = dp[1] * dp[0] = 1 * 1 = 1`。
        *   `dp[2]` 最终为 `1 + 1 = 2`。
        *   `dp` 变为 `[1, 1, 2, 0]`。
    *   **i = 3**:
        *   `j = 1` (根是 1): `dp[3] += dp[1-1] * dp[3-1] = dp[0] * dp[2] = 1 * 2 = 2`。
            *   (左子树 0 节点，右子树 2 节点)
        *   `j = 2` (根是 2): `dp[3] += dp[2-1] * dp[3-2] = dp[1] * dp[1] = 1 * 1 = 1`。
            *   (左子树 1 节点，右子树 1 节点)
        *   `j = 3` (根是 3): `dp[3] += dp[3-1] * dp[3-3] = dp[2] * dp[0] = 2 * 1 = 2`。
            *   (左子树 2 节点，右子树 0 节点)
        *   `dp[3]` 最终为 `2 + 1 + 2 = 5`。
        *   `dp` 变为 `[1, 1, 2, 5]`。
    *   **循环结束 (n=3)**: 返回 `dp[n] = dp[3] = 5`。

这个过程清晰地展示了如何利用子问题的解（`dp[0]` 到 `dp[i-1]`）来构建当前问题（`dp[i]`）的解，这正是动态规划的核心思想。这个问题计算出的数列被称为卡特兰数 (Catalan number)。





---


























## 卡码网KamaCoder 46. 携带研究材料（第六期模拟笔试）

题目描述
>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 
>
>小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

输入描述
>第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。
>
>第二行包含 M 个正整数，代表每种研究材料的所占空间。 
>
>第三行包含 M 个正整数，代表每种研究材料的价值。

输出描述
>输出一个整数，代表小明能够携带的研究材料的最大价值。

输入示例
>6 1
>
>2 2 3 1 5 2
>
>2 3 1 5 4 3

输出示例
>5

提示信息
>小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。 
>
>数据范围：
>1 <= N <= 5000
>1 <= M <= 5000
>研究材料占用空间和价值都小于等于 1000





### 01背包，二维dp无注释版

```java
import java.util.Scanner;

public class Main {


    public static void main( String[] args ) {

        Scanner sc = new Scanner(System.in);

        int M = sc.nextInt();

        int N = sc.nextInt();

        int weight[] = new int[M+1];

        int value[] = new int[M+1];


        int dp[][] = new int[M+1][N+1];


        for( int i=0; i < M; i++ ) {

            weight[i] = sc.nextInt();

        }

        for( int i=0; i < M; i++ ) {

            value[i] = sc.nextInt();
            
        }


        for( int i=0; i < M; i++ ) {

            for( int j=0; j <= N; j++ ) {


                dp[i][j] = 0;
            }
        }


        for( int j = weight[0]; j <= N; j++ ) {

            dp[0][j] = value[0];
        }


        for( int i=1; i < M; i++ ) {

            for( int j=1; j <= N; j++ ) {


                if( j < weight[i] ) {

                    dp[i][j] = dp[i-1][j];
                }
                else{

                    dp[i][j] = Math.max( dp[i-1][j], value[i] + dp[i-1][j-weight[i]] );

                }

                

            }
        }


        System.out.println( dp[M-1][N] );


    }


}
```











### 01背包，二维dp注释版







动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：
1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明










```java
import java.util.Scanner;

/**
 * ## 解题思路总结 (动态规划五部曲)
 *
 * 本代码使用动态规划方法解决 0-1 背包问题。
 *
 * **1. 确定 dp 数组以及下标的含义**
 *    - `dp[i][j]` 代表考虑前 `i` 个物品（物品索引为 0 到 i-1），背包容量为 `j` 时，能够装入背包的最大总价值。
 *
 * **2. 确定递推公式**
 *    - 对于第 `i` 个物品，我们有两种选择：
 *      - **不放入第 `i` 个物品:** 此时的最大价值与考虑前 `i-1` 个物品，背包容量为 `j` 时相同，即 `dp[i-1][j]`。
 *      - **放入第 `i` 个物品:**  前提是背包容量 `j` 必须大于等于第 `i` 个物品的重量 `weight[i]`。
 *                             放入后，背包剩余容量为 `j - weight[i]`，此时的最大价值为放入第 `i` 个物品的价值 `value[i]` 加上考虑前 `i-1` 个物品，背包容量为 `j - weight[i]` 时的最大价值，即 `value[i] + dp[i-1][j-weight[i]]`。
 *    - 递推公式为：
 *      - 如果 `j < weight[i]` (背包容量不足以放入第 `i` 个物品):  `dp[i][j] = dp[i-1][j]`
 *      - 如果 `j >= weight[i]` (背包容量足够放入第 `i` 个物品): `dp[i][j] = Math.max( dp[i-1][j], value[i] + dp[i-1][j-weight[i]] )`
 *
 * **3. dp 数组如何初始化**
 *    - `dp[i][j]` 的默认初始值可以设置为 0，因为表示没有任何物品放入背包时，价值为 0。
 *    - 为了方便递推，通常需要初始化 `dp[0][j]`，即考虑第一个物品（索引为 0）的情况。
 *      - 当背包容量 `j` 大于等于第一个物品的重量 `weight[0]` 时，`dp[0][j]` 的最大价值就是第一个物品的价值 `value[0]`。
 *      - 当背包容量 `j` 小于第一个物品的重量 `weight[0]` 时，`dp[0][j]` 的最大价值为 0（默认值）。
 *
 * **4. 确定遍历顺序**
 *    - 外层循环遍历物品 `i`，从 1 到 `M-1`（或者从 0 到 `M-1`，根据初始化方式调整）。
 *    - 内层循环遍历背包容量 `j`，从 1 到 `N`（或者从 0 到 `N`，根据初始化方式调整）。
 *    - 遍历顺序需要保证计算 `dp[i][j]` 时，所需的 `dp[i-1][j]` 和 `dp[i-1][j-weight[i]]` 已经计算出来。
 *
 * **5. 举例推导 dp 数组 (结合示例输入)**
 *    - 输入示例:
 *      - 物品种类 M = 6，背包容量 N = 1
 *      - 物品重量 weight = [2, 2, 3, 1, 5, 2]
 *      - 物品价值 value = [2, 3, 1, 5, 4, 3]
 *    - 根据代码和递推公式，可以手动推导 dp 数组，最终 `dp[M-1][N]` 即为最大价值。
 *
 * 通过以上五个步骤，可以清晰地理解和实现 0-1 背包问题的动态规划解法。
 */
public class Main {

    public static void main( String[] args ) {

        Scanner sc = new Scanner(System.in);

        // 第一行输入：物品种类 M 和 背包容量 N
        int M = sc.nextInt(); // M 代表研究材料的种类
        int N = sc.nextInt(); // N 代表小明的行李空间

        // 第二行输入：M 个整数，代表每种研究材料的所占空间
        int weight[] = new int[M]; // 创建重量数组，大小为 M，索引从 0 到 M-1
        // 第三行输入：M 个整数，代表每种研究材料的价值
        int value[] = new int[M];  // 创建价值数组，大小为 M，索引从 0 到 M-1

        // 创建 dp 数组：dp[i][j] 表示考虑前 i 个物品，背包容量为 j 时的最大价值
        int dp[][] = new int[M][N+1]; // 创建二维 DP 数组，行数为物品种类 M，列数为背包容量 N+1 (容量从 0 到 N)


        // 循环读取 M 个物品的重量
        for( int i=0; i < M; i++ ) {
            weight[i] = sc.nextInt(); // 将读取的重量存入 weight 数组的第 i 个位置 (索引从 0 开始)
        }

        // 循环读取 M 个物品的价值
        for( int i=0; i < M; i++ ) {
            value[i] = sc.nextInt(); // 将读取的价值存入 value 数组的第 i 个位置 (索引从 0 开始)
        }

        // 初始化 dp 数组：默认 Java 数组初始化为 0，此处为了代码可读性，显式初始化
        for( int i=0; i < M; i++ ) { // 遍历物品种类
            for( int j=0; j <= N; j++ ) { // 遍历背包容量从 0 到 N
                dp[i][j] = 0; // 初始化 dp[i][j] 为 0
            }
        }


        // 初始化 dp 数组的第一行：考虑第一个物品 (索引为 0)
        if (weight[0] <= N) { // 检查第一个物品的重量是否小于等于背包总容量
            for (int j = weight[0]; j <= N; j++ ) { // 从第一个物品的重量开始遍历到背包容量 N
                dp[0][j] = value[0]; // 如果背包容量足够放下第一个物品，则最大价值为第一个物品的价值
            }
        }


        // 动态规划核心部分：填充 dp 数组
        for( int i=1; i < M; i++ ) { // 遍历物品，从第二个物品 (索引为 1) 开始
            for( int j=1; j <= N; j++ ) { // 遍历背包容量，从 1 到 N

                if( j < weight[i] ) { // 如果当前背包容量 j 小于当前物品 i 的重量
                    dp[i][j] = dp[i-1][j]; // 则不放入物品 i，最大价值等于考虑前 i-1 个物品在容量 j 下的最大价值
                }
                else{ // 如果当前背包容量 j 大于等于当前物品 i 的重量
                    // 递推公式：dp[i][j] = Math.max( 不放入物品 i 的价值, 放入物品 i 的价值 )
                    dp[i][j] = Math.max( dp[i-1][j], // 不放入物品 i 的价值：等于考虑前 i-1 个物品在容量 j 下的最大价值
                                        value[i] + dp[i-1][j-weight[i]] ); // 放入物品 i 的价值：等于物品 i 的价值加上考虑前 i-1 个物品在容量 j-weight[i] 下的最大价值
                }


            }
        }

        // 输出最终结果：dp[M-1][N] 表示考虑所有 M 个物品，背包容量为 N 时的最大价值
        System.out.println( dp[M-1][N] ); // 输出 dp 数组右下角的值，即为最大总价值

    }

}
```

**代码逐行讲解说明 (结合示例和代码):**

1.  **`import java.util.Scanner;`**:  导入 `Scanner` 类，用于从标准输入读取数据。

2.  **`public class Main {`**:  定义公共类 `Main`，Java 程序的入口类。

3.  **`public static void main( String[] args ) {`**:  定义 `main` 方法，程序的入口点。

4.  **`Scanner sc = new Scanner(System.in);`**:  创建 `Scanner` 对象 `sc`，用于读取输入。

5.  **`int M = sc.nextInt();`**:  读取输入的第一个整数，赋值给 `M`，代表研究材料的种类数。**例如，对于输入示例 `6 1`，`M` 的值为 6。**

6.  **`int N = sc.nextInt();`**:  读取输入的第二个整数，赋值给 `N`，代表小明的行李空间。**例如，对于输入示例 `6 1`，`N` 的值为 1。**

7.  **`int weight[] = new int[M];`**:  创建整型数组 `weight`，大小为 `M`，用于存储每种研究材料的所占空间。**对于输入示例，`weight` 数组将被用来存储 `2 2 3 1 5 2` 这些重量值。** 注意数组大小为 `M`，索引从 `0` 到 `M-1`。

8.  **`int value[] = new int[M];`**:  创建整型数组 `value`，大小为 `M`，用于存储每种研究材料的价值。**对于输入示例，`value` 数组将被用来存储 `2 3 1 5 4 3` 这些价值值。** 注意数组大小为 `M`，索引从 `0` 到 `M-1`。

9.  **`int dp[][] = new int[M][N+1];`**:  创建二维整型数组 `dp`，大小为 `M` 行 `N+1` 列。`dp[i][j]` 将存储考虑前 `i+1` 种研究材料，行李空间为 `j` 时的最大价值。 **对于输入示例，`dp` 数组将是一个 6 行 2 列的数组 (索引从 0 开始)。**

10. **`for( int i=0; i < M; i++ ) { weight[i] = sc.nextInt(); }`**:  循环 `M` 次，读取第二行输入的 `M` 个整数，并依次存入 `weight` 数组。**例如，对于输入示例，循环结束后 `weight` 数组为 `[2, 2, 3, 1, 5, 2]`。**

11. **`for( int i=0; i < M; i++ ) { value[i] = sc.nextInt(); }`**:  循环 `M` 次，读取第三行输入的 `M` 个整数，并依次存入 `value` 数组。**例如，对于输入示例，循环结束后 `value` 数组为 `[2, 3, 1, 5, 4, 3]`。**

12. **`for( int i=0; i < M; i++ ) { for( int j=0; j <= N; j++ ) { dp[i][j] = 0; } }`**:  嵌套循环初始化 `dp` 数组的所有元素为 0。虽然 Java 数组默认初始化为 0，但显式初始化可以提高代码可读性。

13. **`if (weight[0] <= N) { for (int j = weight[0]; j <= N; j++ ) { dp[0][j] = value[0]; } }`**:  初始化 `dp` 数组的第一行。如果第一个物品的重量小于等于背包容量 `N`，则从重量开始到容量 `N` 的所有 `dp[0][j]` 值都设置为第一个物品的价值 `value[0]`。 **对于示例输入，`weight[0]` 为 2，大于 `N=1`，所以这个 `if` 条件不成立，第一行 `dp` 数组仍然保持初始化值 0。**

14. **`for( int i=1; i < M; i++ ) { for( int j=1; j <= N; j++ ) { ... } }`**:  嵌套循环，外层循环遍历物品（从第二个物品开始，索引 `i` 从 1 到 `M-1`），内层循环遍历背包容量（从 1 到 `N`）。

15. **`if( j < weight[i] ) { dp[i][j] = dp[i-1][j]; }`**:  递推公式的条件判断。如果当前背包容量 `j` 小于当前物品 `i` 的重量 `weight[i]`，则无法放入物品 `i`，`dp[i][j]` 的值等于不放入物品 `i` 的情况，即 `dp[i-1][j]`。

16. **`else{ dp[i][j] = Math.max( dp[i-1][j], value[i] + dp[i-1][j-weight[i]] ); }`**:  递推公式的核心计算。如果当前背包容量 `j` 大于等于当前物品 `i` 的重量 `weight[i]`，则可以选择放入或不放入物品 `i`，取两者中价值较大的：
    *   `dp[i-1][j]`：不放入物品 `i` 的情况，价值与考虑前 `i-1` 个物品在容量 `j` 下的最大价值相同。
    *   `value[i] + dp[i-1][j-weight[i]]`：放入物品 `i` 的情况，价值为物品 `i` 的价值 `value[i]` 加上考虑前 `i-1` 个物品在剩余容量 `j-weight[i]` 下的最大价值。

17. **`System.out.println( dp[M-1][N] );`**:  循环结束后，`dp[M-1][N]` 存储了考虑所有 `M` 种研究材料，行李空间为 `N` 时的最大价值，将其输出到控制台。 **对于示例输入，最终计算出的 `dp[M-1][N]` 的值为 5，因此输出 5。**

**示例推导 (结合输入示例):**

对于输入示例：

```
6 1
2 2 3 1 5 2
2 3 1 5 4 3
```

`M=6`, `N=1`, `weight=[2, 2, 3, 1, 5, 2]`, `value=[2, 3, 1, 5, 4, 3]`

初始化 `dp` 数组为 0。

初始化 `dp[0][j]`：`weight[0]=2 > N=1`，所以 `dp[0][j]` 仍然为 0。

开始填充 `dp` 数组：

*   **i=1 (第二个物品):**
    *   `weight[1]=2 > N=1`，所以 `dp[1][1] = dp[0][1] = 0`
*   **i=2 (第三个物品):**
    *   `weight[2]=3 > N=1`，所以 `dp[2][1] = dp[1][1] = 0`
*   **i=3 (第四个物品):**
    *   `weight[3]=1 <= N=1`，所以 `dp[3][1] = Math.max(dp[2][1], value[3] + dp[2][1-weight[3]]) = Math.max(0, 5 + dp[2][0]) = Math.max(0, 5 + 0) = 5`
*   **i=4 (第五个物品):**
    *   `weight[4]=5 > N=1`，所以 `dp[4][1] = dp[3][1] = 5`
*   **i=5 (第六个物品):**
    *   `weight[5]=2 > N=1`，所以 `dp[5][1] = dp[4][1] = 5`

最终 `dp[5][1] = 5`，所以输出结果为 5。

**总结:**

这段代码完整地实现了 0-1 背包问题的动态规划解法，并加入了详细的注释，结合示例和动态规划五部曲的讲解，相信你已经能够很好地理解这段代码的逻辑和实现原理了。在复习时，结合代码注释和解题思路总结，可以快速回顾和掌握动态规划的解题方法。





好的，我们使用一组新的输入输出来讲解这两种 0-1 背包问题的解法，以便更清晰地展示代码的执行过程。

**新的输入输出示例:**

**输入:**

```
4 5
2 3 4 1
3 4 5 2
```

**解释:**

*   `M = 4`: 有 4 种研究材料（物品）。
*   `N = 5`: 行李空间（背包容量）为 5。
*   `weight = [2, 3, 4, 1]`: 4 种材料的空间占用分别为 2, 3, 4, 1。
*   `value = [3, 4, 5, 2]`: 4 种材料的价值分别为 3, 4, 5, 2。

**预期输出:**

```
7
```

**解释:** 最佳选择是携带第 1 种材料（空间 2，价值 3）和第 2 种材料（空间 3，价值 4），总空间为 2 + 3 = 5，总价值为 3 + 4 = 7。或者选择第 3 种材料（空间 4，价值 5）和第 4 种材料（空间 1，价值 2），总空间为 4 + 1 = 5，总价值为 5 + 2 = 7。

---

### 1. 二维 DP 解法 (`dp[i][j]`) 讲解 (使用新示例)

参考代码：<mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\数据结构与算法学习记录.md"></mcfile> 中的 "01背包，二维dp注释版" 部分。

**动态规划五部曲回顾:**

1.  **DP 数组含义:** `dp[i][j]` 表示从下标为 0 到 `i` 的物品里任意取，放进容量为 `j` 的背包，价值总和最大是多少。
2.  **递推公式:**
    *   若 `j < weight[i]`: `dp[i][j] = dp[i-1][j]`
    *   若 `j >= weight[i]`: `dp[i][j] = Math.max(dp[i-1][j], value[i] + dp[i-1][j-weight[i]])`
3.  **初始化:** `dp` 数组所有元素初始化为 0。然后根据第一个物品初始化 `dp[0][j]`。
4.  **遍历顺序:** 先遍历物品 `i`，再遍历背包容量 `j`。
5.  **结果:** `dp[M-1][N]`

**代码执行过程 (新示例):**

*   `M = 4`, `N = 5`
*   `weight = [2, 3, 4, 1]`
*   `value = [3, 4, 5, 2]`
*   创建 `dp[4][6]` 数组，所有元素初始化为 0。

**初始化 `dp[0][j]` (考虑第一个物品，索引 i=0, weight[0]=2, value[0]=3):**

*   `j` 从 `weight[0]=2` 遍历到 `N=5`。
*   `dp[0][2] = value[0] = 3`
*   `dp[0][3] = value[0] = 3`
*   `dp[0][4] = value[0] = 3`
*   `dp[0][5] = value[0] = 3`
*   此时 `dp` 数组第一行 (i=0) 为: `[0, 0, 3, 3, 3, 3]`

**填充 `dp` 数组 (i 从 1 到 M-1):**

*   **i = 1 (第二个物品, weight[1]=3, value[1]=4):**
    *   `j=1`: `1 < weight[1]`, `dp[1][1] = dp[0][1] = 0`
    *   `j=2`: `2 < weight[1]`, `dp[1][2] = dp[0][2] = 3`
    *   `j=3`: `3 >= weight[1]`, `dp[1][3] = max(dp[0][3], value[1] + dp[0][3-3]) = max(3, 4 + dp[0][0]) = max(3, 4+0) = 4`
    *   `j=4`: `4 >= weight[1]`, `dp[1][4] = max(dp[0][4], value[1] + dp[0][4-3]) = max(3, 4 + dp[0][1]) = max(3, 4+0) = 4`
    *   `j=5`: `5 >= weight[1]`, `dp[1][5] = max(dp[0][5], value[1] + dp[0][5-3]) = max(3, 4 + dp[0][2]) = max(3, 4+3) = 7`
    *   此时 `dp` 数组第二行 (i=1) 为: `[0, 0, 3, 4, 4, 7]`

*   **i = 2 (第三个物品, weight[2]=4, value[2]=5):**
    *   `j=1`: `1 < weight[2]`, `dp[2][1] = dp[1][1] = 0`
    *   `j=2`: `2 < weight[2]`, `dp[2][2] = dp[1][2] = 3`
    *   `j=3`: `3 < weight[2]`, `dp[2][3] = dp[1][3] = 4`
    *   `j=4`: `4 >= weight[2]`, `dp[2][4] = max(dp[1][4], value[2] + dp[1][4-4]) = max(4, 5 + dp[1][0]) = max(4, 5+0) = 5`
    *   `j=5`: `5 >= weight[2]`, `dp[2][5] = max(dp[1][5], value[2] + dp[1][5-4]) = max(7, 5 + dp[1][1]) = max(7, 5+0) = 7`
    *   此时 `dp` 数组第三行 (i=2) 为: `[0, 0, 3, 4, 5, 7]`

*   **i = 3 (第四个物品, weight[3]=1, value[3]=2):**
    *   `j=1`: `1 >= weight[3]`, `dp[3][1] = max(dp[2][1], value[3] + dp[2][1-1]) = max(0, 2 + dp[2][0]) = max(0, 2+0) = 2`
    *   `j=2`: `2 >= weight[3]`, `dp[3][2] = max(dp[2][2], value[3] + dp[2][2-1]) = max(3, 2 + dp[2][1]) = max(3, 2+0) = 3`
    *   `j=3`: `3 >= weight[3]`, `dp[3][3] = max(dp[2][3], value[3] + dp[2][3-1]) = max(4, 2 + dp[2][2]) = max(4, 2+3) = 5`
    *   `j=4`: `4 >= weight[3]`, `dp[3][4] = max(dp[2][4], value[3] + dp[2][4-1]) = max(5, 2 + dp[2][3]) = max(5, 2+4) = 6`
    *   `j=5`: `5 >= weight[3]`, `dp[3][5] = max(dp[2][5], value[3] + dp[2][5-1]) = max(7, 2 + dp[2][4]) = max(7, 2+5) = 7`
    *   此时 `dp` 数组第四行 (i=3) 为: `[0, 2, 3, 5, 6, 7]`

**最终结果:**

`dp[M-1][N] = dp[3][5] = 7`。所以最大价值为 7。

---


**总结:**

通过这个新的示例，我们可以看到：

*   二维 DP 解法更直观地展示了每个物品选择与否对不同容量下最大价值的影响，但空间复杂度较高 O(M*N)。
*   一维 DP 解法通过巧妙的倒序遍历优化了空间复杂度至 O(N)，但理解上需要注意倒序遍历的必要性，以确保每个物品只被考虑一次。
*   两种方法最终都得到了相同的正确结果 7。












### 01背包，一维dp无注释版





```java

import java.util.Scanner;


public class Main {


    public static void main( String args[] ) {

        Scanner sc = new Scanner(System.in);

        int M = sc.nextInt();

        int N = sc.nextInt();

        int dp[] = new int[N+1];

        if( N == 0 ) {

            System.out.println(dp[0]);

            return;
        }


        int weight[] = new int[M+1];

        int value[] = new int[M+1];

        for( int i=0; i < M; i++ ) {

            weight[i] = sc.nextInt();
        }

        for( int i=0; i < M; i++ ) {

            value[i] = sc.nextInt();
        }



        for( int i=0; i < M; i++ ) {

            for( int j=N ; j >= weight[i]; j-- ) {


                dp[j] = Math.max( dp[j], dp[j-weight[i]] + value[i] );

            }
        }


        System.out.println(dp[N]);


        return ;

    }
}


```











### 01背包，一维dp注释版



动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：
1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明










```java
import java.util.Scanner;

/**
 * ## 携带研究材料 - 0-1 背包问题
 *
 * ### 解题思路 - 动态规划 (0-1 背包)
 *
 * 这是一个经典的 0-1 背包问题。每种研究材料（物品）只能选择一次，要么选，要么不选，不能切割。
 * 我们的目标是在限定的行李空间（背包容量 N）内，选择研究材料，使得携带的研究材料总价值最大。
 *
 * **动态规划五部曲：**
 * 1. **确定 dp 数组以及下标的含义:**
 *    - `dp[j]` 代表：当背包容量为 `j` 时，能够携带的研究材料的最大总价值。
 * 2. **确定递推公式:**
 *    - 对于每种研究材料 `i`，我们有两种选择：
 *      - **不选择材料 `i`:**  此时，背包容量为 `j` 的最大价值与不考虑材料 `i` 时相同，即 `dp[j]`。
 *      - **选择材料 `i` (如果当前背包容量 `j` 足够放下材料 `i`):** 此时，最大价值等于放入材料 `i` 的价值 `value[i]`，加上剩余容量 `j - weight[i]` 可以获得的最大价值 `dp[j - weight[i]]`。
 *    - 因此，递推公式为： `dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])`，前提是 `j >= weight[i]`。
 * 3. **dp 数组如何初始化:**
 *    - 当背包容量为 0 时，能携带的最大价值肯定为 0，所以 `dp[0] = 0`。
 *    - 为了在递推过程中正确计算最大值，通常将 `dp` 数组初始化为 0。 因为价值都是正整数，初始为0不会影响max的计算。
 * 4. **确定遍历顺序:**
 *    - **外层循环遍历物品 (研究材料):**  `for (int i = 0; i < M; i++)`，依次考虑每种研究材料。
 *    - **内层循环遍历背包容量:** `for (int j = N; j >= weight[i]; j--)`，为了保证每种材料只被选择一次（0-1 背包的特性），内层循环需要 **倒序遍历** 背包容量。
 *       -  倒序遍历的原因：在更新 `dp[j]` 时，我们使用的是 `dp[j - weight[i]]`。如果正序遍历，`dp[j - weight[i]]` 可能在当前循环中已经被更新过（放入了物品 `i`），这样就会导致在容量为 `j` 时多次放入物品 `i`，违反了 0-1 背包的规则。倒序遍历可以保证计算 `dp[j]` 时，`dp[j - weight[i]]` 仍然是上一轮（或者说不放入当前物品 `i` 时）的状态。
 * 5. **举例推导 dp 数组 (结合示例输入):**
 *    - 见代码讲解部分。
 */
public class Main {

    public static void main( String args[] ) {

        Scanner sc = new Scanner(System.in);

        int M = sc.nextInt(); // M 代表研究材料的种类 (物品数量)
        int N = sc.nextInt(); // N 代表小明的行李空间 (背包容量)

        int dp[] = new int[N+1]; // 1. 定义 dp 数组：dp[j] 表示容量为 j 的背包的最大价值，初始化默认为 0

        if( N == 0 ) { // 特殊情况处理：如果背包容量为 0，则最大价值为 0
            System.out.println(dp[0]); // 输出 dp[0]，即 0
            return; // 结束程序
        }

        int weight[] = new int[M]; // 存储每种研究材料的所占空间 (物品重量)
        int value[] = new int[M];  // 存储每种研究材料的价值 (物品价值)

        // 输入每种研究材料的所占空间
        for( int i=0; i < M; i++ ) {
            weight[i] = sc.nextInt();
        }

        // 输入每种研究材料的价值
        for( int i=0; i < M; i++ ) {
            value[i] = sc.nextInt();
        }

        // 4. 确定遍历顺序：先遍历物品，再倒序遍历背包容量
        for( int i=0; i < M; i++ ) { // 遍历每种研究材料 (物品 i)
            for( int j=N ; j >= weight[i]; j-- ) { // 倒序遍历背包容量，从 N 到 weight[i]
                // 2. 确定递推公式：dp[j] = Math.max(dp[j], dp[j-weight[i]] + value[i])
                //    - dp[j]：不选择当前材料 i，保持之前的最大价值
                //    - dp[j-weight[i]] + value[i]：选择当前材料 i，价值为放入材料 i 的价值 value[i] 加上剩余容量的最大价值 dp[j-weight[i]]
                dp[j] = Math.max( dp[j], dp[j-weight[i]] + value[i] );
            }
        }

        System.out.println(dp[N]); // 输出 dp[N]，即背包容量为 N 时的最大总价值

        return ; // 结束程序
    }
}
```

代码讲解 (结合示例输入)

**示例输入:**

```
6 1
2 2 3 1 5 2
2 3 1 5 4 3
```

*   `M = 6` (6 种研究材料)
*   `N = 1` (行李空间为 1)
*   `weight = [2, 2, 3, 1, 5, 2]` (每种材料的空间)
*   `value = [2, 3, 1, 5, 4, 3]` (每种材料的价值)

**DP 数组初始化:**

`dp = [0, 0]`  (长度为 N+1 = 2，初始值都为 0，`dp[0]` 和 `dp[1]` )

**遍历过程 (外层循环遍历物品，内层循环遍历容量):**

**外层循环 i = 0 (处理第 1 种材料，weight[0] = 2, value[0] = 2):**

*   内层循环 `j` 从 `N=1` 开始，到 `weight[0]=2`，由于 `j >= weight[0]` 的条件不满足 (`1 < 2`)，内层循环不会执行任何操作。
    `dp` 数组保持不变: `dp = [0, 0]`

**外层循环 i = 1 (处理第 2 种材料，weight[1] = 2, value[1] = 3):**

*   内层循环 `j` 从 `N=1` 开始，到 `weight[1]=2`，由于 `j >= weight[1]` 的条件不满足 (`1 < 2`)，内层循环不会执行任何操作。
    `dp` 数组保持不变: `dp = [0, 0]`

**外层循环 i = 2 (处理第 3 种材料，weight[2] = 3, value[2] = 1):**

*   内层循环 `j` 从 `N=1` 开始，到 `weight[2]=3`，由于 `j >= weight[2]` 的条件不满足 (`1 < 3`)，内层循环不会执行任何操作。
    `dp` 数组保持不变: `dp = [0, 0]`

**外层循环 i = 3 (处理第 4 种材料，weight[3] = 1, value[3] = 5):**

*   内层循环 `j` 从 `N=1` 开始，到 `weight[3]=1`，循环执行一次，`j = 1`
    *   `j = 1`:
        *   `dp[1] = Math.max(dp[1], dp[1 - weight[3]] + value[3]) = Math.max(dp[1], dp[1 - 1] + 5) = Math.max(dp[1], dp[0] + 5) = Math.max(0, 0 + 5) = 5`
    `dp` 数组更新为: `dp = [0, 5]`

**外层循环 i = 4 (处理第 5 种材料，weight[4] = 5, value[4] = 4):**

*   内层循环 `j` 从 `N=1` 开始，到 `weight[4]=5`，由于 `j >= weight[4]` 的条件不满足 (`1 < 5`)，内层循环不会执行任何操作。
    `dp` 数组保持不变: `dp = [0, 5]`

**外层循环 i = 5 (处理第 6 种材料，weight[5] = 2, value[5] = 3):**

*   内层循环 `j` 从 `N=1` 开始，到 `weight[5]=2`，由于 `j >= weight[5]` 的条件不满足 (`1 < 2`)，内层循环不会执行任何操作。
    `dp` 数组保持不变: `dp = [0, 5]`

**最终结果:**

循环结束后，`dp[N] = dp[1] = 5`。

**输出:**

`5`

**讲解总结:**

通过动态规划的五部曲分析和代码注释，以及结合示例的详细推导，可以清晰地理解这段代码是如何解决 0-1 背包问题的。  代码的核心在于使用 `dp` 数组记录不同背包容量下的最大价值，并通过递推公式和正确的遍历顺序，最终计算出背包容量为 `N` 时的最大价值。 在示例中，由于背包容量 `N=1` 很小，只有重量为 1 的第 4 种材料可以放入，其价值为 5，因此最终答案为 5。








---





好的，我们使用一组新的输入输出来讲解这两种 0-1 背包问题的解法，以便更清晰地展示代码的执行过程。

**新的输入输出示例:**

**输入:**

```
4 5
2 3 4 1
3 4 5 2
```

**解释:**

*   `M = 4`: 有 4 种研究材料（物品）。
*   `N = 5`: 行李空间（背包容量）为 5。
*   `weight = [2, 3, 4, 1]`: 4 种材料的空间占用分别为 2, 3, 4, 1。
*   `value = [3, 4, 5, 2]`: 4 种材料的价值分别为 3, 4, 5, 2。

**预期输出:**

```
7
```

**解释:** 最佳选择是携带第 1 种材料（空间 2，价值 3）和第 2 种材料（空间 3，价值 4），总空间为 2 + 3 = 5，总价值为 3 + 4 = 7。或者选择第 3 种材料（空间 4，价值 5）和第 4 种材料（空间 1，价值 2），总空间为 4 + 1 = 5，总价值为 5 + 2 = 7。

---



### 2. 一维 DP 解法 (`dp[j]`) 讲解 (使用新示例)

参考代码：<mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\数据结构与算法学习记录.md"></mcfile> 中的 "01背包，一维dp注释版" 部分。

**动态规划五部曲回顾:**

1.  **DP 数组含义:** `dp[j]` 表示容量为 `j` 的背包所能装的最大价值。
2.  **递推公式:** `dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])` (前提 `j >= weight[i]`)
3.  **初始化:** `dp` 数组所有元素初始化为 0。
4.  **遍历顺序:** 先遍历物品 `i`，再 **倒序** 遍历背包容量 `j` (从 `N` 到 `weight[i]`)。
5.  **结果:** `dp[N]`

**代码执行过程 (新示例):**

*   `M = 4`, `N = 5`
*   `weight = [2, 3, 4, 1]`
*   `value = [3, 4, 5, 2]`
*   创建 `dp[6]` 数组，所有元素初始化为 0: `dp = [0, 0, 0, 0, 0, 0]`

**填充 `dp` 数组:**

*   **i = 0 (第一个物品, weight[0]=2, value[0]=3):**
    *   `j` 从 `N=5` 倒序遍历到 `weight[0]=2`。
    *   `j=5`: `dp[5] = max(dp[5], dp[5-2] + value[0]) = max(0, dp[3] + 3) = max(0, 0+3) = 3`
    *   `j=4`: `dp[4] = max(dp[4], dp[4-2] + value[0]) = max(0, dp[2] + 3) = max(0, 0+3) = 3`
    *   `j=3`: `dp[3] = max(dp[3], dp[3-2] + value[0]) = max(0, dp[1] + 3) = max(0, 0+3) = 3`
    *   `j=2`: `dp[2] = max(dp[2], dp[2-2] + value[0]) = max(0, dp[0] + 3) = max(0, 0+3) = 3`
    *   此时 `dp` 数组为: `[0, 0, 3, 3, 3, 3]`

*   **i = 1 (第二个物品, weight[1]=3, value[1]=4):**
    *   `j` 从 `N=5` 倒序遍历到 `weight[1]=3`。
    *   `j=5`: `dp[5] = max(dp[5], dp[5-3] + value[1]) = max(3, dp[2] + 4) = max(3, 3+4) = 7`
    *   `j=4`: `dp[4] = max(dp[4], dp[4-3] + value[1]) = max(3, dp[1] + 4) = max(3, 0+4) = 4`
    *   `j=3`: `dp[3] = max(dp[3], dp[3-3] + value[1]) = max(3, dp[0] + 4) = max(3, 0+4) = 4`
    *   此时 `dp` 数组为: `[0, 0, 3, 4, 4, 7]`

*   **i = 2 (第三个物品, weight[2]=4, value[2]=5):**
    *   `j` 从 `N=5` 倒序遍历到 `weight[2]=4`。
    *   `j=5`: `dp[5] = max(dp[5], dp[5-4] + value[2]) = max(7, dp[1] + 5) = max(7, 0+5) = 7`
    *   `j=4`: `dp[4] = max(dp[4], dp[4-4] + value[2]) = max(4, dp[0] + 5) = max(4, 0+5) = 5`
    *   此时 `dp` 数组为: `[0, 0, 3, 4, 5, 7]`

*   **i = 3 (第四个物品, weight[3]=1, value[3]=2):**
    *   `j` 从 `N=5` 倒序遍历到 `weight[3]=1`。
    *   `j=5`: `dp[5] = max(dp[5], dp[5-1] + value[3]) = max(7, dp[4] + 2) = max(7, 5+2) = 7`
    *   `j=4`: `dp[4] = max(dp[4], dp[4-1] + value[3]) = max(5, dp[3] + 2) = max(5, 4+2) = 6`
    *   `j=3`: `dp[3] = max(dp[3], dp[3-1] + value[3]) = max(4, dp[2] + 2) = max(4, 3+2) = 5`
    *   `j=2`: `dp[2] = max(dp[2], dp[2-1] + value[3]) = max(3, dp[1] + 2) = max(3, 0+2) = 3`
    *   `j=1`: `dp[1] = max(dp[1], dp[1-1] + value[3]) = max(0, dp[0] + 2) = max(0, 0+2) = 2`
    *   此时 `dp` 数组为: `[0, 2, 3, 5, 6, 7]`

**最终结果:**

`dp[N] = dp[5] = 7`。所以最大价值为 7。

**总结:**

通过这个新的示例，我们可以看到：

*   二维 DP 解法更直观地展示了每个物品选择与否对不同容量下最大价值的影响，但空间复杂度较高 O(M*N)。
*   一维 DP 解法通过巧妙的倒序遍历优化了空间复杂度至 O(N)，但理解上需要注意倒序遍历的必要性，以确保每个物品只被考虑一次。
*   两种方法最终都得到了相同的正确结果 7。



---















## 力扣416. 分割等和子集
已解答
中等

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。


示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

示例 2：

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
 

提示：

1 <= nums.length <= 200
1 <= nums[i] <= 100










### 0/1 背包问题变种，一维解法，无注释



```java

class Solution {
    public boolean canPartition(int[] nums) {
        // 01背包问题变体


        int sum=0;

        for( int n : nums ) {

            sum += n;

        }

        if( sum % 2 == 1 ) {

            return false;
        }

        int target = sum / 2;

        int dp[] = new int[sum];


        for( int i=0; i < nums.length; i++ ) { 

            for( int j=target; j >= nums[i] ; j-- ) {

                dp[j] = Math.max( dp[j], nums[i] + dp[ j - nums[i] ] );

            }

        }

        return dp[target] == target;
        
    }
}

```










### 0/1 背包问题变种，一维解法，注释版




好的，我们来结合动态规划五部曲，为你提供的 LeetCode 416 "分割等和子集" 问题的 Java 代码添加详细注释，并进行讲解。

首先，补全你的代码逻辑，然后添加注释：

```java
/**
 * LeetCode 416: 分割等和子集
 *
 * 问题描述：
 * 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，
 * 使得两个子集的元素和相等。
 *
 * 解题思路总结 (动态规划 - 0/1 背包问题变种):
 * 这个问题可以转化为一个 0/1 背包问题。
 * 1. 首先计算数组的总和 sum。如果 sum 是奇数，那么不可能将数组分割成两个和相等的子集，直接返回 false。
 * 2. 如果 sum 是偶数，那么目标是找到一个子集，其和恰好等于 target = sum / 2。
 * 3. 这就变成了：给定一个数组 nums (物品)，每个物品的重量和价值都是其数值本身，
 *    问是否存在一种选择方式，使得选出的物品总和（总重量/总价值）恰好等于背包容量 target。
 *
 * 动态规划五部曲：
 * 1. 确定 dp 数组以及下标的含义:
 *    - `dp[j]` 表示：背包容量（目标和）为 j 时，能凑出的最大子集和是多少。
 *    - (另一种定义方式：`dp[j]` 为 boolean 类型，表示是否能凑出和为 j 的子集。两种方式都可以，这里采用第一种，更贴近标准 0/1 背包)
 *
 * 2. 确定递推公式:
 *    - 0/1 背包的递推公式。对于每个数字 `nums[i]`（物品）：
 *    - 如果不选择 `nums[i]`，则 `dp[j]` 保持不变。
 *    - 如果选择 `nums[i]`（前提是 `j >= nums[i]`），则 `dp[j]` 可以更新为 `dp[j - nums[i]] + nums[i]`。
 *    - 我们需要取这两种情况的最大值：`dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i])`。
 *
 * 3. dp 数组如何初始化:
 *    - `dp` 数组所有元素初始化为 0。`dp[0]` 自然是 0，表示容量为 0 时最大和为 0。
 *
 * 4. 确定遍历顺序:
 *    - 外层循环遍历物品（数组 `nums` 中的元素 `num`），从前到后。
 *    - 内层循环遍历背包容量（目标和 `j`），**必须从后往前**（从 `target` 到 `num`）。
 *      这是为了保证每个数字 `num` 只被使用一次（符合 0/1 背包特性）。如果从前往后遍历，
 *      在计算 `dp[j]` 时使用的 `dp[j - num]` 可能已经是被放入过 `num` 的结果了。
 *
 * 5. 举例推导 dp 数组:
 *    - 见下方详细讲解。
 *
 * 最终判断:
 * - 如果 `dp[target]` 的值等于 `target`，说明我们成功找到了一个子集，其和恰好为 `target`，返回 `true`。
 * - 否则，返回 `false`。
 */
class Solution {
    public boolean canPartition(int[] nums) {
        // 01背包问题变体

        int sum = 0;
        // 计算数组总和
        for (int num : nums) {
            sum += num;
        }

        // 如果总和为奇数，则不可能分割成两个和相等的子集
        if (sum % 2 != 0) {
            return false;
        }

        // 计算目标和 (背包容量)
        int target = sum / 2;

        // 1. 确定dp数组及含义：dp[j] 表示容量为 j 时能凑出的最大子集和
        int[] dp = new int[target + 1]; // 大小为 target + 1，索引从 0 到 target

        // 3. 初始化dp数组：默认初始化为 0 即可

        // 4. 确定遍历顺序：先遍历物品，再倒序遍历背包容量
        for (int num : nums) { // 遍历每个数字 (物品)
            // 内层循环：倒序遍历背包容量
            for (int j = target; j >= num; j--) {
                // 2. 确定递推公式
                // 对于容量 j，可以选择不放入 num (dp[j] 不变)，
                // 或者放入 num (如果 j >= num)，此时最大和为 dp[j-num] + num
                dp[j] = Math.max(dp[j], dp[j - num] + num);
            }
            // 内层循环结束后，dp 数组更新了考虑当前 num 后的状态
        }

        // 5. 结果判断：检查容量为 target 的背包是否正好装满了价值 target
        // 如果 dp[target] == target，说明找到了和为 target 的子集
        return dp[target] == target;
    }
}
```

**结合示例和代码进行详细讲解说明 (动态规划五部曲)**

**示例 1：`nums = [1, 5, 11, 5]`**

1.  **计算总和与目标:**
    *   `sum = 1 + 5 + 11 + 5 = 22`
    *   `sum` 是偶数。
    *   `target = sum / 2 = 22 / 2 = 11`

2.  **初始化 DP 数组:**
    *   `dp` 数组大小为 `target + 1 = 12`。
    *   `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` (索引 0 到 11)

3.  **遍历与状态转移:**

    *   **处理 `num = 1`:**
        *   `j` 从 11 倒序到 1。
        *   `j=11`: `dp[11] = max(dp[11], dp[10]+1) = max(0, 0+1) = 1`
        *   `j=10`: `dp[10] = max(dp[10], dp[9]+1) = max(0, 0+1) = 1`
        *   ...
        *   `j=1`: `dp[1] = max(dp[1], dp[0]+1) = max(0, 0+1) = 1`
        *   `dp` 变为: `[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`

    *   **处理 `num = 5`:**
        *   `j` 从 11 倒序到 5。
        *   `j=11`: `dp[11] = max(dp[11], dp[11-5]+5) = max(1, dp[6]+5) = max(1, 1+5) = 6`
        *   `j=10`: `dp[10] = max(dp[10], dp[10-5]+5) = max(1, dp[5]+5) = max(1, 1+5) = 6`
        *   `j=9`: `dp[9] = max(dp[9], dp[9-5]+5) = max(1, dp[4]+5) = max(1, 1+5) = 6`
        *   `j=8`: `dp[8] = max(dp[8], dp[8-5]+5) = max(1, dp[3]+5) = max(1, 1+5) = 6`
        *   `j=7`: `dp[7] = max(dp[7], dp[7-5]+5) = max(1, dp[2]+5) = max(1, 1+5) = 6`
        *   `j=6`: `dp[6] = max(dp[6], dp[6-5]+5) = max(1, dp[1]+5) = max(1, 1+5) = 6`
        *   `j=5`: `dp[5] = max(dp[5], dp[5-5]+5) = max(1, dp[0]+5) = max(1, 0+5) = 5`
        *   `dp` 变为: `[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 6]`

    *   **处理 `num = 11`:**
        *   `j` 从 11 倒序到 11。
        *   `j=11`: `dp[11] = max(dp[11], dp[11-11]+11) = max(6, dp[0]+11) = max(6, 0+11) = 11`
        *   `dp` 变为: `[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 11]`

    *   **处理 `num = 5` (第二个 5):**
        *   `j` 从 11 倒序到 5。
        *   `j=11`: `dp[11]` 已经是 11，`max(11, dp[6]+5) = max(11, 6+5) = 11`
        *   `j=10`: `dp[10] = max(dp[10], dp[10-5]+5) = max(6, dp[5]+5) = max(6, 5+5) = 10`
        *   `j=9`: `dp[9] = max(dp[9], dp[9-5]+5) = max(6, dp[4]+5) = max(6, 1+5) = 6`
        *   `j=8`: `dp[8] = max(dp[8], dp[8-5]+5) = max(6, dp[3]+5) = max(6, 1+5) = 6`
        *   `j=7`: `dp[7] = max(dp[7], dp[7-5]+5) = max(6, dp[2]+5) = max(6, 1+5) = 6`
        *   `j=6`: `dp[6]` 已经是 6，`max(6, dp[1]+5) = max(6, 1+5) = 6`
        *   `j=5`: `dp[5]` 已经是 5，`max(5, dp[0]+5) = max(5, 0+5) = 5`
        *   `dp` 变为: `[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 10, 11]`

4.  **最终判断:**
    *   `dp[target] = dp[11] = 11`
    *   因为 `dp[target] == target` (11 == 11)，所以返回 `true`。

**示例 2：`nums = [1, 2, 3, 5]`**

1.  **计算总和与目标:**
    *   `sum = 1 + 2 + 3 + 5 = 11`
    *   `sum` 是奇数，直接返回 `false`。

这个过程清晰地展示了如何将分割等和子集问题转化为 0/1 背包问题，并利用动态规划求解。核心在于 `dp` 数组的定义、递推公式的正确应用以及内外层循环（特别是内层倒序）的遍历顺序。











---







## 力扣1049. 最后一块石头的重量 II
已解答
中等

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

 

示例 1：

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

示例 2：

输入：stones = [31,26,33,21,40]
输出：5
 

提示：

1 <= stones.length <= 30
1 <= stones[i] <= 100








### 0/1 背包问题变种，一维解法，无注释




```JAVA


class Solution {
    public int lastStoneWeightII(int[] stones) {
        // 01背包问题变体


        int sum=0;

        for( int n : stones ) {

            sum += n;

        }


        int target = sum / 2;

        int dp[] = new int[target+1];


        for( int i=0; i < stones.length; i++ ) { 

            for( int j=target; j >= stones[i] ; j-- ) {

                dp[j] = Math.max( dp[j], stones[i] + dp[ j - stones[i] ] );

            }

        }



        return sum - dp[target] - dp[target];
        /**最后dp[target]里是容量为target的背包所能背的最大重量。
        那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。
        在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的。
        那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。 */
                


    }
}


```








### 0/1 背包问题变种，一维解法，注释版




数据结构与算法学习记录.md

动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

命令：

1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明






好的，我们来结合动态规划五部曲，为你提供的 LeetCode 1049 "最后一块石头的重量 II" 问题的 Java 代码添加详细注释，并进行讲解。

```java
/**
 * LeetCode 1049: 最后一块石头的重量 II
 *
 * 问题描述：
 * 有一堆石头，重量分别为 stones[i]。每次选两块石头 x 和 y (x <= y) 粉碎。
 * 若 x == y，两块都消失；若 x != y，留下重量为 y - x 的新石头。
 * 目标是求最后剩下石头的最小可能重量（如果没有剩下，则为 0）。
 *
 * 解题思路总结 (动态规划 - 0/1 背包问题变种):
 * 1. 问题转化：
 *    - 石头粉碎的过程，无论顺序如何，最终结果等价于将所有石头分成两堆，记为 A 和 B。
 *    - 每次粉碎相当于从两堆中各取一个石头进行操作，或者在同一堆内操作。
 *    - 最终剩下的石头重量 = |sum(A) - sum(B)|，即两堆石头重量总和之差的绝对值。
 *    - 我们的目标是最小化这个差值 |sum(A) - sum(B)|。
 * 2. 转化为背包问题：
 *    - 设所有石头的总重量为 sum。则 sum(A) + sum(B) = sum。
 *    - 我们要最小化 |sum(A) - (sum - sum(A))| = |2 * sum(A) - sum|。
 *    - 要使这个差值最小，sum(A) 需要尽可能地接近 sum / 2。
 *    - 问题转化为：从 stones 数组中选取若干石头，使得它们的总重量尽可能接近 sum / 2，且不超过 sum / 2。
 *    - 这就是一个典型的 0/1 背包问题：
 *      - 背包容量 (Capacity): target = sum / 2
 *      - 物品 (Items): 每块石头 stones[i]
 *      - 物品重量 (Weight): stones[i]
 *      - 物品价值 (Value): stones[i] (我们希望装入背包的物品总重量最大)
 *    - 目标：求背包能装下的最大总重量。
 *
 * 动态规划五部曲：
 * 1. 确定 dp 数组以及下标的含义:
 *    - `dp[j]` 表示：背包容量为 j 时，能装下的石头的最大总重量。
 *
 * 2. 确定递推公式:
 *    - 对于每块石头 `stones[i]`（物品）：
 *    - 如果不放入背包（不选这块石头），则 `dp[j]` 保持不变。
 *    - 如果放入背包（前提是 `j >= stones[i]`），则 `dp[j]` 可以更新为 `dp[j - stones[i]] + stones[i]`。
 *    - 我们需要取这两种情况的最大值：`dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i])`。
 *
 * 3. dp 数组如何初始化:
 *    - `dp` 数组所有元素初始化为 0。`dp[0] = 0` 表示容量为 0 时最大重量为 0。
 *
 * 4. 确定遍历顺序:
 *    - 外层循环遍历物品（石头 `stones[i]`），从前到后。
 *    - 内层循环遍历背包容量 `j`，**必须从后往前**（从 `target` 到 `stones[i]`）。
 *      这是为了保证每块石头 `stones[i]` 只被考虑一次（符合 0/1 背包特性）。
 *
 * 5. 举例推导 dp 数组:
 *    - 见下方详细讲解。
 *
 * 最终结果计算:
 * - 经过动态规划计算，`dp[target]` 就是最接近 `sum / 2` 的那一堆石头的总重量 (sumA)。
 * - 另一堆石头的总重量是 `sumB = sum - dp[target]`。
 * - 最小剩余重量 = `sumB - sumA = (sum - dp[target]) - dp[target] = sum - 2 * dp[target]`。
 */
class Solution {
    public int lastStoneWeightII(int[] stones) {
        // 01背包问题变体

        int sum = 0;
        // 计算所有石头的总重量
        for (int stone : stones) {
            sum += stone;
        }

        // 计算背包的目标容量 (总重量的一半，向下取整)
        int target = sum / 2;

        // 1. 确定dp数组及含义：dp[j] 表示容量为 j 时能装下的最大石头重量
        int[] dp = new int[target + 1]; // 大小为 target + 1，索引从 0 到 target

        // 3. 初始化dp数组：默认初始化为 0 即可

        // 4. 确定遍历顺序：先遍历物品(石头)，再倒序遍历背包容量
        for (int stone : stones) { // 遍历每块石头 (物品)
            // 内层循环：倒序遍历背包容量
            for (int j = target; j >= stone; j--) {
                // 2. 确定递推公式
                // 对于容量 j，可以选择不放入 stone (dp[j] 不变)，
                // 或者放入 stone (如果 j >= stone)，此时最大重量为 dp[j-stone] + stone
                dp[j] = Math.max(dp[j], dp[j - stone] + stone);
            }
            // 内层循环结束后，dp 数组更新了考虑当前 stone 后的状态
        }

        // 5. 计算最终结果：
        // dp[target] 是最接近 sum/2 的那一堆石头的总重量 (sumA)
        // 另一堆的总重量是 sum - dp[target] (sumB)
        // 最小剩余重量 = sumB - sumA = (sum - dp[target]) - dp[target]
        return sum - 2 * dp[target];
        /**最后dp[target]里是容量为target的背包所能背的最大重量。
        那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。
        在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的。
        那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。 */
    }
}
```

**结合示例和代码进行详细讲解说明 (动态规划五部曲)**

**示例 1：`stones = [2, 7, 4, 1, 8, 1]`**

1.  **计算总和与目标:**
    *   `sum = 2 + 7 + 4 + 1 + 8 + 1 = 23`
    *   `target = sum / 2 = 23 / 2 = 11` (整数除法，向下取整)

2.  **初始化 DP 数组:**
    *   `dp` 数组大小为 `target + 1 = 12`。
    *   `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` (索引 0 到 11)

3.  **遍历与状态转移:**

    *   **处理 `stone = 2`:**
        *   `j` 从 11 倒序到 2。
        *   `j=11`: `dp[11] = max(dp[11], dp[9]+2) = max(0, 0+2) = 2`
        *   ...
        *   `j=2`: `dp[2] = max(dp[2], dp[0]+2) = max(0, 0+2) = 2`
        *   `dp` 变为: `[0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]`

    *   **处理 `stone = 7`:**
        *   `j` 从 11 倒序到 7。
        *   `j=11`: `dp[11] = max(dp[11], dp[4]+7) = max(2, 2+7) = 9`
        *   `j=10`: `dp[10] = max(dp[10], dp[3]+7) = max(2, 2+7) = 9`
        *   `j=9`: `dp[9] = max(dp[9], dp[2]+7) = max(2, 2+7) = 9`
        *   `j=8`: `dp[8] = max(dp[8], dp[1]+7) = max(2, 0+7) = 7`
        *   `j=7`: `dp[7] = max(dp[7], dp[0]+7) = max(2, 0+7) = 7`
        *   `dp` 变为: `[0, 0, 2, 2, 2, 2, 2, 7, 7, 9, 9, 9]`

    *   **处理 `stone = 4`:**
        *   `j` 从 11 倒序到 4。
        *   `j=11`: `dp[11] = max(dp[11], dp[7]+4) = max(9, 7+4) = 11`
        *   `j=10`: `dp[10] = max(dp[10], dp[6]+4) = max(9, 2+4) = 9` (注意 dp[6] 还是上一轮的值 2)
        *   `j=9`: `dp[9] = max(dp[9], dp[5]+4) = max(9, 2+4) = 9`
        *   `j=8`: `dp[8] = max(dp[8], dp[4]+4) = max(7, 2+4) = 7`
        *   `j=7`: `dp[7] = max(dp[7], dp[3]+4) = max(7, 2+4) = 7`
        *   `j=6`: `dp[6] = max(dp[6], dp[2]+4) = max(2, 2+4) = 6`
        *   `j=5`: `dp[5] = max(dp[5], dp[1]+4) = max(2, 0+4) = 4`
        *   `j=4`: `dp[4] = max(dp[4], dp[0]+4) = max(2, 0+4) = 4`
        *   `dp` 变为: `[0, 0, 2, 2, 4, 4, 6, 7, 7, 9, 9, 11]`

    *   **处理 `stone = 1`:**
        *   `j` 从 11 倒序到 1。
        *   `j=11`: `dp[11] = max(dp[11], dp[10]+1) = max(11, 9+1) = 11`
        *   `j=10`: `dp[10] = max(dp[10], dp[9]+1) = max(9, 9+1) = 10`
        *   ... (以此类推)
        *   `dp` 变为: `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]`

    *   **处理 `stone = 8`:**
        *   `j` 从 11 倒序到 8。
        *   `j=11`: `dp[11] = max(dp[11], dp[3]+8) = max(11, 3+8) = 11`
        *   `j=10`: `dp[10] = max(dp[10], dp[2]+8) = max(10, 2+8) = 10`
        *   `j=9`: `dp[9] = max(dp[9], dp[1]+8) = max(9, 1+8) = 9`
        *   `j=8`: `dp[8] = max(dp[8], dp[0]+8) = max(8, 0+8) = 8`
        *   `dp` 保持不变: `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]`

    *   **处理 `stone = 1`:**
        *   `j` 从 11 倒序到 1。
        *   `j=11`: `dp[11] = max(dp[11], dp[10]+1) = max(11, 10+1) = 11`
        *   ... (其他值也不会改变)
        *   `dp` 保持不变: `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]`

4.  **最终计算结果:**
    *   `dp[target] = dp[11] = 11`
    *   最小剩余重量 = `sum - 2 * dp[target] = 23 - 2 * 11 = 23 - 22 = 1`

**输出:**

`1`

这个过程展示了如何将问题转化为 0/1 背包模型，并使用动态规划找到最接近 `sum / 2` 的子集和，从而计算出最小的剩余石头重量。




---



















## 力扣494. 目标和
已解答
中等

给你一个非负整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

 

示例 1：

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

示例 2：

输入：nums = [1], target = 1
输出：1
 

提示：

1 <= nums.length <= 20
0 <= nums[i] <= 1000
0 <= sum(nums[i]) <= 1000
-1000 <= target <= 1000










### 0/1 背包问题变种，二维解法，无注释




```JAVA


class Solution {
    public int findTargetSumWays(int[] nums, int target) {

        int sum=0;

        for( int num : nums ) {

            sum += num;

        }

        // 注意nums[i] >= 0的题目条件，意味着sum也是所有nums[i]的绝对值之和
        // 这里保证了sum + target一定是大于等于零的，也就是left大于等于零（毕竟我们定义left大于right）
        if(sum < Math.abs(target)){
            return 0;
        }

        int bigSize=0;

        if( ( sum + target ) % 2 == 0  ) {

            bigSize = ( sum + target ) / 2;

        }
        else{

            return 0;
        }


        int dp[][] = new int[nums.length+1][bigSize+1]; 

        for( int j=0; j <= bigSize; j++ ) {

            if( j == nums[0] ) {

                dp[0][j] = 1;
            }
            else {

                dp[0][j] = 0;
            }

        }

        for( int i=0; i < nums.length; i++ ) {

            dp[i][0] = 0;
        }

        
        // 初始化最左列（dp[i][0])
        // 当从nums数组的索引0到i的部分有n个0时（n > 0)，每个0可以取+/-，因此有2的n次方中可以取到j = 0的方案
        // n = 0说明当前遍历到的数组部分没有0全为正数，因此只有一种方案可以取到j = 0（就是所有数都不取）
        int numZeros = 0;
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] == 0) {
                numZeros++;
            }
            dp[i][0] = (int) Math.pow(2, numZeros);

        }




        for( int i=1; i < nums.length; i++ ) {

            for( int j=1; j <= bigSize; j++ ) {


                if( j >= nums[i] ) {

                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]];

                }
                else {

                    dp[i][j] = dp[i-1][j];

                }

            }
        }


        
        return dp[nums.length-1][bigSize];






        
    }
}


```







### 0/1 背包问题变种，二维解法，注释版


动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组


命令：

1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。
2.结合示例和代码进行详细讲解说明









好的，我们来结合动态规划五部曲，为你提供的 LeetCode 494 "目标和" 问题的 Java 代码（二维 DP 解法）添加详细注释，并进行讲解。

```java
/**
 * LeetCode 494: 目标和
 *
 * 问题描述：
 * 给你一个非负整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 '+' 或 '-' ，
 * 然后串联起所有整数，构造一个表达式。返回可以通过上述方法构造的、运算结果等于 target 的不同表达式的数目。
 *
 * 解题思路总结 (动态规划 - 0/1 背包问题变种):
 * 1. 问题转化：
 *    - 假设所有添加 '+' 号的元素集合为 P，添加 '-' 号的元素集合为 N。
 *    - 我们要找的是 sum(P) - sum(N) = target。
 *    - 同时我们知道 sum(P) + sum(N) = sum(nums) (记为 sum)。
 *    - 将两个等式相加：2 * sum(P) = target + sum。
 *    - 因此，sum(P) = (target + sum) / 2。
 *    - 问题转化为：从 nums 数组中选取若干元素，使得它们的和恰好等于 (target + sum) / 2。
 *    - 这就是一个典型的 0/1 背包问题变种：
 *      - 背包容量 (Capacity): bagSize = (target + sum) / 2
 *      - 物品 (Items): 数组中的每个元素 nums[i]
 *      - 物品重量 (Weight): nums[i]
 *      - 物品价值 (Value): nums[i] (虽然这里更关心的是“组合数量”而不是“最大价值”)
 *    - 目标：求恰好装满容量为 bagSize 的背包有多少种不同的组合方式。
 *
 * 动态规划五部曲 (二维 DP):
 * 1. 确定 dp 数组以及下标的含义:
 *    - `dp[i][j]` 表示：使用数组 `nums` 中前 `i` 个元素（下标 0 到 i-1），凑成和为 `j` 的不同组合方式的数量。
 *    - 注意：这里的 `i` 对应物品的数量，`j` 对应背包的容量（目标和）。
 *
 * 2. 确定递推公式:
 *    - 考虑第 `i` 个元素 `nums[i-1]` (因为数组下标从 0 开始):
 *    - 如果不选择 `nums[i-1]`：那么凑成和为 `j` 的方式数量等于使用前 `i-1` 个元素凑成和为 `j` 的数量，即 `dp[i-1][j]`。
 *    - 如果选择 `nums[i-1]`（前提是 `j >= nums[i-1]`）：那么凑成和为 `j` 的方式数量等于使用前 `i-1` 个元素凑成和为 `j - nums[i-1]` 的数量，即 `dp[i-1][j - nums[i-1]]`。
 *    - 因此，总的方式数量是这两种情况之和：
 *      `dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[i-1]]`  (当 `j >= nums[i-1]`)
 *      `dp[i][j] = dp[i-1][j]`                          (当 `j < nums[i-1]`)
 *
 * 3. dp 数组如何初始化:
 *    - `dp[0][0] = 1`：表示不使用任何元素（前 0 个），凑成和为 0 的方式有 1 种（即空集）。
 *    - `dp[i][0]` (i > 0)：表示使用前 `i` 个元素凑成和为 0 的方式数量。这需要特别处理 `nums` 中的 0。如果前 `i` 个元素中有 `k` 个 0，那么每个 0 可以选 (+0) 或不选 (-0)，有 `2^k` 种方式凑成 0。代码中对此进行了处理。
 *    - `dp[0][j]` (j > 0)：表示不使用任何元素凑成正数和 `j`，方式数量为 0。
 *
 * 4. 确定遍历顺序:
 *    - 先遍历物品（外层循环 `i` 从 1 到 `nums.length`）。
 *    - 再遍历背包容量（内层循环 `j` 从 0 到 `bagSize`）。
 *
 * 5. 举例推导 dp 数组:
 *    - 见下方详细讲解。
 *
 * 最终结果:
 * - `dp[nums.length][bagSize]` 就是使用所有 `nums` 元素凑成和为 `bagSize` 的方式数量。
 */
class Solution {
    public int findTargetSumWays(int[] nums, int target) {

        int sum = 0;
        // 计算数组元素的总和
        for (int num : nums) {
            sum += num;
        }

        // 预检查：如果目标绝对值大于总和，或者 (sum + target) 不是偶数，则无法达到
        // 注意nums[i] >= 0的题目条件，意味着sum也是所有nums[i]的绝对值之和
        // 1. 如果 sum < |target|，说明即使所有数都取正号或负号，也无法达到 target 的绝对值。
        // 2. 因为 sum(P) = (target + sum) / 2，sum(P) 必须是非负整数。
        //    - target + sum 必须是非负数 (因为 sum >= |target|)
        //    - target + sum 必须是偶数
        if (sum < Math.abs(target) || (sum + target) % 2 != 0) {
            return 0; // 不存在满足条件的组合
        }

        // 计算目标背包容量 (需要凑成的正数子集和)
        int bagSize = (sum + target) / 2;
        if (bagSize < 0) { // 理论上在上面的检查后不会发生，但作为健壮性检查
             return 0;
        }


        // 1. 定义 dp 数组：dp[i][j] 表示用前 i 个数凑成和为 j 的方法数
        // 行数 i: 0 到 nums.length (共 nums.length + 1 行)
        // 列数 j: 0 到 bagSize (共 bagSize + 1 列)
        int[][] dp = new int[nums.length + 1][bagSize + 1];

        // 3. 初始化 dp 数组
        // dp[0][0] = 1: 不用任何数凑成和 0 的方法有 1 种 (空集)
        dp[0][0] = 1;
        // dp[0][j] (j>0) 默认为 0: 不用任何数凑成正数和的方法为 0 种
        // dp[i][0] (i>0) 需要根据 nums[0...i-1] 中 0 的个数确定，但递推公式可以处理，无需特殊初始化

        /*
        // --- 另一种处理 0 的初始化方式 (注释掉，因为递推可以处理) ---
        // 初始化第一列 dp[i][0]
        // 当从nums数组的索引0到i-1的部分有k个0时（k >= 0)，每个0可以取+/-，因此有2的k次方种可以取到j = 0的方案
        int numZeros = 0;
        for(int i = 1; i <= nums.length; i++) {
            if(nums[i-1] == 0) {
                numZeros++;
            }
            // 如果 nums[i-1] 是 0，凑成 0 的方法数翻倍 (选+0或-0)
            // 否则，凑成 0 的方法数不变 (只能不选非零数)
            // 这里假设 dp[i][0] 依赖 dp[i-1][0]，更简洁的方式是在递推中处理
            // dp[i][0] = (int) Math.pow(2, numZeros); // 这种计算方式假设只考虑0，不准确
            // 正确的初始化应该在递推中体现
        }
        // --- 结束注释掉的初始化 ---
        */


        // 4. 确定遍历顺序：先物品后背包
        for (int i = 1; i <= nums.length; i++) { // 遍历物品 (nums[i-1])
            int currentNum = nums[i - 1]; // 当前考虑的数字
            for (int j = 0; j <= bagSize; j++) { // 遍历背包容量

                // 2. 确定递推公式
                // 不选择当前数字 nums[i-1] 的方法数
                int waysWithoutCurrent = dp[i - 1][j];

                // 选择当前数字 nums[i-1] 的方法数 (前提是 j >= currentNum)
                int waysWithCurrent = 0;
                if (j >= currentNum) {
                    waysWithCurrent = dp[i - 1][j - currentNum];
                }

                // 总方法数是两种情况之和
                dp[i][j] = waysWithoutCurrent + waysWithCurrent;
            }
        }

        // 5. 返回结果：使用所有 nums.length 个数，凑成和为 bagSize 的方法数
        return dp[nums.length][bagSize];
    }
}
```

**结合示例和代码进行详细讲解说明 (动态规划五部曲)**

**示例 1：`nums = [1, 1, 1, 1, 1]`, `target = 3`**

1.  **计算总和与目标背包容量:**
    *   `sum = 1 + 1 + 1 + 1 + 1 = 5`
    *   检查: `sum >= abs(target)` (5 >= 3) 成立。 `(sum + target) % 2 == (5 + 3) % 2 == 8 % 2 == 0` 成立。
    *   `bagSize = (sum + target) / 2 = (5 + 3) / 2 = 4`
    *   目标：从 `nums` 中选出若干个 1，使得它们的和等于 4。

2.  **初始化 DP 数组:**
    *   `dp` 数组大小为 `(5 + 1) x (4 + 1)` 即 `6 x 5`。
    *   `dp[0][0] = 1`。其他 `dp[0][j]` (j>0) 为 0。
    *   `dp` 初始状态 (第 0 行): `[1, 0, 0, 0, 0]`

3.  **遍历与状态转移:**

    *   **i = 1 (处理第一个 `num = 1`):**
        *   `j=0`: `dp[1][0] = dp[0][0] + dp[0][0-1]` (无效) `= dp[0][0] = 1`
        *   `j=1`: `dp[1][1] = dp[0][1] + dp[0][1-1] = 0 + dp[0][0] = 1`
        *   `j=2`: `dp[1][2] = dp[0][2] + dp[0][2-1] = 0 + dp[0][1] = 0`
        *   `j=3`: `dp[1][3] = dp[0][3] + dp[0][3-1] = 0 + dp[0][2] = 0`
        *   `j=4`: `dp[1][4] = dp[0][4] + dp[0][4-1] = 0 + dp[0][3] = 0`
        *   `dp` 第 1 行: `[1, 1, 0, 0, 0]`

    *   **i = 2 (处理第二个 `num = 1`):**
        *   `j=0`: `dp[2][0] = dp[1][0] + dp[1][0-1]` (无效) `= dp[1][0] = 1`
        *   `j=1`: `dp[2][1] = dp[1][1] + dp[1][1-1] = 1 + dp[1][0] = 1 + 1 = 2`
        *   `j=2`: `dp[2][2] = dp[1][2] + dp[1][2-1] = 0 + dp[1][1] = 0 + 1 = 1`
        *   `j=3`: `dp[2][3] = dp[1][3] + dp[1][3-1] = 0 + dp[1][2] = 0 + 0 = 0`
        *   `j=4`: `dp[2][4] = dp[1][4] + dp[1][4-1] = 0 + dp[1][3] = 0 + 0 = 0`
        *   `dp` 第 2 行: `[1, 2, 1, 0, 0]`

    *   **i = 3 (处理第三个 `num = 1`):**
        *   `j=0`: `dp[3][0] = dp[2][0] = 1`
        *   `j=1`: `dp[3][1] = dp[2][1] + dp[2][0] = 2 + 1 = 3`
        *   `j=2`: `dp[3][2] = dp[2][2] + dp[2][1] = 1 + 2 = 3`
        *   `j=3`: `dp[3][3] = dp[2][3] + dp[2][2] = 0 + 1 = 1`
        *   `j=4`: `dp[3][4] = dp[2][4] + dp[2][3] = 0 + 0 = 0`
        *   `dp` 第 3 行: `[1, 3, 3, 1, 0]`

    *   **i = 4 (处理第四个 `num = 1`):**
        *   `j=0`: `dp[4][0] = dp[3][0] = 1`
        *   `j=1`: `dp[4][1] = dp[3][1] + dp[3][0] = 3 + 1 = 4`
        *   `j=2`: `dp[4][2] = dp[3][2] + dp[3][1] = 3 + 3 = 6`
        *   `j=3`: `dp[4][3] = dp[3][3] + dp[3][2] = 1 + 3 = 4`
        *   `j=4`: `dp[4][4] = dp[3][4] + dp[3][3] = 0 + 1 = 1`
        *   `dp` 第 4 行: `[1, 4, 6, 4, 1]`

    *   **i = 5 (处理第五个 `num = 1`):**
        *   `j=0`: `dp[5][0] = dp[4][0] = 1`
        *   `j=1`: `dp[5][1] = dp[4][1] + dp[4][0] = 4 + 1 = 5`
        *   `j=2`: `dp[5][2] = dp[4][2] + dp[4][1] = 6 + 4 = 10`
        *   `j=3`: `dp[5][3] = dp[4][3] + dp[4][2] = 4 + 6 = 10`
        *   `j=4`: `dp[5][4] = dp[4][4] + dp[4][3] = 1 + 4 = 5`
        *   `dp` 第 5 行: `[1, 5, 10, 10, 5]`

4.  **最终结果:**
    *   `dp[nums.length][bagSize] = dp[5][4] = 5`

**输出:**

`5`

这个过程展示了如何将目标和问题转化为 0/1 背包计数问题，并使用二维动态规划求解。`dp[i][j]` 存储了到达该状态的方法数，通过累加不选当前数和选当前数（如果容量足够）的方法数来进行状态转移。





### 我的解法里，i=0表示物品0 ，你的解法里i=0不表示物品，i=1开始表示物品。讲解一下我的解法和你修改后的解法有哪些不同？你的解法有什么优点？



好的，我们来详细对比一下你在 <mcfile name="数据结构与算法学习记录.md" path="a:\study\学习笔记\数据结构与算法学习记录.md"></mcfile> 中 LeetCode 494 "目标和" 问题的原始二维 DP 解法（无注释版）和你参考的、我添加了注释的修改后解法，特别是关于索引 `i` 的含义和用法。

**核心区别：`dp[i][j]` 中索引 `i` 的含义**

*   **你的原始解法 (无注释版):**
    *   从代码逻辑（特别是初始化和循环）来看，`dp[i][j]` 似乎试图表示**考虑了 `nums` 数组中下标从 0 到 `i` 的元素**后，凑成和为 `j` 的方法数。
    *   因此，`i=0` 对应的是只考虑了 `nums[0]` 这个元素之后的状态。
    *   这种定义方式相对不标准，并且导致了复杂的初始化逻辑（需要单独处理 `nums[0]`，还要循环处理 `dp[i][0]` 的情况）。
    *   循环 `for( int i=1; i < nums.length; i++ )` 和返回 `dp[nums.length-1][bigSize]` 也印证了这一点，即 `i` 最大只到 `nums.length-1`，对应考虑完最后一个元素 `nums[nums.length-1]`。

*   **修改后的解法 (注释版):**
    *   `dp[i][j]` 的含义是：使用 `nums` 数组中**前 `i` 个元素**（即下标从 0 到 `i-1` 的元素），凑成和为 `j` 的方法数。
    *   因此，`i=0` 表示**不使用任何元素**（前 0 个元素）的状态，这是一个非常自然的**边界/初始状态**。
    *   `i=1` 表示只考虑第一个元素 `nums[0]` 之后的状态。
    *   `i=nums.length` 表示考虑了所有 `nums.length` 个元素之后的状态。
    *   这是 0/1 背包问题二维 DP 的**标准定义方式**。

**具体不同点分析：**

1.  **DP 数组大小与使用:**
    *   **原始:** 声明了 `nums.length + 1` 行，但实际循环和返回只用到了 `0` 到 `nums.length - 1` 行。第 `nums.length` 行没有被有效利用。
    *   **修改后:** 声明了 `nums.length + 1` 行，并且有效利用了所有行。第 0 行作为初始状态，第 `nums.length` 行存储最终结果。

2.  **初始化:**
    *   **原始:** 初始化非常复杂，分了多个步骤：
        *   尝试根据 `nums[0]` 初始化 `dp[0][...]`。
        *   将 `dp[i][0]` 设为 0。
        *   根据 `nums` 中 0 的数量重新计算 `dp[i][0]`。
        *   这种方式容易出错，且逻辑不够清晰，没有很好地利用 DP 的递推性质。
    *   **修改后:** 初始化极其简单：
        *   `dp[0][0] = 1;` // 不用任何数凑成和 0 的方法只有 1 种（空集）。
        *   其他所有 `dp[0][j]` (j>0) 默认为 0。
        *   所有 `dp[i][0]` 的值会在后续的递推过程中根据 `dp[i-1][0]` 和 `nums[i-1]` 是否为 0 自然计算出来，无需特殊初始化循环。

3.  **状态转移循环:**
    *   **原始:**
        *   外层循环 `i` 从 `1` 到 `nums.length - 1`。
        *   递推 `dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]`。这里用 `nums[i]` 对应 `dp[i]`，索引关系不直观。
        *   由于循环终点是 `nums.length - 1`，实际上最后一个元素 `nums[nums.length-1]` 没有参与到 `nums[i]` 这个角色中去影响后续状态（它只作为 `dp[nums.length-1]` 的计算基础）。
    *   **修改后:**
        *   外层循环 `i` 从 `1` 到 `nums.length`。
        *   递推 `dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]`。这里用 `nums[i-1]` (第 `i` 个元素) 影响 `dp[i]` (考虑前 `i` 个元素的状态)，索引关系清晰且符合定义。
        *   循环到 `nums.length` 保证了所有元素都按顺序参与了状态转移。

4.  **结果返回:**
    *   **原始:** `return dp[nums.length-1][bigSize];` 返回的是考虑了前 `n-1` 个元素（下标 0 到 n-1）的状态。
    *   **修改后:** `return dp[nums.length][bigSize];` 返回的是考虑了所有 `n` 个元素（前 `n` 个）的状态，这才是最终答案。

**修改后解法的优点：**

1.  **遵循标准范式:** 采用了 0/1 背包问题二维 DP 的标准状态定义和递推方式，代码更易于理解、学习和迁移到其他类似问题。
2.  **逻辑清晰简洁:** 状态定义清晰，初始化简单，递推关系明确，避免了原始解法中复杂的、可能引入错误的初始化步骤。
3.  **代码更健壮:** 正确处理了边界条件（`i=0`, `j=0`）和所有元素，确保了计算的完整性和最终结果的正确性。
4.  **易于维护和调试:** 标准化的结构使得代码更容易阅读、修改和调试。

总而言之，修改后的解法通过采用标准的 DP 状态定义（让 `i=0` 表示初始状态），极大地简化了代码逻辑，提高了代码的可读性、健壮性和规范性。




---

















































































































































































## 











































































































































































































































## 











































































































































































































































## 力扣198. 打家劫舍
已解答
中等

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
 

提示：

1 <= nums.length <= 100
0 <= nums[i] <= 400






### dp-JAVA-无注释

```JAVA


class Solution {
    public int rob(int[] nums) {


        if( nums.length == 0 ) {

            return 0;
        }

        if( nums.length == 1 ) {

            return nums[0];
        }



        int dp[] = new int[nums.length+1];

        dp[0] = nums[0];

        dp[1] = Math.max( nums[0], nums[1] );


        for( int i=2; i < nums.length; i++ ) {

            dp[i] = Math.max( dp[i-1], nums[i] + dp[i-2] );

        }



        return dp[nums.length-1];
        

        
    }
}


```






### dp-JAVA-注释版





动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义

2. 确定递推公式

3. dp数组如何初始化

4. 确定遍历顺序

5. 举例推导dp数组

命令：

1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明







好的，我们来结合动态规划五部曲，为你提供的 LeetCode 198 "打家劫舍" 问题的 Java 代码添加详细注释，并进行讲解。

首先，对你的代码进行微调，使 `dp` 数组的大小和索引与房屋索引更直观地对应。`dp[i]` 将表示偷窃到第 `i` 间房屋（包括第 `i` 间）时能获得的最大金额。

```java
/**
 * LeetCode 198: 打家劫舍
 *
 * 问题描述：
 * 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，
 * 相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
 * 给定一个代表每个房屋存放金额的非负整数数组 nums，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
 *
 * 解题思路总结 (动态规划):
 * 1. 确定 dp 数组以及下标的含义:
 *    - `dp[i]` 表示：考虑下标从 0 到 i 的房屋，所能偷窃到的最高总金额。
 *    - 注意：`dp[i]` 的计算结果并不一定意味着第 i 间房屋必须被偷窃。
 *
 * 2. 确定递推公式:
 *    - 对于第 i 间房屋，有两种选择：
 *      a) 偷窃第 i 间房屋 (`nums[i]`)：
 *         - 由于不能偷窃相邻的房屋，所以不能偷窃第 i-1 间。
 *         - 最大金额为偷窃到第 i-2 间房屋的最大金额加上第 i 间的金额：`dp[i-2] + nums[i]`。
 *      b) 不偷窃第 i 间房屋 (`nums[i]`)：
 *         - 最大金额等于偷窃到第 i-1 间房屋的最大金额：`dp[i-1]`。
 *    - 因此，`dp[i]` 应该取这两种情况中的最大值：
 *      `dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])`
 *
 * 3. dp 数组如何初始化:
 *    - `dp[0]`: 只有一间房屋时，最大金额就是 `nums[0]`。所以 `dp[0] = nums[0]`。
 *    - `dp[1]`: 有两间房屋时，不能同时偷。最大金额是 `max(nums[0], nums[1])`。所以 `dp[1] = Math.max(nums[0], nums[1])`。
 *    - 需要处理 `nums` 数组长度为 0 或 1 的边界情况。
 *
 * 4. 确定遍历顺序:
 *    - 从前往后遍历。`dp[i]` 依赖于 `dp[i-1]` 和 `dp[i-2]`，所以需要先计算出前面的值。
 *    - 循环从 `i = 2` 开始，直到 `nums.length - 1`。
 *
 * 5. 举例推导 dp 数组:
 *    - 见下方详细讲解。
 *
 * 最终结果:
 * - 偷窃完所有房屋后，能获得的最大金额存储在 `dp[nums.length - 1]` 中。
 */
class Solution {
    public int rob(int[] nums) {

        // 处理边界情况：没有房屋
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // 处理边界情况：只有一间房屋
        if (nums.length == 1) {
            return nums[0];
        }

        // 1. 定义 dp 数组：dp[i] 表示偷窃到第 i 间房屋（包括第 i 间）能获得的最大金额
        // 数组大小为 nums.length，索引 0 到 nums.length - 1 对应房屋索引
        int[] dp = new int[nums.length];

        // 3. 初始化 dp 数组
        // 偷窃第 0 间房的最大金额
        dp[0] = nums[0];
        // 偷窃到第 1 间房的最大金额，不能同时偷 0 和 1
        dp[1] = Math.max(nums[0], nums[1]);

        // 4. 确定遍历顺序：从第 2 间房屋开始遍历 (索引 i = 2)
        for (int i = 2; i < nums.length; i++) {
            // 2. 确定递推公式
            // 选择偷第 i 间 (dp[i-2] + nums[i]) 或不偷第 i 间 (dp[i-1])
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        // 5. 返回结果：偷窃完所有房屋（到最后一间 nums.length - 1）的最大金额
        return dp[nums.length - 1];
    }
}
```

**结合示例和代码进行详细讲解说明 (动态规划五部曲)**

**示例 2：`nums = [2, 7, 9, 3, 1]`**

1.  **确定 dp 数组及含义:**
    *   `dp[i]` 表示偷窃到第 `i` 间房屋（包括第 `i` 间）时能获得的最大金额。
    *   `dp` 数组大小为 5。

2.  **确定递推公式:**
    *   `dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])`

3.  **初始化 dp 数组:**
    *   `nums.length = 5`，不满足长度为 0 或 1 的边界条件。
    *   `dp[0] = nums[0] = 2`
    *   `dp[1] = Math.max(nums[0], nums[1]) = Math.max(2, 7) = 7`
    *   `dp` 初始状态: `[2, 7, ?, ?, ?]`

4.  **确定遍历顺序:** 从 `i = 2` 到 `4`。

5.  **举例推导 dp 数组:**

    *   **i = 2 (处理第三间房 `nums[2] = 9`):**
        *   `dp[2] = Math.max(dp[1], dp[0] + nums[2])`
        *   `dp[2] = Math.max(7, 2 + 9)`
        *   `dp[2] = Math.max(7, 11) = 11`
        *   `dp` 变为: `[2, 7, 11, ?, ?]`
        *   含义：偷到第 2 间房时，最大金额是 11（偷第 0 间和第 2 间）。

    *   **i = 3 (处理第四间房 `nums[3] = 3`):**
        *   `dp[3] = Math.max(dp[2], dp[1] + nums[3])`
        *   `dp[3] = Math.max(11, 7 + 3)`
        *   `dp[3] = Math.max(11, 10) = 11`
        *   `dp` 变为: `[2, 7, 11, 11, ?]`
        *   含义：偷到第 3 间房时，最大金额是 11（不偷第 3 间，保持偷第 0 和 2 间的方案）。

    *   **i = 4 (处理第五间房 `nums[4] = 1`):**
        *   `dp[4] = Math.max(dp[3], dp[2] + nums[4])`
        *   `dp[4] = Math.max(11, 11 + 1)`
        *   `dp[4] = Math.max(11, 12) = 12`
        *   `dp` 变为: `[2, 7, 11, 11, 12]`
        *   含义：偷到第 4 间房时，最大金额是 12（偷第 0、2、4 间）。

6.  **最终结果:**
    *   遍历结束，返回 `dp[nums.length - 1] = dp[4] = 12`。

**输出:**

`12`

这个过程清晰地展示了如何使用动态规划解决打家劫舍问题。`dp[i]` 记录了到达当前房屋时的最优解，通过比较“偷当前房屋”和“不偷当前房屋”两种策略，逐步构建出全局最优解。





---















## 力扣213. 打家劫舍 II
已解答
中等

提示
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：

输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：

输入：nums = [1,2,3]
输出：3
 

提示：

1 <= nums.length <= 100
0 <= nums[i] <= 1000









### dp-JAVA-无注释





```JAVA


class Solution {
    public int rob(int[] nums) {

        if( nums == null || nums.length == 0 ) {

            return 0;
        }

        if( nums.length == 1 ) {

            return nums[0];
        }


        int result1 = robRange( nums, 0, nums.length-2 );

        int result2 = robRange( nums, 1, nums.length-1 );


        int ret = Math.max( result1, result2 );
        
        return ret;
        
    }



    public int robRange(int[] nums, int start, int end) {
        

        int length = end-start+1;
        
        if( length == 0 ) {

            return 0;
        }

        if( length == 1 ) {

            return nums[start];
        }



        int dp[] = new int[nums.length+1];

        dp[start] = nums[start];

        dp[start+1] = Math.max( nums[start], nums[start+1] );


        for( int i = start+2; i <= end; i++ ) {

            dp[i] = Math.max( dp[i-1], nums[i] + dp[i-2] );

        }



        return dp[end];
        

        
    }


}


```











### dp-JAVA-注释版




动态规划五部曲

1. 确定dp数组（dp table）以及下标的含义

2. 确定递推公式

3. dp数组如何初始化

4. 确定遍历顺序

5. 举例推导dp数组

命令：

1.结合动态规划五部曲，在我的代码中，逐行嵌入详细注释说明，在类注释中嵌入解题思路总结，使其易于理解和复习。

2.结合示例和代码进行详细讲解说明







好的，我们来结合动态规划五部曲，为你提供的 LeetCode 213 "打家劫舍 II" 问题的 Java 代码添加详细注释，并进行讲解。

```java
/**
 * LeetCode 213: 打家劫舍 II
 *
 * 问题描述：
 * 房屋围成一圈，第一个房屋和最后一个房屋相邻。相邻房屋不能同时偷窃。
 * 计算在不触动警报的情况下，能偷窃到的最高金额。
 *
 * 解题思路总结 (动态规划):
 * 核心思想：由于第一个房屋和最后一个房屋不能同时偷窃，我们将环形问题分解为两个线性问题（打家劫舍 I）。
 *
 * 情况一：不偷窃最后一个房屋 (nums[n-1])。
 *    - 那么可偷窃的范围就变成了从下标 0 到 n-2 的房屋。
 *    - 对子数组 nums[0...n-2] 应用打家劫舍 I 的算法。
 *
 * 情况二：不偷窃第一个房屋 (nums[0])。
 *    - 那么可偷窃的范围就变成了从下标 1 到 n-1 的房屋。
 *    - 对子数组 nums[1...n-1] 应用打家劫舍 I 的算法。
 *
 * 最终结果：取上述两种情况计算出的最大金额中的较大者。
 *
 * 这两种情况覆盖了所有可能的有效偷窃组合：
 * - 如果最优解包含偷窃第一个房屋，那么它一定不包含最后一个房屋，会被情况一计算到。
 * - 如果最优解包含偷窃最后一个房屋，那么它一定不包含第一个房屋，会被情况二计算到。
 * - 如果最优解既不包含第一个也不包含最后一个房屋，那么两种情况都能计算到这个解，取最大值时仍然正确。
 *
 * `robRange` 函数实现了打家劫舍 I 的逻辑，用于计算指定范围内的最大偷窃金额。
 */
class Solution {
    /**
     * 主函数，处理环形打家劫舍问题
     * @param nums 代表每个房屋金额的数组
     * @return 能偷窃到的最高金额
     */
    public int rob(int[] nums) {

        // 处理边界情况：没有房屋
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // 处理边界情况：只有一间房屋
        if (nums.length == 1) {
            return nums[0];
        }

        // 情况一：不偷窃最后一个房屋 (范围 0 到 n-2)
        // 调用 robRange 计算 nums[0...n-2] 的最大偷窃金额
        int result1 = robRange(nums, 0, nums.length - 2);

        // 情况二：不偷窃第一个房屋 (范围 1 到 n-1)
        // 调用 robRange 计算 nums[1...n-1] 的最大偷窃金额
        int result2 = robRange(nums, 1, nums.length - 1);

        // 返回两种情况中的最大值
        int ret = Math.max(result1, result2);
        return ret;
    }

    /**
     * 计算线性排列房屋在指定范围 [start, end] 内的最大偷窃金额 (打家劫舍 I 逻辑)
     *
     * 动态规划五部曲应用于此函数：
     * 1. 确定 dp 数组以及下标的含义:
     *    - `dp[i]` 表示：考虑下标从 `start` 到 `i` 的房屋，所能偷窃到的最高总金额。
     *    - 注意：这里的 `dp` 数组大小定义为 `nums.length + 1` 是为了方便使用原数组的下标 `i` 作为 `dp` 数组的下标，
     *      虽然空间上可以优化，但当前实现是有效的。实际只用到了 `dp[start]` 到 `dp[end]` 的部分。
     *
     * 2. 确定递推公式:
     *    - 对于第 `i` 间房屋 (`start <= i <= end`)：
     *      `dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])`
     *      (需要确保 `i-1` 和 `i-2` 也在 `[start, end]` 范围内，通过初始化处理边界)
     *
     * 3. dp 数组如何初始化:
     *    - 处理 `robRange` 的边界情况 (length 为 0 或 1)。
     *    - `dp[start] = nums[start]`：只考虑范围内的第一间房。
     *    - `dp[start+1] = Math.max(nums[start], nums[start+1])`：考虑范围内的前两间房。
     *
     * 4. 确定遍历顺序:
     *    - 从 `start + 2` 开始，按顺序遍历到 `end`。
     *
     * 5. 举例推导 dp 数组:
     *    - 见下方主函数的讲解示例。
     *
     * @param nums 房屋金额数组
     * @param start 起始房屋下标 (包含)
     * @param end 结束房屋下标 (包含)
     * @return 在范围 [start, end] 内能偷窃到的最高金额
     */
    public int robRange(int[] nums, int start, int end) {

        // 计算当前考虑的房屋数量
        int length = end - start + 1;

        // 处理边界情况：范围内没有房屋
        if (length == 0) {
            return 0;
        }

        // 处理边界情况：范围内只有一间房屋
        if (length == 1) {
            return nums[start]; // 直接返回该房屋的金额
        }

        // 1. 定义 dp 数组 (大小比实际需要的大，但方便使用下标)
        // 理论上只需要大小为 length 或更小的空间 (滚动数组/变量优化)
        int dp[] = new int[nums.length]; // 使用 nums.length 保证下标 i 能直接对应

        // 3. 初始化 dp 数组 (针对 [start, end] 范围)
        // 初始化范围内的第一个房屋
        dp[start] = nums[start];
        // 初始化范围内的前两个房屋
        dp[start + 1] = Math.max(nums[start], nums[start + 1]);

        // 4. 确定遍历顺序：从范围内的第三个房屋开始遍历
        for (int i = start + 2; i <= end; i++) {
            // 2. 确定递推公式
            // 选择偷第 i 间 (dp[i-2] + nums[i]) 或不偷第 i 间 (dp[i-1])
            // 注意：这里的 dp[i-1] 和 dp[i-2] 存储的是考虑了 start 到 i-1/i-2 的最大金额
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        // 5. 返回结果：偷窃到范围 [start, end] 中最后一间房时的最大金额
        return dp[end];
    }
}
```

**结合示例和代码进行详细讲解说明**

**示例 2：`nums = [1, 2, 3, 1]`**

1.  **主函数 `rob` 调用:**
    *   `nums.length = 4`。不满足长度为 0 或 1 的边界。
    *   **计算 `result1`:** 调用 `robRange(nums, 0, 2)`，计算不偷最后一个房子（范围 `[1, 2, 3]`）的最大金额。
    *   **计算 `result2`:** 调用 `robRange(nums, 1, 3)`，计算不偷第一个房子（范围 `[2, 3, 1]`）的最大金额。
    *   返回 `Math.max(result1, result2)`。

2.  **执行 `robRange(nums, 0, 2)` (范围 `[1, 2, 3]`):**
    *   `start = 0`, `end = 2`, `length = 3`.
    *   初始化 `dp` 数组 (大小为 4)。
    *   `dp[0] = nums[0] = 1`
    *   `dp[1] = Math.max(nums[0], nums[1]) = Math.max(1, 2) = 2`
    *   `dp` 初始部分: `[1, 2, ?, ?]`
    *   循环 `i` 从 `start + 2 = 2` 到 `end = 2`:
        *   `i = 2`:
            *   `dp[2] = Math.max(dp[1], dp[0] + nums[2])`
            *   `dp[2] = Math.max(2, 1 + 3)`
            *   `dp[2] = Math.max(2, 4) = 4`
            *   `dp` 变为: `[1, 2, 4, ?]`
    *   循环结束。
    *   返回 `dp[end] = dp[2] = 4`。所以 `result1 = 4`。

3.  **执行 `robRange(nums, 1, 3)` (范围 `[2, 3, 1]`):**
    *   `start = 1`, `end = 3`, `length = 3`.
    *   初始化 `dp` 数组 (大小为 4)。
    *   `dp[1] = nums[1] = 2` (注意下标)
    *   `dp[2] = Math.max(nums[1], nums[2]) = Math.max(2, 3) = 3`
    *   `dp` 初始部分: `[?, 2, 3, ?]`
    *   循环 `i` 从 `start + 2 = 3` 到 `end = 3`:
        *   `i = 3`:
            *   `dp[3] = Math.max(dp[2], dp[1] + nums[3])`
            *   `dp[3] = Math.max(3, 2 + 1)`
            *   `dp[3] = Math.max(3, 3) = 3`
            *   `dp` 变为: `[?, 2, 3, 3]`
    *   循环结束。
    *   返回 `dp[end] = dp[3] = 3`。所以 `result2 = 3`。

4.  **返回最终结果:**
    *   `ret = Math.max(result1, result2) = Math.max(4, 3) = 4`。

**输出:**

`4`

这个过程展示了如何将环形问题分解为两个线性子问题，并利用打家劫舍 I 的动态规划解法来解决这两个子问题，最终合并结果得到环形问题的解。












---



















## 




















































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 











































































































































































































































## 

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































