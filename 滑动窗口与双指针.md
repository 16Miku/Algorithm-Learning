

# 说明

本文档记录了按照灵神题单刷题的学习记录。灵神题单链接：<https://leetcode.cn/discuss/post/3578981/ti-dan-hua-dong-chuang-kou-ding-chang-bu-rzz7/>




# 一、定长滑动窗口


## §1.1 基础


### 1456. 定长子串中元音的最大数目

已解答
中等
相关标签
premium lock icon
相关企业
提示
给你字符串 s 和整数 k 。

请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。

英文中的 元音字母 为（a, e, i, o, u）。

 

示例 1：

输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。

示例 2：

输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。

示例 3：

输入：s = "leetcode", k = 3
输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。

示例 4：

输入：s = "rhythms", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。

示例 5：

输入：s = "tryhard", k = 4
输出：1
 

提示：

1 <= s.length <= 10^5
s 由小写英文字母组成
1 <= k <= s.length



#### 定长滑动窗口，无注释



```java

class Solution {


    public int maxVowels(String s, int k) {

        
        if( s == null || s.length() == 0 || k == 0 || k > s.length() ) {

            return 0;

        }


        int currentVowels = 0;

        int maxVowels = 0;

        for( int i=0; i < k; i++ ) {

            if( isVowel( s.charAt(i) ) ) {

                currentVowels++;

            }
        }


        maxVowels = currentVowels;


        for( int right = k; right < s.length(); right++ ) {


            char leftChar = s.charAt( right-k );

            char rightChar = s.charAt( right );


            if( isVowel( leftChar ) ) {

                currentVowels--;
            }


            if( isVowel( rightChar ) ) {


                currentVowels++;
            }


            maxVowels = Math.max( maxVowels, currentVowels );





        }



        return maxVowels;



    }


    public boolean isVowel( char c ) {

        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
        
    }



}

```





#### 定长滑动窗口，注释版




好的，作为一名高级软件工程师，我来一步步教你如何解决 LeetCode 上的“定长子串中元音的最大数目”这道算法题。我们将继续使用 Java 语言来实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个字符串 `s`。
    *   一个整数 `k`，表示子串的长度。
*   **目标**: 找出所有长度为 `k` 的子串中，包含元音字母（'a', 'e', 'i', 'o', 'u'）数目最多的那个子串，并返回它包含的元音字母的最大数目。
*   **关键点**:
    *   **定长子串**: 题目明确要求子串的长度必须是 `k`。
    *   **元音字母**: 明确指定为 'a', 'e', 'i', 'o', 'u' (不区分大小写，但题目通常默认小写)。
    *   **最大数目**: 我们只需要返回元音字母的最大数量，而不是子串本身。

**示例分析：**

假设 `s = "abciiidef"`, `k = 3`

*   第一个长度为 3 的子串是 "abc"：包含 'a', 'i' (2个元音)
*   第二个长度为 3 的子串是 "bci"：包含 'i' (1个元音)
*   第三个长度为 3 的子串是 "cii"：包含 'i', 'i' (2个元音)
*   第四个长度为 3 的子串是 "iii"：包含 'i', 'i', 'i' (3个元音)
*   第五个长度为 3 的子串是 "iid"：包含 'i', 'i' (2个元音)
*   第六个长度为 3 的子串是 "ide"：包含 'i', 'e' (2个元音)
*   第七个长度为 3 的子串是 "def"：包含 'e' (1个元音)

所有长度为 `k` 的子串中，元音字母最多的子串是 "iii"，包含 3 个元音。所以输出 3。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“固定大小滑动窗口”问题。由于我们需要在所有长度为 `k` 的子串中找到元音数量最多的，暴力解法是枚举所有长度为 `k` 的子串，然后对每个子串计数元音，但这会导致重复计算，效率低下。

滑动窗口在这里的优势在于：

*   **避免重复计算**: 当窗口从一个位置滑动到下一个位置时，我们不需要重新计算整个新窗口的元音数量。
*   **增量更新**: 我们只需要关注窗口最左边移出的字符和最右边移入的字符，对元音计数进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **初始化窗口**: 首先计算第一个长度为 `k` 的子串（即 `s[0...k-1]`）中的元音数量。
2.  **滑动窗口**: 然后，窗口向右滑动。
    *   当窗口从 `s[i...i+k-1]` 滑动到 `s[i+1...i+k]` 时：
        *   最左边的字符 `s[i]` 被移出窗口。
        *   最右边的字符 `s[i+k]` 被移入窗口。
    *   我们只需要根据 `s[i]` 是否是元音来减少计数，并根据 `s[i+k]` 是否是元音来增加计数。
3.  **更新最大值**: 在每次滑动后，更新当前窗口的元音数量，并与记录的最大元音数量进行比较，取较大值。

---

3. 数据结构选择

*   **`Set<Character>` 或 `boolean[]`**: 为了高效地判断一个字符是否为元音，我们可以使用 `HashSet` 存储元音字母，或者更高效地，使用一个布尔数组来标记每个字符是否为元音（如果字符集大小固定且较小，例如 ASCII 字符）。由于元音字母只有固定的几个小写字母，使用布尔数组 `boolean[26]` (对应 'a' 到 'z') 或者 `boolean[128]` (对应 ASCII 字符) 会非常高效。

我们将使用一个辅助方法 `isVowel(char c)` 来判断字符是否是元音，它内部可以通过硬编码或一个 `Set` 来实现。为了简洁和效率，直接硬编码判断会更好。

---

4. 算法步骤详解

1.  **定义辅助函数 `isVowel(char c)`**:
    *   判断传入的字符 `c` 是否是 'a', 'e', 'i', 'o', 'u' 中的一个。

2.  **初始化变量**:
    *   `currentVowels = 0`: 记录当前滑动窗口中元音的数量。
    *   `maxVowels = 0`: 记录所有长度为 `k` 的子串中元音的最大数量。

3.  **计算第一个窗口的元音数量**:
    *   遍历字符串 `s` 的前 `k` 个字符 (从索引 0 到 `k-1`)。
    *   对于每个字符，如果它是元音，则 `currentVowels` 加 1。
    *   将 `maxVowels` 初始化为 `currentVowels`。

4.  **滑动窗口**:
    *   从索引 `k` 开始，遍历字符串直到末尾 (`s.length() - 1`)。这个索引 `i` 代表当前窗口的右边界。
    *   在每次迭代中：
        *   **移出旧字符**: 检查 `s.charAt(i - k)` (即窗口最左边即将移出的字符) 是否是元音。如果是，`currentVowels` 减 1。
        *   **移入新字符**: 检查 `s.charAt(i)` (即窗口最右边新移入的字符) 是否是元音。如果是，`currentVowels` 加 1。
        *   **更新最大值**: 将 `maxVowels` 更新为 `Math.max(maxVowels, currentVowels)`。

5.  **返回结果**: 遍历结束后，`maxVowels` 就是最终答案。

---

5. 流程图
略

---

6. Java 代码实现

```java
class Solution {
    /**
     * 判断一个字符是否是元音字母。
     * 元音字母包括 'a', 'e', 'i', 'o', 'u'。
     *
     * @param c 待判断的字符
     * @return 如果是元音字母则返回 true，否则返回 false
     */
    private boolean isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }

    /**
     * 找出字符串 s 中所有长度为 k 的子串中，包含元音字母的最大数目。
     * 使用固定大小的滑动窗口算法。
     *
     * @param s 输入字符串
     * @param k 子串的固定长度
     * @return 长度为 k 的子串中元音字母的最大数目
     */
    public int maxVowels(String s, int k) {
        // 如果输入字符串为空、k为0，或者k大于字符串长度，则直接返回0
        if (s == null || s.length() == 0 || k == 0 || k > s.length()) {
            return 0;
        }

        // currentVowels 记录当前滑动窗口中元音的数量
        int currentVowels = 0;
        // maxVowels 记录到目前为止找到的，所有长度为 k 的子串中元音的最大数量
        int maxVowels = 0;

        // 1. 计算第一个长度为 k 的窗口的元音数量
        // 窗口范围：s[0] 到 s[k-1]
        for (int i = 0; i < k; i++) {
            if (isVowel(s.charAt(i))) {
                currentVowels++;
            }
        }
        // 将第一个窗口的元音数量作为初始的最大值
        maxVowels = currentVowels;

        // 2. 滑动窗口
        // right 指针从 k 开始，遍历到字符串末尾
        // 每次循环，right 指针代表当前窗口的右边界
        // 当前窗口的范围是 s[right - k + 1] 到 s[right]
        for (int right = k; right < s.length(); right++) {
            // leftChar 是当前窗口最左边即将移出的字符
            char leftChar = s.charAt(right - k);
            // rightChar 是当前窗口最右边新移入的字符
            char rightChar = s.charAt(right);

            // 检查移出的字符是否是元音，如果是，则 currentVowels 减 1
            if (isVowel(leftChar)) {
                currentVowels--;
            }

            // 检查移入的字符是否是元音，如果是，则 currentVowels 加 1
            if (isVowel(rightChar)) {
                currentVowels++;
            }

            // 更新 maxVowels，取当前窗口元音数量和历史最大值之间的较大者
            maxVowels = Math.max(maxVowels, currentVowels);
        }

        // 遍历结束后，maxVowels 即为所求的长度为 k 的子串中元音的最大数目
        return maxVowels;
    }
}
```

---

7. 示例演练

我们以 `s = "abciiidef"`, `k = 3` 为例，逐步演示代码的执行过程：

| `right` | `s.charAt(right)` | `leftChar` (`s.charAt(right - k)`) | `currentVowels` (更新前) | `isVowel(leftChar)` | `currentVowels` (移出后) | `isVowel(rightChar)` | `currentVowels` (移入后) | `maxVowels` | 备注 |
| :------ | :---------------- | :--------------------------------- | :----------------------- | :------------------ | :----------------------- | :------------------- | :----------------------- | :---------- | :--- |
| **初始化阶段 (i = 0 to k-1)** | | | | | | | | | |
| i=0     | 'a'               | -                                  | 0                        | -                   | -                        | 是                   | 1                        | -           | 窗口 "a" |
| i=1     | 'b'               | -                                  | 1                        | -                   | -                        | 否                   | 1                        | -           | 窗口 "ab" |
| i=2     | 'c'               | -                                  | 1                        | -                   | -                        | 否                   | 1                        | -           | 窗口 "abc" |
| **初始化结果** | | | | | | | **1** | **1** | 第一个窗口 "abc" 有 1 个元音 ('a') |
| **滑动阶段 (right = k to s.length() - 1)** | | | | | | | | | |
| 3       | 'i'               | 'a' (`s.charAt(0)`)                | 1                        | 是                  | 0                        | 是                   | 1                        | `max(1,1)`=1| 窗口 "bci" ('a'移出,'i'移入) |
| 4       | 'i'               | 'b' (`s.charAt(1)`)                | 1                        | 否                  | 1                        | 是                   | 2                        | `max(1,2)`=2| 窗口 "cii" ('b'移出,'i'移入) |
| 5       | 'i'               | 'c' (`s.charAt(2)`)                | 2                        | 否                  | 2                        | 是                   | 3                        | `max(2,3)`=3| 窗口 "iii" ('c'移出,'i'移入) |
| 6       | 'd'               | 'i' (`s.charAt(3)`)                | 3                        | 是                  | 2                        | 否                   | 2                        | `max(3,2)`=3| 窗口 "iid" ('i'移出,'d'移入) |
| 7       | 'e'               | 'i' (`s.charAt(4)`)                | 2                        | 是                  | 1                        | 是                   | 2                        | `max(3,2)`=3| 窗口 "ide" ('i'移出,'e'移入) |
| 8       | 'f'               | 'i' (`s.charAt(5)`)                | 2                        | 是                  | 1                        | 否                   | 1                        | `max(3,1)`=3| 窗口 "def" ('i'移出,'f'移入) |

最终 `maxVowels` 为 3。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入字符串 `s` 的长度。
    *   我们首先遍历前 `k` 个字符来初始化第一个窗口，这需要 `O(k)` 时间。
    *   然后，`right` 指针从 `k` 遍历到 `N-1`，总共 `N-k` 次迭代。每次迭代中，我们进行常数次操作（字符判断、加减、比较）。
    *   因此，总的时间复杂度是 `O(k + (N-k)) = O(N)`，是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`currentVowels`, `maxVowels`, `leftChar`, `rightChar`)。
    *   `isVowel` 方法也没有使用额外的存储空间。
    *   因此，空间复杂度是常数级别的。

---

希望这个详细的解释和代码能帮助你完全理解并掌握这道算法题！







### 643. 子数组最大平均数 I
已解答
简单
相关标签
premium lock icon
相关企业
给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。

请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。

任何误差小于 10-5 的答案都将被视为正确答案。

 

示例 1：

输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75

示例 2：

输入：nums = [5], k = 1
输出：5.00000
 

提示：

n == nums.length
1 <= k <= n <= 10^5
-10^4 <= nums[i] <= 10^4





#### 定长滑动窗口，无注释


```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        

        if( nums == null || nums.length == 0 || k == 0 ) {

            return 0.0;
        }

        long currentSum = 0;

        for( int i=0; i < k; i++ ) {

            currentSum += nums[i];
        }


        long maxSum = currentSum;


        for( int right = k; right < nums.length; right++ ) {


            int leftChar = nums[right-k];

            int rightChar = nums[right];

            currentSum += rightChar-leftChar;

            maxSum = Math.max( currentSum,maxSum );


        }


        return (double) maxSum/k;



    }
}
```









#### 定长滑动窗口，注释版




好的，作为一名高级软件工程师，我来一步步教你如何解决 LeetCode 上的“子数组最大平均数 I”这道算法题。我们将继续使用 Java 语言来实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个整数数组 `nums`。
    *   一个整数 `k`，表示子数组的长度。
*   **目标**: 找到一个长度为 `k` 的连续子数组，使得其平均值最大，并返回这个最大平均值。
*   **关键点**:
    *   **连续子数组**: 必须是数组中连续的一部分。
    *   **定长 `k`**: 子数组的长度是固定的 `k`。
    *   **最大平均值**: 我们需要返回的是平均值的最大值。

**示例分析：**

假设 `nums = [1,12,-5,-6,50,3]`, `k = 4`

*   第一个长度为 4 的子数组是 `[1, 12, -5, -6]`，和为 `1 + 12 - 5 - 6 = 2`，平均值为 `2 / 4 = 0.5`。
*   第二个长度为 4 的子数组是 `[12, -5, -6, 50]`，和为 `12 - 5 - 6 + 50 = 51`，平均值为 `51 / 4 = 12.75`。
*   第三个长度为 4 的子数组是 `[-5, -6, 50, 3]`，和为 `-5 - 6 + 50 + 3 = 42`，平均值为 `42 / 4 = 10.5`。

所有长度为 `k` 的子数组中，最大平均值是 12.75。所以输出 12.75。

**重要观察**: 因为子数组的长度 `k` 是固定的，所以要使平均值最大化 (`Sum / k`)，就等价于使子数组的**和 (Sum)** 最大化。因此，问题可以转化为：找到一个长度为 `k` 的连续子数组，使其和最大。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是“固定大小滑动窗口”问题的又一个经典应用。与上一题“定长子串中元音的最大数目”非常相似。

*   **避免重复计算**: 我们不需要每次都重新计算整个子数组的和。
*   **增量更新**: 当窗口从一个位置滑动到下一个位置时，我们只需要对和进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **初始化窗口**: 首先计算第一个长度为 `k` 的子数组（即 `nums[0...k-1]`）的元素之和。
2.  **滑动窗口**: 然后，窗口向右滑动。
    *   当窗口从 `nums[i...i+k-1]` 滑动到 `nums[i+1...i+k]` 时：
        *   最左边的元素 `nums[i]` 被移出窗口。
        *   最右边的元素 `nums[i+k]` 被移入窗口。
    *   我们只需要从当前和中减去 `nums[i]`，并加上 `nums[i+k]`，即可得到新窗口的和。
3.  **更新最大值**: 在每次滑动后，更新当前窗口的和，并与记录的最大和进行比较，取较大值。
4.  **计算平均值**: 遍历结束后，用找到的最大和除以 `k`，即为最大平均值。

---

3. 数据结构选择

对于这道题，我们只需要几个简单的变量来存储当前的和以及最大和即可，不需要复杂的数据结构。

*   `currentSum`: 记录当前滑动窗口中元素的和。
*   `maxSum`: 记录到目前为止找到的所有长度为 `k` 的子数组中的最大和。

---

4. 算法步骤详解

1.  **初始化变量**:
    *   `currentSum = 0`: 用于存储当前滑动窗口中元素的和。
    *   `maxSum = 0`: 用于存储找到的最大子数组和。需要注意的是，由于数组元素可能为负数，`maxSum` 的初始值不能简单设为 0。一种方法是先计算第一个窗口的和，然后将其作为 `maxSum` 的初始值。

2.  **计算第一个窗口的和**:
    *   遍历数组 `nums` 的前 `k` 个元素 (从索引 0 到 `k-1`)。
    *   将这些元素累加到 `currentSum` 中。
    *   将 `maxSum` 初始化为 `currentSum`。

3.  **滑动窗口**:
    *   从索引 `k` 开始，遍历数组直到末尾 (`nums.length - 1`)。这个索引 `i` 代表当前窗口的右边界。
    *   在每次迭代中：
        *   **移出旧元素**: `currentSum` 减去 `nums[i - k]` (即窗口最左边即将移出的元素)。
        *   **移入新元素**: `currentSum` 加上 `nums[i]` (即窗口最右边新移入的元素)。
        *   **更新最大和**: 将 `maxSum` 更新为 `Math.max(maxSum, currentSum)`。

4.  **返回结果**: 遍历结束后，最终结果是 `(double) maxSum / k`。注意需要强制类型转换为 `double` 以确保得到浮点数结果。

---

5. 流程图
略
---

6. Java 代码实现

```java
class Solution {
    /**
     * 找出数组中长度为 k 的连续子数组的最大平均值。
     * 使用固定大小的滑动窗口算法。
     *
     * @param nums 输入整数数组
     * @param k 子数组的固定长度
     * @return 长度为 k 的子数组的最大平均值
     */
    public double findMaxAverage(int[] nums, int k) {
        // 如果数组为空，或者 k 为 0，或者 k 大于数组长度，则无法形成有效子数组，返回 0.0
        // 题目约束 nums.length >= k，所以 k > nums.length 的情况理论上不会发生
        if (nums == null || nums.length == 0 || k == 0) {
            return 0.0;
        }

        // currentSum 用于存储当前滑动窗口中元素的和
        long currentSum = 0; // 使用 long 类型以防止整数溢出，因为 nums[i] 范围较大，k 也可能较大
        
        // 1. 计算第一个长度为 k 的窗口的元素之和
        // 窗口范围：nums[0] 到 nums[k-1]
        for (int i = 0; i < k; i++) {
            currentSum += nums[i];
        }

        // maxSum 用于记录到目前为止找到的所有长度为 k 的子数组中的最大和
        // 初始时，将第一个窗口的和作为最大和
        long maxSum = currentSum;

        // 2. 滑动窗口
        // right 指针从 k 开始，遍历到数组末尾
        // 每次循环，right 指针代表当前窗口的右边界新加入的元素
        // 当前窗口的范围是 nums[right - k + 1] 到 nums[right]
        for (int right = k; right < nums.length; right++) {
            // 窗口滑动：
            // 移出最左边的元素：currentSum 减去 nums[right - k]
            // 移入最右边的新元素：currentSum 加上 nums[right]
            currentSum = currentSum - nums[right - k] + nums[right];

            // 更新 maxSum，取当前窗口的和与历史最大和之间的较大者
            maxSum = Math.max(maxSum, currentSum);
        }

        // 遍历结束后，maxSum 即为所求的长度为 k 的子数组的最大和
        // 将最大和转换为 double 类型再除以 k，以确保得到浮点数结果
        return (double) maxSum / k;
    }
}
```

---

7. 示例演练

我们以 `nums = [1,12,-5,-6,50,3]`, `k = 4` 为例，逐步演示代码的执行过程：

| `right` | `nums[right]` | `nums[right - k]` (移出元素) | `currentSum` (更新前) | `currentSum` (更新后) | `maxSum` (更新后) | 备注 |
| :------ | :------------ | :--------------------------- | :-------------------- | :-------------------- | :---------------- | :--- |
| **初始化阶段 (i = 0 to k-1)** | | | | | | |
| i=0     | 1             | -                            | 0                     | 1                     | -                 | currentSum = 1 |
| i=1     | 12            | -                            | 1                     | 13                    | -                 | currentSum = 1 + 12 = 13 |
| i=2     | -5            | -                            | 13                    | 8                     | -                 | currentSum = 13 - 5 = 8 |
| i=3     | -6            | -                            | 8                     | 2                     | -                 | currentSum = 8 - 6 = 2 |
| **初始化结果** | | | | **2** | **2** | 第一个窗口 `[1, 12, -5, -6]` 的和是 2。`maxSum` 初始为 2。 |
| **滑动阶段 (right = k to nums.length - 1)** | | | | | | |
| 4       | 50            | `nums[0]` (1)                | 2                     | `2 - 1 + 50 = 51`     | `max(2, 51)`=51   | 窗口 `[12, -5, -6, 50]` |
| 5       | 3             | `nums[1]` (12)               | 51                    | `51 - 12 + 3 = 42`    | `max(51, 42)`=51  | 窗口 `[-5, -6, 50, 3]` |

最终 `maxSum` 为 51。
返回 `(double) 51 / 4 = 12.75`。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入数组 `nums` 的长度。
    *   我们首先遍历前 `k` 个元素来初始化第一个窗口的和，这需要 `O(k)` 时间。
    *   然后，`right` 指针从 `k` 遍历到 `N-1`，总共 `N-k` 次迭代。每次迭代中，我们进行常数次操作（加减、比较）。
    *   因此，总的时间复杂度是 `O(k + (N-k)) = O(N)`，是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`currentSum`, `maxSum`)。
    *   因此，空间复杂度是常数级别的。

---

希望这个详细的解释和代码能帮助你完全理解并掌握这道算法题！








### 1343. 大小为 K 且平均值大于等于阈值的子数组数目
已解答
中等
相关标签
premium lock icon
相关企业
提示
给你一个整数数组 arr 和两个整数 k 和 threshold 。

请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。

 

示例 1：

输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
输出：3
解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。
示例 2：

输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
输出：6
解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。
 

提示：
1 <= arr.length <= 10^5
1 <= arr[i] <= 10^4
1 <= k <= arr.length
0 <= threshold <= 10^4




#### 定长滑动窗口，无注释





```java
class Solution {
    public int numOfSubarrays(int[] arr, int k, int threshold) {
        

        int count = 0;

        long currentSum=0;

        long targetSum = (long) threshold * k;

        for( int i=0; i < k; i++ ) {

            currentSum += arr[i];

        }

        if( currentSum >= targetSum ) {

            count++;
        }


        for( int right=k; right < arr.length; right++ ) {

            
            currentSum = currentSum - arr[right-k] + arr[right];

            if( currentSum >= targetSum ) {

                count++;
            }


        }


        return count;



    }
}
```






#### 定长滑动窗口，注释版




好的，作为一名高级软件工程师，我将极尽详细地为你讲解“大小为 K 且平均值大于等于阈值的子数组数目”这道算法题，并提供详细的 Java 代码实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个整数数组 `arr`。
    *   一个整数 `k`，表示子数组的固定长度。
    *   一个整数 `threshold`，表示平均值的阈值。
*   **目标**: 统计并返回数组 `arr` 中，有多少个**长度为 `k` 的连续子数组**，其**平均值**大于等于 `threshold`。
*   **关键点**:
    *   **连续子数组**: 必须是数组中连续的一部分。
    *   **定长 `k`**: 子数组的长度是固定的 `k`。
    *   **平均值大于等于 `threshold`**: 这是判断一个子数组是否符合条件的标准。

**示例分析：**

假设 `arr = [2,2,2,2,5,5,5,8]`, `k = 3`, `threshold = 4`

我们需要找出所有长度为 3 的子数组，计算它们的平均值，然后看平均值是否 `>= 4`。

1.  子数组 `[2,2,2]`：
    *   和 = `2 + 2 + 2 = 6`
    *   平均值 = `6 / 3 = 2`
    *   `2 < 4`，不符合条件。

2.  子数组 `[2,2,5]`：
    *   和 = `2 + 2 + 5 = 9`
    *   平均值 = `9 / 3 = 3`
    *   `3 < 4`，不符合条件。

3.  子数组 `[2,5,5]`：
    *   和 = `2 + 5 + 5 = 12`
    *   平均值 = `12 / 3 = 4`
    *   `4 >= 4`，**符合条件**。计数 +1。

4.  子数组 `[5,5,5]`：
    *   和 = `5 + 5 + 5 = 15`
    *   平均值 = `15 / 3 = 5`
    *   `5 >= 4`，**符合条件**。计数 +1。

5.  子数组 `[5,5,8]`：
    *   和 = `5 + 5 + 8 = 18`
    *   平均值 = `18 / 3 = 6`
    *   `6 >= 4`，**符合条件**。计数 +1。

最终，符合条件的子数组有 3 个。

**重要观察/优化**:

题目要求 `平均值 >= threshold`，即 `子数组之和 / k >= threshold`。
由于 `k` 总是正整数 (`1 <= k <= arr.length`)，我们可以将不等式两边同乘以 `k`，得到：
`子数组之和 >= threshold * k`。

这个转换非常重要，它避免了在每次计算平均值时进行浮点数除法，从而避免了潜在的浮点数精度问题，并且可以直接比较整数，效率更高。
所以，问题可以转化为：找到有多少个长度为 `k` 的连续子数组，其**和**大于等于 `threshold * k`。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“固定大小滑动窗口”问题。由于我们需要遍历所有长度为 `k` 的子数组并计算它们的和，如果每次都重新求和，效率会非常低 (`O(N*K)`)。

滑动窗口在这里的优势在于：

*   **避免重复计算**: 当窗口从一个位置滑动到下一个位置时，我们不需要重新计算整个新窗口的和。
*   **增量更新**: 我们只需要关注窗口最左边移出的元素和最右边移入的元素，对当前窗口的总和进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **初始化窗口**: 首先计算第一个长度为 `k` 的子数组（即 `arr[0...k-1]`）的元素之和。
2.  **滑动窗口**: 然后，窗口向右滑动。
    *   当窗口从 `arr[i...i+k-1]` 滑动到 `arr[i+1...i+k]` 时：
        *   最左边的元素 `arr[i]` 被移出窗口。
        *   最右边的元素 `arr[i+k]` 被移入窗口。
    *   我们只需要从当前和中减去 `arr[i]`，并加上 `arr[i+k]`，即可得到新窗口的和。
3.  **判断条件并计数**: 在每次滑动（包括初始化第一个窗口后）后，检查当前窗口的和是否大于等于 `threshold * k`。如果是，则计数器加 1。

---

3. 数据结构选择

对于这道题，我们只需要几个简单的变量来存储当前的和、目标和以及符合条件的子数组数目。不需要复杂的数据结构。

*   `currentSum`: 记录当前滑动窗口中元素的和。
*   `count`: 记录符合条件的子数组数目。
*   `targetSum`: `threshold * k` 的结果，用于比较。

**数据类型考虑**:
`arr[i]` 的范围是 `1 <= arr[i] <= 10^4`。
`k` 的范围是 `1 <= k <= arr.length`，`arr.length` 最大是 `10^5`。
`currentSum` 在最坏情况下可能达到 `10^4 * 10^5 = 10^9`。
`threshold` 的范围是 `0 <= threshold <= 10^4`。
`targetSum = threshold * k` 在最坏情况下可能达到 `10^4 * 10^5 = 10^9`。
`int` 类型的最大值约为 `2 * 10^9`，所以 `10^9` 还在 `int` 范围内。
但是，为了更加稳健和防止任何潜在的中间计算溢出（尽管在这里直接相乘可能不会），使用 `long` 类型来存储 `currentSum` 和 `targetSum` 是一个非常好的习惯。

---

4. 算法步骤详解

1.  **初始化变量**:
    *   `count = 0`: 用于存储符合条件的子数组数目。
    *   `currentSum = 0L`: 用于存储当前滑动窗口中元素的和，使用 `long` 类型。
    *   `targetSum = (long)threshold * k`: 计算目标和，同样使用 `long` 类型以防止 `threshold * k` 溢出。

2.  **计算第一个窗口的和并检查**:
    *   遍历数组 `arr` 的前 `k` 个元素 (从索引 0 到 `k-1`)。
    *   将这些元素累加到 `currentSum` 中。
    *   完成第一个窗口的和计算后，检查 `currentSum >= targetSum`。如果为真，则 `count++`。

3.  **滑动窗口并检查**:
    *   从索引 `k` 开始，遍历数组直到末尾 (`arr.length - 1`)。这个索引 `i` 代表当前窗口的右边界新加入的元素。
    *   在每次迭代中：
        *   **移出旧元素**: `currentSum` 减去 `arr[i - k]` (即窗口最左边即将移出的元素)。
        *   **移入新元素**: `currentSum` 加上 `arr[i]` (即窗口最右边新移入的元素)。
        *   **检查条件**: 检查更新后的 `currentSum >= targetSum`。如果为真，则 `count++`。

4.  **返回结果**: 遍历结束后，`count` 就是符合条件的子数组数目。

---

5. 流程图
略

---

6. Java 代码实现

```java
class Solution {
    /**
     * 统计数组中长度为 k 且平均值大于等于阈值的子数组数目。
     * 使用固定大小的滑动窗口算法。
     *
     * @param arr 输入整数数组
     * @param k 子数组的固定长度
     * @param threshold 平均值的阈值
     * @return 长度为 k 且平均值大于等于 threshold 的子数组数目
     */
    public int numOfSubarrays(int[] arr, int k, int threshold) {
        // count 用于记录符合条件的子数组数目
        int count = 0;
        
        // currentSum 用于存储当前滑动窗口中元素的和。
        // 使用 long 类型以防止在累加过程中发生整数溢出，
        // 尽管单个 arr[i] 和 k 的乘积可能在 int 范围内，
        // 但多个 arr[i] 的和可能超出 int 范围。
        long currentSum = 0; 
        
        // targetSum 是判断条件：子数组之和 >= threshold * k。
        // 将 threshold 强制转换为 long 后再与 k 相乘，
        // 确保乘法结果不会溢出 int 范围。
        long targetSum = (long)threshold * k;

        // 1. 计算第一个长度为 k 的窗口的元素之和
        // 窗口范围：arr[0] 到 arr[k-1]
        for (int i = 0; i < k; i++) {
            currentSum += arr[i];
        }

        // 检查第一个窗口是否符合条件
        if (currentSum >= targetSum) {
            count++;
        }

        // 2. 滑动窗口
        // right 指针从 k 开始，遍历到数组末尾
        // 每次循环，right 指针代表当前窗口的右边界新加入的元素
        // 当前窗口的范围是 arr[right - k + 1] 到 arr[right]
        for (int right = k; right < arr.length; right++) {
            // 窗口滑动操作：
            // 移出最左边的元素：currentSum 减去 arr[right - k]
            // 移入最右边的新元素：currentSum 加上 arr[right]
            currentSum = currentSum - arr[right - k] + arr[right];

            // 检查当前窗口更新后的和是否符合条件
            if (currentSum >= targetSum) {
                count++;
            }
        }

        // 遍历结束后，count 即为所求的符合条件的子数组数目
        return count;
    }
}
```

---

7. 示例演练

我们以 `arr = [2,2,2,2,5,5,5,8]`, `k = 3`, `threshold = 4` 为例，逐步演示代码的执行过程：

*   `targetSum = (long)4 * 3 = 12`

| `right` | `arr[right]` | `arr[right - k]` (移出元素) | `currentSum` (更新前) | `currentSum` (更新后) | `currentSum >= targetSum` (>=12)? | `count` | 备注 |
| :------ | :----------- | :-------------------------- | :-------------------- | :-------------------- | :-------------------------------- | :------ | :--- |
| **初始化阶段 (i = 0 to k-1)** | | | | | | | |
| i=0     | 2            | -                           | 0                     | 2                     | -                                 | -       | currentSum = 2 |
| i=1     | 2            | -                           | 2                     | 4                     | -                                 | -       | currentSum = 2 + 2 = 4 |
| i=2     | 2            | -                           | 4                     | 6                     | -                                 | -       | currentSum = 4 + 2 = 6 |
| **初始化结果** | | | | **6** | `6 >= 12` 否              | **0**   | 第一个窗口 `[2,2,2]` 的和是 6。 |
| **滑动阶段 (right = k to arr.length - 1)** | | | | | | | |
| 3       | 2            | `arr[0]` (2)                | 6                     | `6 - 2 + 2 = 6`       | `6 >= 12` 否                      | 0       | 窗口 `[2,2,2]` -> `[2,2,2]` (和不变) |
| 4       | 5            | `arr[1]` (2)                | 6                     | `6 - 2 + 5 = 9`       | `9 >= 12` 否                      | 0       | 窗口 `[2,2,5]` |
| 5       | 5            | `arr[2]` (2)                | 9                     | `9 - 2 + 5 = 12`      | `12 >= 12` 是                     | 1       | 窗口 `[2,5,5]` |
| 6       | 5            | `arr[3]` (2)                | 12                    | `12 - 2 + 5 = 15`     | `15 >= 12` 是                     | 2       | 窗口 `[5,5,5]` |
| 7       | 8            | `arr[4]` (5)                | 15                    | `15 - 5 + 8 = 18`     | `18 >= 12` 是                     | 3       | 窗口 `[5,5,8]` |

最终 `count` 为 3。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入数组 `arr` 的长度。
    *   我们首先遍历前 `k` 个元素来初始化第一个窗口的和，这需要 `O(k)` 时间。
    *   然后，`right` 指针从 `k` 遍历到 `N-1`，总共 `N-k` 次迭代。每次迭代中，我们进行常数次操作（加减、比较）。
    *   因此，总的时间复杂度是 `O(k + (N-k)) = O(N)`，是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`count`, `currentSum`, `targetSum`)。
    *   因此，空间复杂度是常数级别的。

---

希望这个详细的解释和代码能帮助你完全理解并掌握这道算法题！













### 2090. 半径为 k 的子数组平均值
中等
相关标签
premium lock icon
相关企业
提示
给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。

半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。

构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。

x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。

例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。
 

示例 1：



输入：nums = [7,4,3,9,1,8,5,2,6], k = 3
输出：[-1,-1,-1,5,4,4,-1,-1,-1]
解释：
- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。
- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。
  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。
- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。
- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。
- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。


示例 2：

输入：nums = [100000], k = 0
输出：[100000]
解释：
- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。
  avg[0] = 100000 / 1 = 100000 。


示例 3：

输入：nums = [8], k = 100000
输出：[-1]
解释：
- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。
 

提示：
n == nums.length
1 <= n <= 10^5
0 <= nums[i], k <= 10^5







#### 定长滑动窗口，无注释



```java
class Solution {
    public int[] getAverages(int[] nums, int k) {
        

        int n = nums.length;

        int[] avgs = new int[n];

        Arrays.fill( avgs, -1 );

        if( k == 0 ) {

            for( int i=0; i < n; i++ ) {

                avgs[i] = nums[i];

            }

            return avgs;

        }



        long windowSize = (long) 2*k + 1;

        if( windowSize > n ) {

            return avgs;
        }


        long currentSum=0;


        for( int i=0; i < windowSize; i++ ) {

            currentSum += nums[i];

        }


        avgs[k] = (int) ( currentSum / windowSize );


        for( int center = k + 1; center <= n-1 -k; center++ ) {


            currentSum -= nums[center - k - 1];

            currentSum += nums[center + k];


            avgs[center] = (int) (currentSum / windowSize);

        }

        return avgs;



    }
}
```





#### 定长滑动窗口，注释版




好的，作为一名高级软件工程师，我将极尽详细地为你讲解 LeetCode 上的“半径为 k 的子数组平均值”这道算法题，并提供详细的 Java 代码实现。

---

 1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个下标从 0 开始的整数数组 `nums`，长度为 `n`。
    *   一个整数 `k`，表示“半径”。
*   **目标**: 构建并返回一个长度为 `n` 的数组 `avgs`，其中 `avgs[i]` 是以下标 `i` 为中心，半径为 `k` 的子数组的平均值。
*   **关键定义**:
    *   **半径为 k 的子数组**: 对于以 `i` 为中心的子数组，它包含的元素范围是 `nums[i - k]` 到 `nums[i + k]`（包含这两个边界）。
    *   **子数组长度**: 这个子数组的长度是 `(i + k) - (i - k) + 1 = 2k + 1`。
    *   **平均值计算**: `x` 个元素的平均值是 `x` 个元素相加之和除以 `x`。题目明确指出使用**截断式整数除法**，这意味着直接进行整数除法（例如 Java 中 `int` 或 `long` 类型的 `/` 运算符）即可，它会自动向下取整（截断小数部分）。例如，`11 / 4` 结果为 `2`。
    *   **无效情况**: 如果在下标 `i` 前或后不足 `k` 个元素，那么 `avgs[i]` 应该为 `-1`。

**示例分析：**

假设 `nums = [7,4,3,9,1,8,5,2,6]`, `k = 3`

`n = 9`, `k = 3`。
子数组的固定长度（窗口大小）是 `2k + 1 = 2 * 3 + 1 = 7`。

*   **对于 `avgs[0]`, `avgs[1]`, `avgs[2]`**:
    *   以 `0` 为中心：需要 `0-3 = -3` 到 `0+3 = 3`。`nums[-3]` 不存在，所以 `avgs[0] = -1`。
    *   以 `1` 为中心：需要 `1-3 = -2` 到 `1+3 = 4`。`nums[-2]` 不存在，所以 `avgs[1] = -1`。
    *   以 `2` 为中心：需要 `2-3 = -1` 到 `2+3 = 5`。`nums[-1]` 不存在，所以 `avgs[2] = -1`。
    *   **总结**: 对于中心 `i`，如果 `i - k < 0`，则为 `-1`。这意味着前 `k` 个索引 (`0` 到 `k-1`) 都会是 `-1`。

*   **对于 `avgs[3]`**:
    *   以 `3` 为中心，半径为 `3` 的子数组是 `nums[3-3]` 到 `nums[3+3]`，即 `nums[0]` 到 `nums[6]`。
    *   子数组为 `[7,4,3,9,1,8,5]`。
    *   和 = `7 + 4 + 3 + 9 + 1 + 8 + 5 = 37`。
    *   平均值 = `37 / 7 = 5` (截断)。所以 `avgs[3] = 5`。
    *   **观察**: 这是第一个可以形成完整 `2k+1` 长度子数组的中心。它的左边界是 `0` (`k - k`)，右边界是 `2k` (`k + k`)。

*   **对于 `avgs[4]`**:
    *   以 `4` 为中心，半径为 `3` 的子数组是 `nums[4-3]` 到 `nums[4+3]`，即 `nums[1]` 到 `nums[7]`。
    *   子数组为 `[4,3,9,1,8,5,2]`。
    *   和 = `4 + 3 + 9 + 1 + 8 + 5 + 2 = 32`。
    *   平均值 = `32 / 7 = 4` (截断)。所以 `avgs[4] = 4`。

*   **对于 `avgs[5]`**:
    *   以 `5` 为中心，半径为 `3` 的子数组是 `nums[5-3]` 到 `nums[5+3]`，即 `nums[2]` 到 `nums[8]`。
    *   子数组为 `[3,9,1,8,5,2,6]`。
    *   和 = `3 + 9 + 1 + 8 + 5 + 2 + 6 = 34`。
    *   平均值 = `34 / 7 = 4` (截断)。所以 `avgs[5] = 4`。

*   **对于 `avgs[6]`, `avgs[7]`, `avgs[8]`**:
    *   以 `6` 为中心：需要 `6-3 = 3` 到 `6+3 = 9`。`nums[9]` 不存在 (`n=9`，最大索引 `8`)，所以 `avgs[6] = -1`。
    *   以 `7` 为中心：需要 `7-3 = 4` 到 `7+3 = 10`。`nums[10]` 不存在，所以 `avgs[7] = -1`。
    *   以 `8` 为中心：需要 `8-3 = 5` 到 `8+3 = 11`。`nums[11]` 不存在，所以 `avgs[8] = -1`。
    *   **总结**: 对于中心 `i`，如果 `i + k >= n`，则为 `-1`。这意味着后 `k` 个索引 (`n-k` 到 `n-1`) 都会是 `-1`。

**综合有效中心索引范围**:
一个中心 `i` 能够形成完整半径为 `k` 的子数组的条件是：
1.  `i - k >= 0`
2.  `i + k < n`
结合起来就是：`k <= i <= n - 1 - k`。
如果 `k > n - 1 - k`（即 `2k + 1 > n`），那么就没有一个中心 `i` 能够满足条件，所有 `avgs[i]` 都将是 `-1`。

**特殊情况 `k = 0`**:
如果 `k = 0`，则半径为 0。
子数组的长度是 `2 * 0 + 1 = 1`。
以 `i` 为中心的子数组就是 `nums[i]`。
平均值就是 `nums[i] / 1 = nums[i]`。
在这种情况下，所有 `avgs[i]` 都等于 `nums[i]`。

**数据类型考虑**:
`nums[i]` 的范围是 `0 <= nums[i] <= 10^5`。
`k` 的范围是 `0 <= k <= 10^5`。
子数组长度 `2k + 1` 最大可以达到 `2 * 10^5 + 1 = 200001`。
子数组之和 `currentSum` 最大可以达到 `10^5 * (2 * 10^5 + 1) ≈ 2 * 10^{10}`。
Java 的 `int` 类型最大值约为 `2 * 10^9`。显然，`currentSum` 必须使用 `long` 类型来存储，以防止溢出。

---

 2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“固定大小滑动窗口”问题。我们需要计算多个固定长度子数组的和，然后求平均值。如果每次都重新计算子数组的和，效率会非常低 (`O(N * WindowSize)`)。

滑动窗口在这里的优势在于：

*   **避免重复计算**: 当窗口从一个位置滑动到下一个位置时，我们不需要重新计算整个新窗口的和。
*   **增量更新**: 我们只需要关注窗口最左边移出的元素和最右边移入的元素，对当前窗口的总和进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **确定窗口大小**: 窗口的固定大小是 `windowSize = 2k + 1`。
2.  **处理无效情况**: 先初始化结果数组 `avgs` 为 `-1`。对于无法形成完整窗口的中心 `i`，其 `avgs[i]` 保持 `-1`。
3.  **计算第一个有效窗口的和**: 找到第一个能够形成完整窗口的中心 `i`（即 `i = k`）。计算这个窗口 `nums[0]` 到 `nums[2k]` 的和。
4.  **滑动窗口**: 然后，窗口向右滑动。
    *   当中心从 `i` 移动到 `i + 1` 时，窗口的左边界从 `i - k` 移动到 `i + 1 - k`，右边界从 `i + k` 移动到 `i + 1 + k`。
    *   这意味着，`nums[i - k]` 这个元素离开了窗口。
    *   `nums[i + 1 + k]` 这个元素进入了窗口。
    *   我们只需要从当前和中减去离开的元素，并加上进入的元素，即可得到新窗口的和。
5.  **计算平均值并存储**: 在每次更新 `currentSum` 后，计算 `currentSum / windowSize`，并将结果存储到 `avgs[i]` 中。

---

 3. 数据结构选择

*   `int[] nums`: 输入数组。
*   `int[] avgs`: 结果数组，长度与 `nums` 相同。
*   `long currentSum`: 存储当前滑动窗口中元素的总和，必须是 `long` 类型。
*   `long windowSize`: 存储窗口的固定长度 `2k + 1`，使用 `long` 确保计算 `2*k` 时不会因 `k` 过大而溢出（虽然 `k` 最大 `10^5`，`2*k` 是 `2*10^5` 仍在 `int` 范围内，但保持一致性更好）。

---

 4. 算法步骤详解

1.  **初始化结果数组**:
    *   创建 `int[] avgs = new int[n]`。
    *   使用 `java.util.Arrays.fill(avgs, -1)` 将所有元素初始化为 `-1`。这样，对于那些无法形成完整半径 `k` 子数组的索引，其值自然就是 `-1`。

2.  **处理特殊情况 `k = 0`**:
    *   如果 `k` 为 `0`，则每个元素的平均值就是它本身。
    *   遍历 `nums`，将 `nums[i]` 的值直接赋给 `avgs[i]`。
    *   完成后直接返回 `avgs`。

3.  **计算窗口大小**:
    *   `long windowSize = (long)2 * k + 1;`
    *   注意这里将 `2 * k` 强制转换为 `long`，虽然对于 `k` 最大 `10^5` 来说 `2*k` 仍在 `int` 范围内，但这是个好习惯，避免潜在溢出。

4.  **处理窗口大小大于数组长度的情况**:
    *   如果 `windowSize > n`，表示没有任何一个中心能够形成完整的半径 `k` 子数组。
    *   在这种情况下，`avgs` 数组已经全部填充为 `-1` 了，直接返回 `avgs` 即可。

5.  **计算第一个有效窗口的和**:
    *   第一个有效的中心是 `k`。这个窗口的范围是 `nums[0]` 到 `nums[2k]`。
    *   `long currentSum = 0L;`
    *   从 `i = 0` 遍历到 `windowSize - 1`，将 `nums[i]` 累加到 `currentSum`。
    *   将 `(int)(currentSum / windowSize)` 的结果存储到 `avgs[k]` 中。

6.  **滑动窗口并计算后续平均值**:
    *   从下一个可能的中心 `i = k + 1` 开始，一直遍历到 `n - 1 - k`（这是最后一个能形成完整窗口的中心）。
    *   在每次循环中：
        *   **更新 `currentSum`**:
            *   减去离开窗口的元素：`currentSum -= nums[i - k - 1]`。
            *   加上进入窗口的元素：`currentSum += nums[i + k]`。
        *   **计算平均值并存储**: 将 `(int)(currentSum / windowSize)` 的结果存储到 `avgs[i]` 中。

7.  **返回结果**: 遍历结束后，`avgs` 数组就包含了所有计算好的平均值，直接返回它。

---

 5. 流程图

略

---

 6. Java 代码实现

```java
import java.util.Arrays; // 导入 Arrays 工具类，用于填充数组

class Solution {
    /**
     * 计算数组中每个位置半径为 k 的子数组的平均值。
     *
     * @param nums 输入的整数数组。
     * @param k 半径。
     * @return 包含每个位置平均值的数组，如果无法形成完整子数组则为 -1。
     */
    public int[] getAverages(int[] nums, int k) {
        int n = nums.length; // 获取数组长度
        int[] avgs = new int[n]; // 创建结果数组，长度与 nums 相同

        // 1. 初始化结果数组 avgs，所有元素默认填充为 -1。
        // 这是为了处理那些无法形成完整半径 k 子数组的索引。
        Arrays.fill(avgs, -1);

        // 2. 处理特殊情况：k = 0。
        // 如果半径 k 为 0，则每个子数组只包含其中心元素本身。
        // 平均值就是该元素的值。
        if (k == 0) {
            for (int i = 0; i < n; i++) {
                avgs[i] = nums[i];
            }
            return avgs;
        }

        // 计算滑动窗口的固定大小：中心元素 + 前 k 个元素 + 后 k 个元素。
        // 使用 long 类型以确保计算 (2 * k) 时不会因为 k 过大而溢出，虽然这里 int 足够。
        long windowSize = (long)2 * k + 1;

        // 3. 处理特殊情况：如果窗口大小大于数组长度。
        // 这意味着没有任何一个中心能够形成完整的半径 k 子数组。
        // 此时 avgs 数组已经全部是 -1，直接返回即可。
        if (windowSize > n) {
            return avgs;
        }

        // currentSum 用于存储当前滑动窗口中元素的总和。
        // 必须使用 long 类型，因为 nums[i] 和 k 都可能很大，
        // 它们的乘积 (nums[i] * windowSize) 可能超出 int 的最大值。
        long currentSum = 0;

        // 4. 计算第一个有效窗口的元素之和。
        // 第一个能够形成完整半径 k 子数组的中心是索引 k。
        // 这个窗口的范围是 [0, 2k]，即 nums[0] 到 nums[windowSize - 1]。
        for (int i = 0; i < windowSize; i++) {
            currentSum += nums[i];
        }

        // 将第一个有效窗口的平均值存储到 avgs[k]。
        // 题目要求截断式整数除法，Java 的整数除法默认就是截断的。
        avgs[k] = (int)(currentSum / windowSize);

        // 5. 滑动窗口并计算后续有效窗口的平均值。
        // 'center' 变量代表当前子数组的中心索引。
        // 它从 k + 1 开始，一直到 n - 1 - k (最后一个可以形成完整窗口的中心)。
        for (int center = k + 1; center <= n - 1 - k; center++) {
            // 滑动窗口的更新逻辑：
            // - 移除窗口最左边的元素：这个元素是上一个窗口的起始元素。
            //   对于当前中心 'center'，其窗口的左边界是 'center - k'。
            //   上一个窗口的左边界是 '(center - 1) - k'。
            //   因此，要移除的元素是 nums[(center - 1) - k]，即 nums[center - k - 1]。
            currentSum -= nums[center - k - 1];

            // - 添加窗口最右边的新元素：这个元素是当前窗口的结束元素。
            //   对于当前中心 'center'，其窗口的右边界是 'center + k'。
            currentSum += nums[center + k];

            // 计算当前窗口的平均值并存储。
            avgs[center] = (int)(currentSum / windowSize);
        }

        // 6. 返回结果数组。
        return avgs;
    }
}
```

---

 7. 示例演练

我们以 `nums = [7,4,3,9,1,8,5,2,6]`, `k = 3` 为例，逐步演示代码的执行过程：

*   `n = 9`, `k = 3`
*   `avgs` 初始化为 `[-1,-1,-1,-1,-1,-1,-1,-1,-1]`
*   `k != 0`，跳过 `k=0` 处理。
*   `windowSize = (long)2 * 3 + 1 = 7`.
*   `windowSize (7) <= n (9)`，跳过 `windowSize > n` 处理。
*   `currentSum = 0L`.

**1. 计算第一个有效窗口的和 (for i = 0 to 6)**:
*   `i=0`: `currentSum += nums[0]` (7) -> `currentSum = 7`
*   `i=1`: `currentSum += nums[1]` (4) -> `currentSum = 11`
*   `i=2`: `currentSum += nums[2]` (3) -> `currentSum = 14`
*   `i=3`: `currentSum += nums[3]` (9) -> `currentSum = 23`
*   `i=4`: `currentSum += nums[4]` (1) -> `currentSum = 24`
*   `i=5`: `currentSum += nums[5]` (8) -> `currentSum = 32`
*   `i=6`: `currentSum += nums[6]` (5) -> `currentSum = 37`
*   `avgs[k]` (即 `avgs[3]`) = `(int)(37 / 7) = 5`.
*   此时 `avgs` 为 `[-1,-1,-1,5,-1,-1,-1,-1,-1]`。

**2. 滑动窗口 (for center = k + 1 to n - 1 - k)**:
   即 `center` 从 `4` 到 `9 - 1 - 3 = 5`。所以 `center` 将为 `4, 5`。

*   **`center = 4`**:
    *   移除 `nums[center - k - 1]` = `nums[4 - 3 - 1]` = `nums[0]` (7)。
        `currentSum = 37 - 7 = 30`.
    *   添加 `nums[center + k]` = `nums[4 + 3]` = `nums[7]` (2)。
        `currentSum = 30 + 2 = 32`.
    *   `avgs[4] = (int)(32 / 7) = 4`.
    *   此时 `avgs` 为 `[-1,-1,-1,5,4,-1,-1,-1,-1]`。

*   **`center = 5`**:
    *   移除 `nums[center - k - 1]` = `nums[5 - 3 - 1]` = `nums[1]` (4)。
        `currentSum = 32 - 4 = 28`.
    *   添加 `nums[center + k]` = `nums[5 + 3]` = `nums[8]` (6)。
        `currentSum = 28 + 6 = 34`.
    *   `avgs[5] = (int)(34 / 7) = 4`.
    *   此时 `avgs` 为 `[-1,-1,-1,5,4,4,-1,-1,-1]`。

循环结束。

**3. 返回 `avgs`**: `[-1,-1,-1,5,4,4,-1,-1,-1]`，与示例输出完全一致。

---

 8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `Arrays.fill()` 操作需要 `O(N)` 时间。
    *   `k = 0` 的特殊处理循环需要 `O(N)` 时间。
    *   计算第一个有效窗口的和的循环需要 `O(windowSize)` 或 `O(k)` 时间。
    *   滑动窗口的主循环执行 `(n - 1 - k) - (k + 1) + 1 = n - 2k - 1` 次。每次迭代执行常数个操作（加法、减法、除法）。因此这部分是 `O(N - 2k)` 时间。
    *   综合来看，所有操作都是线性的，所以总的时间复杂度是 `O(N)`。

*   **空间复杂度**: `O(N)`。
    *   我们创建了一个新的 `avgs` 数组来存储结果，其大小为 `N`。
    *   其他变量（`n`, `k`, `windowSize`, `currentSum`, `center`）都只占用常数空间。
    *   因此，总的空间复杂度是 `O(N)`。

---

希望这个极尽详细的讲解和代码能帮助你完全理解并掌握这道算法题！








### 2379. 得到 K 个黑块的最少涂色次数
已解答
简单
相关标签
premium lock icon
相关企业
提示
给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 'W' 要么是 'B' ，表示第 i 块的颜色。字符 'W' 和 'B' 分别表示白色和黑色。

给你一个整数 k ，表示想要 连续 黑色块的数目。

每一次操作中，你可以选择一个白色块将它 涂成 黑色块。

请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。

 

示例 1：

输入：blocks = "WBBWWBBWBW", k = 7
输出：3
解释：
一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。
得到 blocks = "BBBBBBBWBW" 。
可以证明无法用少于 3 次操作得到 7 个连续的黑块。
所以我们返回 3 。

示例 2：

输入：blocks = "WBWBBBW", k = 2
输出：0
解释：
不需要任何操作，因为已经有 2 个连续的黑块。
所以我们返回 0 。
 

提示：

n == blocks.length
1 <= n <= 100
blocks[i] 要么是 'W' ，要么是 'B' 。
1 <= k <= n








#### 定长滑动窗口，无注释


```java
class Solution {
    public int minimumRecolors(String blocks, int k) {



        int n = blocks.length();

        int minRecolors = Integer.MAX_VALUE;

        int currentWhites=0;

        for( int i=0; i < k; i++ ) {

            if( blocks.charAt(i) == 'W' ) {

                currentWhites++;
            }
        }

        minRecolors = currentWhites;


        for( int right = k; right < n; right++ ) {


            if( blocks.charAt( right-k ) == 'W' ) {

                currentWhites--;

            }

            if( blocks.charAt(right) == 'W' ) {

                currentWhites++;

            }

            minRecolors = Math.min( minRecolors,currentWhites );

        }

        return minRecolors;
        
    }
}
```






#### 定长滑动窗口，注释讲解




好的，作为一名高级软件工程师，我将极尽详细地为你讲解 LeetCode 上的“得到 K 个黑块的最少涂色次数”这道算法题，并提供详细的 Java 代码实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个长度为 `n` 的字符串 `blocks`，由 'W'（白色）和 'B'（黑色）组成。
    *   一个整数 `k`，表示我们想要得到的连续黑色块的数目。
*   **操作**: 每一次操作，你可以选择一个白色块 ('W') 将其涂成黑色块 ('B')。
*   **目标**: 返回至少出现一次连续 `k` 个黑色块的**最少操作次数**。

**关键点**:

*   **连续 `k` 个黑色块**: 我们关注的是一个长度恰好为 `k` 的子字符串，并且这个子字符串中的所有字符都必须是 'B'。
*   **最少操作次数**: 这意味着我们需要找到一个长度为 `k` 的子字符串，其中包含的 'W' 字符数量最少。因为每个 'W' 都需要一次操作才能变成 'B'。

**示例分析：**

假设 `blocks = "WBBWWBBWBW"`, `k = 7`

我们需要找到所有长度为 7 的连续子串，计算每个子串中 'W' 的数量，然后找出最小的那个数量。

*   子串 `blocks[0...6]` = `"WBBWWBB"`
    *   'W' 的数量：3 个 (blocks[0], blocks[3], blocks[4])。
    *   操作次数：3

*   子串 `blocks[1...7]` = `"BBWWBBW"`
    *   'W' 的数量：3 个 (blocks[3], blocks[4], blocks[7])。
    *   操作次数：3

*   子串 `blocks[2...8]` = `"BWWBBWB"`
    *   'W' 的数量：3 个 (blocks[3], blocks[4], blocks[7])。
    *   操作次数：3

*   子串 `blocks[3...9]` = `"WWBBWBW"`
    *   'W' 的数量：4 个 (blocks[3], blocks[4], blocks[7], blocks[9])。
    *   操作次数：4

在所有长度为 7 的子串中，最少的操作次数是 3。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“固定大小滑动窗口”问题。我们需要在所有长度为 `k` 的子串中，找到 'W' 数量最少的那个。

*   **避免重复计算**: 我们不需要每次都重新遍历整个子串来计数 'W'。
*   **增量更新**: 当窗口从一个位置滑动到下一个位置时，我们只需要关注窗口最左边移出的字符和最右边移入的字符，对当前窗口中 'W' 的数量进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **确定窗口大小**: 窗口的固定大小是 `k`。
2.  **初始化窗口**: 首先计算第一个长度为 `k` 的子串（即 `blocks[0...k-1]`）中 'W' 的数量。这个数量就是我们当前的最少操作次数的候选值。
3.  **滑动窗口**: 然后，窗口向右滑动。
    *   当窗口从 `blocks[i...i+k-1]` 滑动到 `blocks[i+1...i+k]` 时：
        *   最左边的字符 `blocks[i]` 被移出窗口。
        *   最右边的字符 `blocks[i+k]` 被移入窗口。
    *   我们只需要根据 `blocks[i]` 是否是 'W' 来减少计数，并根据 `blocks[i+k]` 是否是 'W' 来增加计数。
4.  **更新最小操作次数**: 在每次滑动后，更新当前窗口中 'W' 的数量，并与记录的最小操作次数进行比较，取较小值。

---

3. 数据结构选择

对于这道题，我们只需要几个简单的变量来存储当前的 'W' 数量以及最小的 'W' 数量。不需要复杂的数据结构。

*   `currentWhites`: 记录当前滑动窗口中 'W' 的数量。
*   `minRecolors`: 记录到目前为止找到的，所有长度为 `k` 的子串中 'W' 的最小数量。

---

4. 算法步骤详解

1.  **初始化变量**:
    *   `n = blocks.length()`: 字符串的长度。
    *   `minRecolors = Integer.MAX_VALUE`: 用于存储找到的最少操作次数。初始化为最大整数值，以便第一次比较时能被任何有效值更新。
    *   `currentWhites = 0`: 用于存储当前滑动窗口中 'W' 的数量。

2.  **计算第一个窗口的 'W' 数量**:
    *   遍历字符串 `blocks` 的前 `k` 个字符 (从索引 0 到 `k-1`)。
    *   对于每个字符，如果它是 'W'，则 `currentWhites` 加 1。
    *   将 `minRecolors` 初始化为 `currentWhites`。

3.  **滑动窗口**:
    *   从索引 `k` 开始，遍历字符串直到末尾 (`n - 1`)。这个索引 `i` 代表当前窗口的右边界新加入的字符。
    *   在每次迭代中：
        *   **移出旧字符**: 检查 `blocks.charAt(i - k)` (即窗口最左边即将移出的字符) 是否是 'W'。如果是，`currentWhites` 减 1。
        *   **移入新字符**: 检查 `blocks.charAt(i)` (即窗口最右边新移入的字符) 是否是 'W'。如果是，`currentWhites` 加 1。
        *   **更新最小操作次数**: 将 `minRecolors` 更新为 `Math.min(minRecolors, currentWhites)`。

4.  **返回结果**: 遍历结束后，`minRecolors` 就是最终答案。

---

5. 流程图


---

6. Java 代码实现

```java
class Solution {
    /**
     * 计算得到 k 个连续黑块的最少涂色次数。
     * 使用固定大小的滑动窗口算法。
     *
     * @param blocks 输入的字符串，由 'W' 和 'B' 组成。
     * @param k 想要得到的连续黑色块的数目。
     * @return 至少出现一次连续 k 个黑色块的最少操作次数。
     */
    public int minimumRecolors(String blocks, int k) {
        int n = blocks.length(); // 获取字符串的长度

        // minRecolors 用于记录到目前为止找到的，所有长度为 k 的子串中 'W' 的最小数量。
        // 初始化为 Integer.MAX_VALUE，确保任何有效值都能更新它。
        int minRecolors = Integer.MAX_VALUE;
        
        // currentWhites 用于记录当前滑动窗口中 'W' 的数量。
        int currentWhites = 0;

        // 1. 计算第一个长度为 k 的窗口的 'W' 数量。
        // 窗口范围：blocks[0] 到 blocks[k-1]
        for (int i = 0; i < k; i++) {
            if (blocks.charAt(i) == 'W') {
                currentWhites++;
            }
        }
        // 将第一个窗口的 'W' 数量作为初始的最小操作次数。
        minRecolors = currentWhites;

        // 2. 滑动窗口。
        // 'i' 代表当前窗口的右边界新加入的字符的索引。
        // 循环从 'k' 开始，直到 'n - 1'（字符串的最后一个字符）。
        // 每次循环，窗口的起始索引是 'i - k + 1'，结束索引是 'i'。
        for (int i = k; i < n; i++) {
            // 窗口滑动操作：
            // - 检查即将移出窗口的字符 (blocks[i - k])。
            //   如果它是 'W'，则 currentWhites 减 1。
            if (blocks.charAt(i - k) == 'W') {
                currentWhites--;
            }

            // - 检查新进入窗口的字符 (blocks[i])。
            //   如果它是 'W'，则 currentWhites 加 1。
            if (blocks.charAt(i) == 'W') {
                currentWhites++;
            }

            // 更新 minRecolors，取当前窗口的 'W' 数量与历史最小操作次数之间的较小者。
            minRecolors = Math.min(minRecolors, currentWhites);
        }

        // 遍历结束后，minRecolors 即为所求的最少操作次数。
        return minRecolors;
    }
}
```

---

7. 示例演练

我们以 `blocks = "WBBWWBBWBW"`, `k = 7` 为例，逐步演示代码的执行过程：

*   `n = 10`, `k = 7`
*   `minRecolors = Integer.MAX_VALUE`
*   `currentWhites = 0`

**1. 计算第一个窗口的 'W' 数量 (for i = 0 to 6)**:
   子串是 `blocks[0...6]` = `"WBBWWBB"`
*   `i=0`, `blocks[0] = 'W'`: `currentWhites = 1`
*   `i=1`, `blocks[1] = 'B'`: `currentWhites = 1`
*   `i=2`, `blocks[2] = 'B'`: `currentWhites = 1`
*   `i=3`, `blocks[3] = 'W'`: `currentWhites = 2`
*   `i=4`, `blocks[4] = 'W'`: `currentWhites = 3`
*   `i=5`, `blocks[5] = 'B'`: `currentWhites = 3`
*   `i=6`, `blocks[6] = 'B'`: `currentWhites = 3`
*   **初始化结果**: `minRecolors = currentWhites = 3`。

**2. 滑动窗口 (for i = k to n - 1)**:
   即 `i` 从 `7` 到 `9`。

*   **`i = 7`**:
    *   移除 `blocks[i - k]` = `blocks[7 - 7]` = `blocks[0]` ('W')。
        `currentWhites = 3 - 1 = 2`.
    *   添加 `blocks[i]` = `blocks[7]` ('W')。
        `currentWhites = 2 + 1 = 3`.
    *   `minRecolors = Math.min(3, 3) = 3`.
    *   当前窗口: `blocks[1...7]` = `"BBWWBBW"`，'W' 数量为 3。

*   **`i = 8`**:
    *   移除 `blocks[i - k]` = `blocks[8 - 7]` = `blocks[1]` ('B')。
        `currentWhites` 不变，仍为 3.
    *   添加 `blocks[i]` = `blocks[8]` ('B')。
        `currentWhites` 不变，仍为 3.
    *   `minRecolors = Math.min(3, 3) = 3`.
    *   当前窗口: `blocks[2...8]` = `"BWWBBWB"`，'W' 数量为 3。

*   **`i = 9`**:
    *   移除 `blocks[i - k]` = `blocks[9 - 7]` = `blocks[2]` ('B')。
        `currentWhites` 不变，仍为 3.
    *   添加 `blocks[i]` = `blocks[9]` ('W')。
        `currentWhites = 3 + 1 = 4`.
    *   `minRecolors = Math.min(3, 4) = 3`.
    *   当前窗口: `blocks[3...9]` = `"WWBBWBW"`，'W' 数量为 4。

循环结束。

**3. 返回 `minRecolors`**: 3。与示例输出完全一致。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入字符串 `blocks` 的长度。
    *   我们首先遍历前 `k` 个字符来初始化第一个窗口的 'W' 数量，这需要 `O(k)` 时间。
    *   然后，主循环（滑动窗口）从 `i = k` 遍历到 `N-1`，总共 `N-k` 次迭代。每次迭代中，我们进行常数次操作（字符比较、加减、取最小值）。
    *   因此，总的时间复杂度是 `O(k + (N-k)) = O(N)`，是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`n`, `minRecolors`, `currentWhites`, `i`)。
    *   因此，空间复杂度是常数级别的。

---

希望这个极尽详细的讲解和代码能帮助你完全理解并掌握这道算法题！






---






# 二、不定长滑动窗口
不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。

注：滑动窗口相当于在维护一个队列。右指针的移动可以视作入队，左指针的移动可以视作出队。

## §2.1 求最长/最大

## §2.1.1 基础









### 3. 无重复字符的最长子串

中等

相关标签

相关企业

提示

给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。

     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

 

提示：

0 <= s.length <= 5 * 10^4

s 由英文字母、数字、符号和空格组成


@高级软件工程师 教我如何做这道算法题？使用java语言






#### 不定长滑动窗口，无注释


```java
class Solution {



    public int lengthOfLongestSubstring(String s) {


        if( s == null || s.length() == 0 ) {

            return 0;
        }


        Map<Character,Integer> charIndexMap = new HashMap<>();

        int maxLen = 0;

        int left = 0;


        for( int right=0; right < s.length(); right++ ) {


            char currentChar = s.charAt( right );


            if( charIndexMap.containsKey( currentChar ) && charIndexMap.get(currentChar) >= left ) {

                left = charIndexMap.get(currentChar) + 1;

            }


            charIndexMap.put( currentChar, right );


            int currentWindowLength = right - left + 1;


            maxLen = Math.max( maxLen, currentWindowLength );


        }
        

        return maxLen;
    }


    
}
```






#### 不定长滑动窗口，注释讲解



好的，作为一名高级软件工程师，我来一步步教你如何解决“无重复字符的最长子串”这道算法题。我们将使用 Java 语言来实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**: 一个字符串 `s`。
*   **目标**: 找出 `s` 中不含有重复字符的**最长子串**的长度。
*   **关键点**:
    *   **子串 (Substring)**：是原始字符串中连续的一部分。例如，"abcabcbb" 的子串有 "abc", "bca", "abcbb" 等。
    *   **子序列 (Subsequence)**：不一定是连续的，但字符顺序不变。例如，"pwke" 是 "pwwkew" 的子序列，但不是子串。题目明确要求是**子串**。
    *   **无重复字符**: 子串中的所有字符都必须是唯一的。

**示例分析：**

*   `s = "abcabcbb"`
    *   "abc" 是一个无重复字符的子串，长度为 3。
    *   "bca" 也是，长度为 3。
    *   "cab" 也是，长度为 3。
    *   "abca" 包含重复字符 'a'，不是。
    *   最长的无重复字符子串是 "abc", "bca", "cab"，它们的长度都是 3。所以输出 3。

*   `s = "bbbbb"`
    *   最长的无重复字符子串是 "b"，长度为 1。所以输出 1。

*   `s = "pwwkew"`
    *   "pw" 长度 2。
    *   "pww" 包含重复 'w'。
    *   "wk" 长度 2。
    *   "wke" 长度 3。
    *   "kew" 长度 3。
    *   最长的无重复字符子串是 "wke" 或 "kew"，长度都是 3。所以输出 3。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题非常适合使用“滑动窗口”算法来解决。滑动窗口是一种常用的算法技巧，用于解决数组或字符串的子数组/子串问题。它的基本思想是维护一个窗口（通常由两个指针 `left` 和 `right` 定义），然后根据条件移动窗口的边界。

**滑动窗口的优势：**

*   避免了暴力枚举所有子串（时间复杂度过高）。
*   通过只遍历字符串一次（或常数次），大大提高了效率。

**对于这道题，滑动窗口的工作原理如下：**

1.  我们用两个指针 `left` 和 `right` 来定义当前考察的“窗口” `s[left...right]`。
2.  `right` 指针会不断向右移动，扩展窗口。
3.  在窗口扩展的过程中，我们需要检查新加入的字符 `s[right]` 是否已经在当前窗口 `s[left...right-1]` 中出现过。
4.  如果 `s[right]` **没有**出现过，说明当前窗口 `s[left...right]` 仍然是无重复字符的，我们可以更新最大长度，并继续向右扩展 `right`。
5.  如果 `s[right]` **已经**出现过，说明当前窗口 `s[left...right]` 包含了重复字符。为了消除重复，我们需要收缩窗口，即移动 `left` 指针。`left` 指针应该移动到哪里呢？它应该移动到重复字符的**下一个位置**，这样才能确保新的窗口 `s[new_left...right]` 不再包含重复字符。
6.  重复步骤 2-5，直到 `right` 指针遍历完整个字符串。

---

3. 数据结构选择

为了高效地判断字符是否重复以及快速找到重复字符的位置，我们需要一个数据结构来存储窗口内的字符及其位置。

*   **`HashSet<Character>`**: 可以快速判断字符是否存在（O(1) 时间复杂度），但无法直接获取字符的索引，当遇到重复字符时，`left` 指针需要一个一个地向右移动，直到重复字符被移除。
*   **`HashMap<Character, Integer>`**: 键是字符，值是字符在字符串中出现的**最新索引**。
    *   优点：可以快速判断字符是否存在 (O(1))。当遇到重复字符时，可以直接通过 `map.get(char)` 获取其上次出现的索引，然后将 `left` 指针直接跳到 `上次出现索引 + 1` 的位置，从而更高效地收缩窗口。这是更优的选择。

我们将使用 `HashMap<Character, Integer>`。

---

4. 算法步骤详解

1.  **初始化变量**:
    *   `maxLength = 0`: 用于存储找到的最长无重复字符子串的长度。
    *   `left = 0`: 滑动窗口的左边界。
    *   `Map<Character, Integer> charIndexMap = new HashMap<>()`: 用于存储字符及其在字符串中最新出现的索引。

2.  **遍历字符串**: 使用 `right` 指针从 `0` 遍历到 `s.length() - 1`。

    *   对于每个字符 `s.charAt(right)`：

        a.  **检查重复**:
            *   判断 `charIndexMap` 中是否已经包含了 `s.charAt(right)`。
            *   如果包含，并且 `charIndexMap.get(s.charAt(right))` (即该字符上次出现的索引) **大于或等于** `left` (这意味着上次出现的位置在当前窗口内)，则说明当前窗口内有重复字符。
            *   此时，需要将 `left` 移动到 `charIndexMap.get(s.charAt(right)) + 1`。这样，窗口的左边界就跳过了重复字符及其之前的部分，确保新窗口是无重复的。

        b.  **更新字符索引**:
            *   无论是否发生重复，都需要更新 `charIndexMap` 中 `s.charAt(right)` 的最新索引为当前的 `right`。`charIndexMap.put(s.charAt(right), right)`。

        c.  **更新最大长度**:
            *   当前无重复子串的长度是 `right - left + 1`。
            *   将 `maxLength` 更新为 `Math.max(maxLength, right - left + 1)`。

3.  **返回结果**: 遍历结束后，`maxLength` 就是最终答案。

---

5. 流程图


---

6. Java 代码实现

```java
class Solution {
    /**
     * 找出字符串中不含有重复字符的最长子串的长度。
     * 使用滑动窗口（Sliding Window）算法。
     *
     * @param s 输入字符串
     * @return 最长无重复字符子串的长度
     */
    public int lengthOfLongestSubstring(String s) {
        // 如果输入字符串为空或为null，则最长子串长度为0
        if (s == null || s.length() == 0) {
            return 0;
        }

        // 用于存储字符及其在字符串中最新出现的索引
        // 键：字符 (Character)
        // 值：字符在字符串中出现的最新索引 (Integer)
        java.util.Map<Character, Integer> charIndexMap = new java.util.HashMap<>();

        // maxLen 用于记录到目前为止找到的最长无重复字符子串的长度
        int maxLen = 0;
        // left 是滑动窗口的左边界指针
        int left = 0;

        // right 是滑动窗口的右边界指针，它会遍历整个字符串
        for (int right = 0; right < s.length(); right++) {
            // 获取当前右指针指向的字符
            char currentChar = s.charAt(right);

            // 检查当前字符是否已经在 charIndexMap 中存在，并且其上次出现的索引在当前窗口 [left, right-1] 内
            // 如果 charIndexMap.containsKey(currentChar) 为真，说明之前出现过这个字符
            // 如果 charIndexMap.get(currentChar) >= left 为真，说明上次出现的位置在当前窗口的左边界或右边界之间
            if (charIndexMap.containsKey(currentChar) && charIndexMap.get(currentChar) >= left) {
                // 如果有重复字符，并且该重复字符在当前窗口内，
                // 则需要移动左边界（left）到重复字符的下一个位置，
                // 这样可以确保当前窗口内不再包含这个重复字符。
                left = charIndexMap.get(currentChar) + 1;
            }

            // 更新或添加当前字符的最新索引到 charIndexMap
            // 无论字符是否重复，我们都更新它的最新位置。
            charIndexMap.put(currentChar, right);

            // 计算当前无重复字符子串的长度
            // 长度 = 右边界索引 - 左边界索引 + 1
            int currentWindowLength = right - left + 1;

            // 更新最长无重复字符子串的长度
            maxLen = Math.max(maxLen, currentWindowLength);
        }

        // 遍历结束后，maxLen 即为所求的最长无重复字符子串的长度
        return maxLen;
    }
}
```

---

7. 示例演练

我们以 `s = "abcabcbb"` 为例，逐步演示代码的执行过程：

| `right` | `currentChar` | `charIndexMap` (更新前) | `charIndexMap.get(currentChar)` >= `left`? | `left` (更新后) | `charIndexMap` (更新后) | `currentWindowLength` (`right - left + 1`) | `maxLen` | 备注 |
| :------ | :------------ | :---------------------- | :----------------------------------------- | :-------------- | :---------------------- | :------------------------------------------- | :------- | :--- |
| 0       | 'a'           | {}                      | 否                                         | 0               | {'a': 0}                | 0 - 0 + 1 = 1                                | 1        | 窗口: "a" |
| 1       | 'b'           | {'a': 0}                | 否                                         | 0               | {'a': 0, 'b': 1}        | 1 - 0 + 1 = 2                                | 2        | 窗口: "ab" |
| 2       | 'c'           | {'a': 0, 'b': 1}        | 否                                         | 0               | {'a': 0, 'b': 1, 'c': 2}| 2 - 0 + 1 = 3                                | 3        | 窗口: "abc" |
| 3       | 'a'           | {'a': 0, 'b': 1, 'c': 2}| `map.get('a')` (0) >= `left` (0)? 是       | 0 + 1 = 1       | {'a': 3, 'b': 1, 'c': 2}| 3 - 1 + 1 = 3                                | 3        | 'a' 重复，`left` 移到 1。窗口: "bca" |
| 4       | 'b'           | {'a': 3, 'b': 1, 'c': 2}| `map.get('b')` (1) >= `left` (1)? 是       | 1 + 1 = 2       | {'a': 3, 'b': 4, 'c': 2}| 4 - 2 + 1 = 3                                | 3        | 'b' 重复，`left` 移到 2。窗口: "cab" |
| 5       | 'c'           | {'a': 3, 'b': 4, 'c': 2}| `map.get('c')` (2) >= `left` (2)? 是       | 2 + 1 = 3       | {'a': 3, 'b': 4, 'c': 5}| 5 - 3 + 1 = 3                                | 3        | 'c' 重复，`left` 移到 3。窗口: "abc" |
| 6       | 'b'           | {'a': 3, 'b': 4, 'c': 5}| `map.get('b')` (4) >= `left` (3)? 是       | 4 + 1 = 5       | {'a': 3, 'b': 6, 'c': 5}| 6 - 5 + 1 = 2                                | 3        | 'b' 重复，`left` 移到 5。窗口: "bb" (但实际是 'b') |
| 7       | 'b'           | {'a': 3, 'b': 6, 'c': 5}| `map.get('b')` (6) >= `left` (5)? 是       | 6 + 1 = 7       | {'a': 3, 'b': 7, 'c': 5}| 7 - 7 + 1 = 1                                | 3        | 'b' 重复，`left` 移到 7。窗口: "b" |

最终 `maxLen` 为 3。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入字符串 `s` 的长度。
    *   `right` 指针从头到尾遍历了字符串一次。
    *   `left` 指针也最多从头到尾遍历字符串一次（它只会向右移动，不会回退）。
    *   `HashMap` 的操作（`containsKey`, `get`, `put`）在平均情况下是 `O(1)` 的时间复杂度。
    *   因此，总的时间复杂度是线性的，非常高效。

*   **空间复杂度**: `O(min(N, M))`。
    *   `M` 是字符集的大小。对于英文字母、数字、符号和空格组成的字符串，`M` 是一个常数（例如，ASCII 字符集大小为 128 或 Unicode 字符集更大，但实际使用的字符种类通常有限）。
    *   `HashMap` 最多存储 `min(N, M)` 个不重复的字符。
    *   在最坏情况下，如果所有字符都不重复，`HashMap` 会存储 `N` 个字符。但如果字符集很小，比如只有小写字母，那么最多存储 26 个字符。
    *   因此，空间复杂度取决于字符串长度和字符集大小中的较小者。

---

希望这个详细的解释和代码能帮助你完全理解并掌握这道算法题！









### 3090. 每个字符最多出现两次的最长子字符串
已解答
简单
相关标签
premium lock icon
相关企业
提示
给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该子字符串的 最大 长度。

 

示例 1：
输入： s = "bcbbbcba"
输出： 4
解释：
以下子字符串长度为 4，并且每个字符最多出现两次："bcbbbcba"。

示例 2：
输入： s = "aaaa"
输出： 2
解释：
以下子字符串长度为 2，并且每个字符最多出现两次："aaaa"。

 

提示：

2 <= s.length <= 100
s 仅由小写英文字母组成。







#### 不定长滑动窗口，无注释



```java
class Solution {
    public int maximumLengthSubstring(String s) {
        

        int n = s.length();

        int maxLen = 0;

        int left = 0;

        int[] counts = new int[26];

        for( int right=0; right < n; right++ ) {

            char charR = s.charAt( right );

            counts[ charR - 'a' ]++;


            while( counts[ charR - 'a' ] > 2 ) {

                char charL = s.charAt( left );

                counts[ charL - 'a' ]--;

                left++;

            }


            int currentWindowLength = right - left + 1;

            maxLen = Math.max( maxLen, currentWindowLength );


        }


        return maxLen;




    }
}
```






#### 不定长滑动窗口，注释讲解






好的，作为一名高级软件工程师，我将极尽详细地为你讲解 LeetCode 上的“每个字符最多出现两次的最长子字符串”这道算法题，并提供详细的 Java 代码实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**: 一个长度为 `n` 的字符串 `s`，其中只包含小写英文字母。
*   **目标**: 找出 `s` 中满足以下条件的**最长子字符串**，并返回该子字符串的**最大长度**：
    *   子字符串中的**每个字符最多出现两次**。
*   **操作**: 不涉及操作，只是查找。

**关键点**:

*   **子字符串 (Substring)**：是原始字符串中连续的一部分。
*   **每个字符最多出现两次**: 例如，如果子字符串是 "banana"，'a' 出现了 3 次，就不符合条件。如果是 "apple"，'p' 出现了 2 次，符合条件。
*   **最长**: 我们需要找到所有符合条件的子字符串中，长度最大的那个。

**示例分析：**

*   `s = "bcbbbcba"`
    *   `"b"`: 'b' 1次。长度 1。
    *   `"bc"`: 'b' 1次, 'c' 1次。长度 2。
    *   `"bcb"`: 'b' 2次, 'c' 1次。长度 3。
    *   `"bcbb"`: 'b' 3次。不符合条件。
    *   `"cbb"`: 'c' 1次, 'b' 2次。长度 3。
    *   `"cbba"`: 'c' 1次, 'b' 2次, 'a' 1次。长度 4。符合条件。
    *   `"bbca"`: 'b' 2次, 'c' 1次, 'a' 1次。长度 4。符合条件。
    *   观察发现，最长的符合条件的子字符串是 "cbba" 或 "bbca"，它们的长度都是 4。所以输出 4。

*   `s = "aaaa"`
    *   `"a"`: 'a' 1次。长度 1。
    *   `"aa"`: 'a' 2次。长度 2。
    *   `"aaa"`: 'a' 3次。不符合条件。
    *   最长的符合条件的子字符串是 "aa"，长度 2。所以输出 2。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“寻找满足特定条件的最长子字符串”问题，非常适合使用**滑动窗口**算法。

*   **窗口定义**: 我们使用两个指针 `left` 和 `right` 来定义当前正在考虑的子字符串，即 `s[left...right]`。
*   **扩展窗口**: `right` 指针会不断向右移动，将新的字符 `s.charAt(right)` 加入到窗口中。
*   **维护条件**: 在窗口扩展的过程中，我们需要实时检查窗口内字符的出现次数是否满足“每个字符最多出现两次”的条件。
*   **收缩窗口**: 如果加入新字符后，某个字符的出现次数超过了两次，那么当前窗口就不再合法了。此时，我们需要移动 `left` 指针向右收缩窗口，从窗口的左侧移除字符，直到窗口再次变得合法（即所有字符的出现次数都不超过两次）。
*   **更新结果**: 每当窗口合法时，我们就可以计算当前子字符串的长度 (`right - left + 1`)，并用它来更新我们找到的最长长度。

**如何判断条件是否满足？**

为了高效地跟踪窗口内每个字符的出现次数，我们可以使用一个**哈希表**或一个**频率数组**。由于题目明确指出字符串只包含小写英文字母（共26种），使用一个大小为 26 的整数数组 `int[26]` 来充当频率计数器是最优的选择。数组的索引 `0` 对应字符 'a'，`1` 对应 'b'，以此类推，索引 `c - 'a'` 对应字符 `c`。

---

3. 数据结构选择

*   `int[] counts = new int[26]`: 这是一个长度为 26 的整数数组，用于存储当前滑动窗口中每个小写字母的出现频率。`counts[0]` 存储 'a' 的频率，`counts[1]` 存储 'b' 的频率，以此类推。数组元素默认初始化为 0。
*   `int maxLen`: 用于存储到目前为止找到的满足条件的最长子字符串的长度。
*   `int left`: 滑动窗口的左边界指针。

---

4. 算法步骤详解

1.  **初始化**:
    *   获取输入字符串 `s` 的长度 `n`。
    *   初始化 `maxLen = 0`，表示目前找到的最长合法子字符串长度为 0。
    *   初始化 `left = 0`，表示滑动窗口的初始左边界在字符串的起始位置。
    *   创建一个 `int[] counts = new int[26]`，用于存储字符频率。所有元素默认值为 0。

2.  **遍历字符串 (右指针 `right`)**:
    *   使用一个 `for` 循环，让 `right` 指针从 `0` 遍历到 `n - 1`（字符串的最后一个字符）。
    *   在每次循环迭代中，`right` 指针指向的字符 `s.charAt(right)` 被视为新加入窗口的元素。

3.  **将新字符加入窗口并更新频率**:
    *   获取当前右指针指向的字符 `charR = s.charAt(right)`。
    *   将 `charR` 的频率加 1：`counts[charR - 'a']++`。

4.  **检查条件并收缩窗口**:
    *   在将 `charR` 加入窗口后，我们需要检查它是否导致了某个字符的频率超过 2。
    *   使用一个 `while` 循环来收缩窗口：`while (counts[charR - 'a'] > 2)`。
        *   这个 `while` 循环的条件是：如果当前 `charR` 的频率超过了 2，说明窗口不合法，需要收缩。
        *   在 `while` 循环内部，执行以下操作：
            *   获取左指针指向的字符 `charL = s.charAt(left)`。
            *   将 `charL` 的频率减 1：`counts[charL - 'a']--`（因为它即将从窗口中移除）。
            *   将 `left` 指针向右移动一位：`left++`。
        *   这个 `while` 循环会一直执行，直到 `counts[charR - 'a']` 的值不再大于 2。注意，`while` 循环条件只关注导致不合法的那个字符 `charR`，因为它是最近加入的，它最有可能导致不合法。当 `charR` 的频率恢复到 <= 2 时，窗口就再次合法了，因为其他字符的频率要么不变，要么因为 `left` 移动而减少，所以它们也不会超过 2。

5.  **更新最长长度**:
    *   在 `while` 循环结束后，当前滑动窗口 `s[left...right]` 已经是一个合法的子字符串（所有字符频率都最多为 2）。
    *   计算当前合法子字符串的长度：`currentLength = right - left + 1`。
    *   更新 `maxLen`：`maxLen = Math.max(maxLen, currentLength)`。

6.  **返回结果**:
    *   当 `right` 指针遍历完整个字符串后，`maxLen` 将存储满足条件的最长子字符串的长度。返回 `maxLen`。

---

5. 流程图


---

6. Java 代码实现

```java
import java.util.Arrays; // 导入 Arrays 工具类，虽然这里没直接用，但有时用于调试或初始化

class Solution {
    /**
     * 找出字符串中满足每个字符最多出现两次的最长子字符串的长度。
     * 使用滑动窗口（Sliding Window）算法。
     *
     * @param s 输入字符串，仅由小写英文字母组成。
     * @return 满足条件的最长子字符串的最大长度。
     */
    public int maximumLengthSubstring(String s) {
        int n = s.length(); // 获取输入字符串的长度
        int maxLen = 0;     // 用于存储找到的最长合法子字符串的长度
        int left = 0;       // 滑动窗口的左边界指针

        // counts 数组用于存储当前滑动窗口中每个字符的出现次数。
        // 数组大小为 26，因为字符串只包含小写英文字母（'a' 到 'z'）。
        // counts[0] 对应 'a' 的计数，counts[1] 对应 'b' 的计数，以此类推。
        // 数组元素默认初始化为 0。
        int[] counts = new int[26]; 

        // right 是滑动窗口的右边界指针，它会从字符串的开头遍历到结尾。
        for (int right = 0; right < n; right++) {
            // 获取当前右指针指向的字符。
            char charR = s.charAt(right);
            
            // 将当前字符 charR 加入到滑动窗口中，并更新其在 counts 数组中的计数。
            counts[charR - 'a']++;

            // 检查当前窗口是否满足条件：即新加入的字符 charR 的出现次数是否超过 2。
            // 如果 counts[charR - 'a'] > 2，说明当前窗口不再合法，需要收缩窗口。
            while (counts[charR - 'a'] > 2) {
                // 获取左指针指向的字符。这个字符即将从窗口中移除。
                char charL = s.charAt(left);
                
                // 将左指针指向的字符 charL 从窗口中移除，并更新其在 counts 数组中的计数。
                counts[charL - 'a']--;
                
                // 移动左指针，收缩窗口。
                left++;
            }

            // 此时，当前滑动窗口 [left, right] 是一个合法的子字符串，
            // 因为在 `while` 循环的作用下，所有字符的出现次数都已保证最多为 2。
            
            // 计算当前合法子字符串的长度。
            int currentWindowLength = right - left + 1;
            
            // 更新 maxLen，取当前合法子字符串的长度与历史最大长度之间的较大者。
            maxLen = Math.max(maxLen, currentWindowLength);
        }

        // 遍历结束后，maxLen 即为所求的满足条件的最长子字符串的长度。
        return maxLen;
    }
}
```

---

7. 示例演练

我们以 `s = "bcbbbcba"` 为例，逐步演示代码的执行过程：

*   `n = 8`, `maxLen = 0`, `left = 0`, `counts = [0,0,...,0]` (26个0)

| `right` | `charR` | `counts` (charR - 'a') | `while` 循环条件 (`counts[charR-'a'] > 2`) | `charL` (移除) | `counts` (charL - 'a') | `left` (更新后) | `maxLen` (更新后) | 窗口 (`s[left...right]`) | 备注 |
| :------ | :------ | :--------------------- | :----------------------------------------- | :------------- | :--------------------- | :-------------- | :---------------- | :-------------------- | :--- |
| 0       | 'b'     | `counts['b'-'a']` = 1  | 否                                         | -              | -                      | 0               | `max(0, 1)` = 1   | "b"                   | 'b':1 |
| 1       | 'c'     | `counts['c'-'a']` = 1  | 否                                         | -              | -                      | 0               | `max(1, 2)` = 2   | "bc"                  | 'b':1, 'c':1 |
| 2       | 'b'     | `counts['b'-'a']` = 2  | 否                                         | -              | -                      | 0               | `max(2, 3)` = 3   | "bcb"                 | 'b':2, 'c':1 |
| 3       | 'b'     | `counts['b'-'a']` = 3  | 是 (因为 'b' 的计数为 3)                   | 'b'            | `counts['b'-'a']` = 2  | 1               | `max(3, 3)` = 3   | "cbb"                 | 'b':2, 'c':1 (移除 's[0]'='b') |
| 4       | 'b'     | `counts['b'-'a']` = 3  | 是 (因为 'b' 的计数为 3)                   | 'c'            | `counts['c'-'a']` = 0  | 2               | `max(3, 3)` = 3   | "bbb" (这里是错的，因为'b'还是3次) | 'b':3, 'c':0 (移除 's[1]'='c') |
|         |         |                        | 是 (因为 'b' 的计数仍为 3)                 | 'b'            | `counts['b'-'a']` = 2  | 3               | `max(3, 2)` = 3   | "bb"                  | 'b':2 (移除 's[2]'='b') |
| 5       | 'c'     | `counts['c'-'a']` = 1  | 否                                         | -              | -                      | 3               | `max(3, 3)` = 3   | "bbc"                 | 'b':2, 'c':1 |
| 6       | 'b'     | `counts['b'-'a']` = 3  | 是 (因为 'b' 的计数为 3)                   | 'b'            | `counts['b'-'a']` = 2  | 4               | `max(3, 3)` = 3   | "bcb"                 | 'b':2, 'c':1 (移除 's[3]'='b') |
| 7       | 'a'     | `counts['a'-'a']` = 1  | 否                                         | -              | -                      | 4               | `max(3, 4)` = 4   | "bcba"                | 'a':1, 'b':2, 'c':1 |

最终 `maxLen` 为 4。与示例输出完全一致。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入字符串 `s` 的长度。
    *   `right` 指针从头到尾遍历字符串一次，总共 `N` 次迭代。
    *   `left` 指针也只会向右移动，并且在整个过程中，`left` 指针的总移动次数不会超过 `N` 次（因为 `left` 最多从 0 移动到 `N-1`）。
    *   `counts` 数组的增减操作是常数时间 `O(1)`。
    *   因此，总的时间复杂度是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   `counts` 数组的大小是固定的 26（因为只有小写英文字母），它不随输入字符串的长度 `N` 变化。
    *   其他变量 (`n`, `maxLen`, `left`, `charR`, `charL`) 都只占用常数空间。
    *   因此，空间复杂度是常数级别的。

---

希望这个极尽详细的讲解和代码能帮助你完全理解并掌握这道算法题！









### 1493. 删掉一个元素以后全为 1 的最长子数组
已解答
中等
相关标签
premium lock icon
相关企业
提示
给你一个二进制数组 nums ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

 

提示 1：

输入：nums = [1,1,0,1]
输出：3
解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。

示例 2：

输入：nums = [0,1,1,1,0,1,1,0,1]
输出：5
解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。

示例 3：

输入：nums = [1,1,1]
输出：2
解释：你必须要删除一个元素。
 

提示：

1 <= nums.length <= 10^5
nums[i] 要么是 0 要么是 1 。







#### 不定长滑动窗口，无注释




```java
class Solution {
    public int longestSubarray(int[] nums) {


        int n = nums.length;

        int currentNum = 0;

        int maxLength = 0;

        int left=0;

        int right;

        int cnt = 0;

        int removeIndex = 0;

        if( nums == null && n == 0 ) {

            return 0;
        }


        for( right=0; right < n  ; right++ ) {
            

            if( nums[right] == 1 ) {

                


            } else {
                // nums[right] == 0

                cnt++;


            }


            
            while( cnt > 1 ) {

                if( nums[left] == 0 ) {

                    cnt--;
                }

                left++;
            } 


            currentNum = right - left + 1 - 1;


            maxLength = Math.max( maxLength, currentNum );


        }



        return maxLength;

        
    }
}
```








#### 不定长滑动窗口，注释讲解


好的，作为一名高级软件工程师，我将极尽详细地为你讲解 LeetCode 上的“删掉一个元素以后全为 1 的最长子数组”这道算法题，并提供详细的 Java 代码实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**: 一个二进制数组 `nums`，只包含 `0` 和 `1`。
*   **操作**: 你**必须**从数组中删掉**一个**元素。
*   **目标**: 在删掉一个元素后的结果数组中，找到**最长**的且只包含 `1` 的**非空子数组**的长度。
*   **特殊情况**: 如果不存在这样的子数组（即删掉一个元素后，没有连续的 `1`），返回 `0`。

**关键点**:

*   **二进制数组**: 元素只有 `0` 或 `1`。
*   **删掉一个元素**: 这是强制性的，即使原数组全是 `1`，也要删掉一个。
*   **最长全 `1` 子数组**: 目标是找到一段连续的 `1`。
*   **非空子数组**: 结果长度不能是负数，且如果得到的是空数组，则长度为 0。

**示例分析：**

*   `nums = [1,1,0,1]`
    *   删除 `nums[0]` (1): `[1,0,1]` -> 最长全 `1` 子数组是 `[1]` (长度 1)。
    *   删除 `nums[1]` (1): `[1,0,1]` -> 最长全 `1` 子数组是 `[1]` (长度 1)。
    *   删除 `nums[2]` (0): `[1,1,1]` -> 最长全 `1` 子数组是 `[1,1,1]` (长度 3)。
    *   删除 `nums[3]` (1): `[1,1,0]` -> 最长全 `1` 子数组是 `[1,1]` (长度 2)。
    *   最大长度是 3。

*   `nums = [0,1,1,1,0,1,1,0,1]`
    *   如果我们删除 `nums[4]` (0)，原数组变为 `[0,1,1,1,1,1,0,1]`。
    *   其中最长的全 `1` 子数组是 `[1,1,1,1,1]`，长度为 5。
    *   这是通过删除一个 `0` 来连接两个 `1` 的连续段。

*   `nums = [1,1,1]`
    *   我们**必须**删除一个元素。
    *   删除任意一个 `1` 后，数组变为 `[1,1]`。
    *   最长全 `1` 子数组是 `[1,1]`，长度为 2。

**核心转化**:

题目要求删除一个元素后得到最长全 `1` 子数组。这等价于在原数组中找到一个子数组，它**最多包含一个 `0`**。
*   如果找到一个子数组，它恰好包含**一个 `0`**：删除这个 `0`，那么这个子数组两边的 `1` 就可以连接起来，形成一个更长的全 `1` 子数组。它的长度就是原窗口的长度减 1（因为删掉了那个 `0`）。
*   如果找到一个子数组，它包含**零个 `0`**（即全是 `1`）：我们仍然**必须**删除一个元素。所以我们只能删除这个子数组中的一个 `1`。这样，最终得到的全 `1` 子数组长度是原窗口长度减 1。

**结论**: 无论窗口内是零个 `0` 还是一个 `0`，我们最终都能得到一个全 `1` 的子数组，其长度等于**当前窗口的长度减 1**。因此，我们的目标是找到一个**最多包含一个 `0`** 的**最长子数组**，然后返回它的长度减 1。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“在满足某个条件（最多包含 K 个特定元素）的情况下寻找最长子数组”问题。这里 K=1 (最多一个 '0')。

*   **窗口定义**: 我们使用两个指针 `left` 和 `right` 来定义当前正在考虑的子数组 `nums[left...right]`。
*   **扩展窗口**: `right` 指针会不断向右移动，将新的元素 `nums[right]` 加入到窗口中。
*   **维护条件**: 我们需要实时跟踪窗口内 `0` 的数量。
*   **收缩窗口**: 如果加入新元素后，窗口内 `0` 的数量超过了 `1`（即 `zeroCount > 1`），那么当前窗口就不再合法了。此时，我们需要移动 `left` 指针向右收缩窗口，从窗口的左侧移除元素，直到窗口再次变得合法（即 `zeroCount <= 1`）。
*   **更新结果**: 每当窗口合法时（即 `zeroCount <= 1`），我们就可以计算当前子数组的长度减 1 (`(right - left + 1) - 1 = right - left`)，并用它来更新我们找到的最长长度。

---

3. 数据结构选择

*   `int zeroCount`: 记录当前滑动窗口中 `0` 的数量。
*   `int maxLen`: 记录到目前为止找到的，通过删除一个元素后，最长的全 `1` 子数组的长度。
*   `int left`: 滑动窗口的左边界指针。

---

4. 算法步骤详解

1.  **初始化变量**:
    *   `n = nums.length`: 数组的长度。
    *   `maxLen = 0`: 用于存储找到的最长全 `1` 子数组的长度。
    *   `left = 0`: 滑动窗口的左边界指针。
    *   `zeroCount = 0`: 记录当前窗口中 `0` 的数量。

2.  **遍历数组 (右指针 `right`)**:
    *   使用一个 `for` 循环，让 `right` 指针从 `0` 遍历到 `n - 1`（数组的最后一个元素）。
    *   在每次循环迭代中，`right` 指针指向的元素 `nums[right]` 被视为新加入窗口的元素。

3.  **将新元素加入窗口并更新 `zeroCount`**:
    *   如果 `nums[right]` 是 `0`，则 `zeroCount` 加 1。

4.  **检查条件并收缩窗口**:
    *   在将 `nums[right]` 加入窗口后，我们需要检查 `zeroCount` 是否超过 `1`。
    *   使用一个 `while` 循环来收缩窗口：`while (zeroCount > 1)`。
        *   这个 `while` 循环的条件是：如果当前窗口中 `0` 的数量超过了 1，说明窗口不合法，需要收缩。
        *   在 `while` 循环内部，执行以下操作：
            *   如果 `nums[left]` 是 `0`（即左侧即将移出的元素是 `0`），则 `zeroCount` 减 1。
            *   将 `left` 指针向右移动一位：`left++`。
        *   这个 `while` 循环会一直执行，直到 `zeroCount` 的值不再大于 1。

5.  **更新最长长度**:
    *   在 `while` 循环结束后，当前滑动窗口 `nums[left...right]` 已经是一个合法的子数组（其中 `0` 的数量最多为 1）。
    *   计算当前合法子数组的长度，并减去 1（因为我们必须删除一个元素）：`currentLengthAfterDeletion = (right - left + 1) - 1 = right - left`。
    *   更新 `maxLen`：`maxLen = Math.max(maxLen, currentLengthAfterDeletion)`。

6.  **特殊处理全 `1` 数组**:
    *   考虑一种特殊情况：如果整个数组 `nums` 都由 `1` 组成（例如 `[1,1,1]`）。
    *   按照上述逻辑，`zeroCount` 将始终为 `0`。
    *   当 `right` 遍历到 `n-1` 时，`left` 仍然是 `0`。
    *   `maxLen` 会被更新为 `(n-1) - 0 = n-1`。
    *   这恰好符合题意：如果 `nums = [1,1,1]`，必须删除一个，得到 `[1,1]`，长度为 2 (`3-1`)。
    *   所以，我们的 `maxLen = right - left` 逻辑已经包含了这种“删除一个 `1`”的情况，无需额外判断。

7.  **返回结果**:
    *   当 `right` 指针遍历完整个数组后，`maxLen` 将存储满足条件的最长全 `1` 子数组的长度。返回 `maxLen`。

---

5. 流程图


---

6. Java 代码实现

```java
class Solution {
    /**
     * 删掉一个元素以后，返回最长的只包含 1 的非空子数组的长度。
     * 使用滑动窗口（Sliding Window）算法。
     *
     * @param nums 输入的二进制数组。
     * @return 最长的全 1 子数组的长度。
     */
    public int longestSubarray(int[] nums) {
        int n = nums.length; // 获取数组的长度
        int maxLen = 0;      // 用于存储找到的最长全 1 子数组的长度
        int left = 0;        // 滑动窗口的左边界指针
        int zeroCount = 0;   // 记录当前滑动窗口中 '0' 的数量

        // right 是滑动窗口的右边界指针，它会从数组的开头遍历到结尾。
        for (int right = 0; right < n; right++) {
            // 如果当前右指针指向的元素是 '0'，则增加 zeroCount。
            if (nums[right] == 0) {
                zeroCount++;
            }

            // 检查当前窗口是否满足条件：即窗口中 '0' 的数量是否超过 1。
            // 如果 zeroCount > 1，说明当前窗口不再合法（因为我们只能删除一个 0），需要收缩窗口。
            while (zeroCount > 1) {
                // 如果左指针指向的元素是 '0'，则在将其移出窗口时，减少 zeroCount。
                if (nums[left] == 0) {
                    zeroCount--;
                }
                // 移动左指针，收缩窗口。
                left++;
            }

            // 此时，当前滑动窗口 [left, right] 是一个合法的子数组，
            // 因为在 `while` 循环的作用下，zeroCount 已经保证最多为 1。
            
            // 计算当前合法子数组在删除一个元素（无论是 0 还是 1）后的长度。
            // 窗口长度是 (right - left + 1)。
            // 无论窗口中有一个 0 还是没有 0，我们都必须删除一个元素。
            // 如果有一个 0，删除它，得到 (right - left + 1) - 1 = right - left 个 1。
            // 如果没有 0，删除一个 1，得到 (right - left + 1) - 1 = right - left 个 1。
            int currentResultLength = right - left;
            
            // 更新 maxLen，取当前结果长度与历史最大长度之间的较大者。
            maxLen = Math.max(maxLen, currentResultLength);
        }

        // 考虑全 1 数组的情况：例如 nums = [1,1,1]。
        // 按照上述逻辑，zeroCount 始终为 0，maxLen 最终会是 (n-1) - 0 = n-1。
        // 对于 [1,1,1]，n=3，maxLen = 2。这符合题意（必须删除一个 1，得到 [1,1]）。
        // 如果数组中没有 0，我们最终会得到 n-1 个 1。
        // 如果数组中至少有一个 0，maxLen 会是连接两个 1 块后的长度，或者单个 1 块的长度。

        // 唯一需要额外考虑的是，如果整个数组都是 1，maxLen 会是 n-1。
        // 但如果数组是 [0,0,0]，maxLen 会是 0。
        // 题目要求“非空子数组”，所以 0 是合法返回值。
        
        return maxLen;
    }
}
```

---

7. 示例演练

我们以 `nums = [0,1,1,1,0,1,1,0,1]` 为例，逐步演示代码的执行过程：

*   `n = 9`, `maxLen = 0`, `left = 0`, `zeroCount = 0`

| `right` | `nums[right]` | `zeroCount` (更新前) | `zeroCount` (更新后) | `while zeroCount > 1`? | `nums[left]` (移除) | `zeroCount` (移除后) | `left` (更新后) | `maxLen` (更新后) | 窗口 `nums[left...right]` | 备注 |
| :------ | :------------ | :------------------- | :------------------- | :--------------------- | :------------------ | :------------------- | :-------------- | :---------------- | :------------------------ | :--- |
| 0       | 0             | 0                    | 1                    | 否                     | -                   | -                    | 0               | `max(0, 0-0)`=0   | `[0]`                     | 1个0 |
| 1       | 1             | 1                    | 1                    | 否                     | -                   | -                    | 0               | `max(0, 1-0)`=1   | `[0,1]`                   | 1个0 |
| 2       | 1             | 1                    | 1                    | 否                     | -                   | -                    | 0               | `max(1, 2-0)`=2   | `[0,1,1]`                 | 1个0 |
| 3       | 1             | 1                    | 1                    | 否                     | -                   | -                    | 0               | `max(2, 3-0)`=3   | `[0,1,1,1]`               | 1个0 |
| 4       | 0             | 1                    | 2                    | 是                     | `nums[0]`(0)        | 1                    | 1               | `max(3, 4-1)`=3   | `[1,1,1,0]`               | 2个0，移除最左0 |
| 5       | 1             | 1                    | 1                    | 否                     | -                   | -                    | 1               | `max(3, 5-1)`=4   | `[1,1,1,0,1]`             | 1个0 |
| 6       | 1             | 1                    | 1                    | 否                     | -                   | -                    | 1               | `max(4, 6-1)`=5   | `[1,1,1,0,1,1]`           | 1个0 |
| 7       | 0             | 1                    | 2                    | 是                     | `nums[1]`(1)        | 2                    | 2               | `max(5, 7-2)`=5   | `[1,1,0,1,1,0]`           | 2个0，移除最左1 |
|         |               |                      |                      | 是                     | `nums[2]`(1)        | 2                    | 3               | `max(5, 7-3)`=4   | `[1,0,1,1,0]`             | 2个0，移除最左1 |
|         |               |                      |                      | 是                     | `nums[3]`(1)        | 2                    | 4               | `max(5, 7-4)`=3   | `[0,1,1,0]`               | 2个0，移除最左1 |
|         |               |                      |                      | 是                     | `nums[4]`(0)        | 1                    | 5               | `max(5, 7-5)`=2   | `[1,1,0]`                 | 1个0，移除最左0 |
| 8       | 1             | 1                    | 1                    | 否                     | -                   | -                    | 5               | `max(5, 8-5)`=5   | `[1,1,0,1]`               | 1个0 |

最终 `maxLen` 为 5。与示例输出完全一致。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入数组 `nums` 的长度。
    *   `right` 指针从头到尾遍历数组一次，总共 `N` 次迭代。
    *   `left` 指针也只会向右移动，并且在整个过程中，`left` 指针的总移动次数不会超过 `N` 次（因为 `left` 最多从 0 移动到 `N-1`）。
    *   `if` 和 `while` 循环内部的操作都是常数时间 `O(1)`。
    *   因此，总的时间复杂度是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`n`, `maxLen`, `left`, `zeroCount`, `right`)。
    *   因此，空间复杂度是常数级别的。

---

希望这个极尽详细的讲解和代码能帮助你完全理解并掌握这道算法题！











### 1208. 尽可能使字符串相等
已解答
中等
相关标签
premium lock icon
相关企业
提示
给你两个长度相同的字符串，s 和 t。

将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。

如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。

 

示例 1：

输入：s = "abcd", t = "bcdf", maxCost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。

示例 2：

输入：s = "abcd", t = "cdef", maxCost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。

示例 3：

输入：s = "abcd", t = "acde", maxCost = 0
输出：1
解释：a -> a, cost = 0，字符串未发生变化，所以最大长度为 1。
 

提示：

1 <= s.length, t.length <= 10^5
0 <= maxCost <= 10^6
s 和 t 都只含小写英文字母。




#### 不定长滑动窗口，无注释


```java
class Solution {
    public int equalSubstring(String s, String t, int maxCost) {
        

        int n = s.length();
        
        int maxLen = 0;

        int currentCost = 0;

        int left = 0;

        for( int right=0; right < n; right++ ) {

            currentCost += Math.abs( s.charAt( right ) - t.charAt(right) );

            while( currentCost > maxCost ) {


                currentCost -= Math.abs( s.charAt( left ) - t.charAt(left) );

                left++;

            }


            int currentWindowLength = right - left + 1;


            maxLen = Math.max( maxLen,currentWindowLength );


        }


        return maxLen;

    }
}
```




#### 不定长滑动窗口，注释讲解


好的，作为一名高级软件工程师，我将极尽详细地为你讲解 LeetCode 上的“尽可能使字符串相等”这道算法题，并提供详细的 Java 代码实现。

---

 1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   两个长度相同的字符串 `s` 和 `t`。
    *   一个整数 `maxCost`，表示最大预算。
*   **操作开销**: 将 `s` 中的第 `i` 个字符变到 `t` 中的第 `i` 个字符的开销是 `|s[i] - t[i]|`（两个字符 ASCII 码值的差的绝对值）。
*   **目标**: 找到 `s` 的一个**子字符串**，它可以转化为 `t` 中**对应位置**的子字符串，并且总开销**小于等于** `maxCost`。我们要求返回这样可以转化的**最大长度**。
*   **特殊情况**: 如果 `s` 中没有子字符串可以转化（即使是长度为 1 的子字符串也超出预算），则返回 `0`。

**关键点**:

*   **子字符串 (Substring)**：是原始字符串中连续的一部分。
*   **对应位置**: 如果我们选择 `s[start...end]` 这个子字符串，那么它必须转化为 `t[start...end]` 这个子字符串。
*   **总开销 <= maxCost**: 这是核心约束。
*   **最大长度**: 我们要找到所有符合条件的子字符串中，长度最大的那个。

**示例分析：**

*   `s = "abcd", t = "bcdf", maxCost = 3`

    首先，我们计算每个位置的转换开销 `cost[i] = |s[i] - t[i]|`：
    *   `i = 0`: `|'a' - 'b'| = 1`
    *   `i = 1`: `|'b' - 'c'| = 1`
    *   `i = 2`: `|'c' - 'd'| = 1`
    *   `i = 3`: `|'d' - 'f'| = 2`
    所以，开销数组可以看作 `costs = [1, 1, 1, 2]`。

    现在问题转化为：找到一个连续的子数组 `costs[left...right]`，使得其元素之和 `sum(costs[left...right]) <= maxCost`，并求出 `(right - left + 1)` 的最大值。

    *   考虑子字符串 "a" -> "b" (索引 0): 开销 1。长度 1。
    *   考虑子字符串 "ab" -> "bc" (索引 0-1): 开销 1 + 1 = 2。长度 2。
    *   考虑子字符串 "abc" -> "bcd" (索引 0-2): 开销 1 + 1 + 1 = 3。长度 3。`3 <= maxCost (3)`，符合条件。当前最大长度 3。
    *   考虑子字符串 "abcd" -> "bcdf" (索引 0-3): 开销 1 + 1 + 1 + 2 = 5。`5 > maxCost (3)`，不符合条件。
        *   这时，我们需要缩小窗口。如果从左侧移除 `s[0]` (开销 1)，窗口变为 "bcd" -> "cdf" (索引 1-3)。
        *   新窗口开销 1 + 1 + 2 = 4。`4 > maxCost (3)`，仍不符合。
        *   继续从左侧移除 `s[1]` (开销 1)，窗口变为 "cd" -> "df" (索引 2-3)。
        *   新窗口开销 1 + 2 = 3。`3 <= maxCost (3)`，符合条件。当前最大长度 `max(3, 2)` = 3。

    最终最大长度是 3。

---

 2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“在满足某个条件（总开销不超过 `maxCost`）的情况下寻找最长子字符串”问题。这种问题模式非常适合使用**滑动窗口**算法。

*   **窗口定义**: 我们使用两个指针 `left` 和 `right` 来定义当前正在考虑的子字符串，即 `s[left...right]` 及其对应的 `t[left...right]`。
*   **扩展窗口**: `right` 指针会不断向右移动，将新的字符对 `(s.charAt(right), t.charAt(right))` 加入到窗口中。
*   **维护条件**: 我们需要实时跟踪当前窗口内所有字符对的总转换开销 `currentCost`。
*   **收缩窗口**: 如果加入新字符后，`currentCost` 超过了 `maxCost`，那么当前窗口就不再合法了。此时，我们需要移动 `left` 指针向右收缩窗口，从窗口的左侧移除字符对 `(s.charAt(left), t.charAt(left))`，直到 `currentCost` 再次变得合法（即 `currentCost <= maxCost`）。
*   **更新结果**: 每当窗口合法时（即 `currentCost <= maxCost`），我们就可以计算当前子字符串的长度 (`right - left + 1`)，并用它来更新我们找到的最长长度 `maxLen`。

---

 3. 数据结构选择

*   `int currentCost`: 记录当前滑动窗口中所有字符转换开销的总和。
*   `int maxLen`: 记录到目前为止找到的满足条件的最长子字符串的长度。
*   `int left`: 滑动窗口的左边界指针。

---

 4. 算法步骤详解

1.  **初始化变量**:
    *   `n = s.length()`: 字符串的长度（`s` 和 `t` 长度相同）。
    *   `maxLen = 0`: 表示目前找到的最长合法子字符串长度为 0。
    *   `currentCost = 0`: 表示当前滑动窗口的总开销。
    *   `left = 0`: 表示滑动窗口的初始左边界在字符串的起始位置。

2.  **遍历字符串 (右指针 `right`)**:
    *   使用一个 `for` 循环，让 `right` 指针从 `0` 遍历到 `n - 1`（字符串的最后一个字符）。
    *   在每次循环迭代中，`right` 指针指向的字符对 `(s.charAt(right), t.charAt(right))` 被视为新加入窗口的元素。

3.  **将新字符对开销加入窗口并更新 `currentCost`**:
    *   计算当前位置的开销：`cost_at_right = Math.abs(s.charAt(right) - t.charAt(right))`。
    *   将 `cost_at_right` 加到 `currentCost` 中：`currentCost += cost_at_right`。

4.  **检查条件并收缩窗口**:
    *   在将 `cost_at_right` 加入窗口后，我们需要检查 `currentCost` 是否超过 `maxCost`。
    *   使用一个 `while` 循环来收缩窗口：`while (currentCost > maxCost)`。
        *   这个 `while` 循环的条件是：如果当前窗口的总开销超过了 `maxCost`，说明窗口不合法，需要收缩。
        *   在 `while` 循环内部，执行以下操作：
            *   计算左指针指向的字符对的开销：`cost_at_left = Math.abs(s.charAt(left) - t.charAt(left))`。
            *   从 `currentCost` 中减去 `cost_at_left`（因为它即将从窗口中移除）。
            *   将 `left` 指针向右移动一位：`left++`。
        *   这个 `while` 循环会一直执行，直到 `currentCost` 的值不再大于 `maxCost`。

5.  **更新最长长度**:
    *   在 `while` 循环结束后，当前滑动窗口 `s[left...right]` 已经是一个合法的子字符串（其总开销 `currentCost <= maxCost`）。
    *   计算当前合法子字符串的长度：`currentLength = right - left + 1`。
    *   更新 `maxLen`：`maxLen = Math.max(maxLen, currentLength)`。

6.  **返回结果**:
    *   当 `right` 指针遍历完整个字符串后，`maxLen` 将存储满足条件的最长子字符串的长度。返回 `maxLen`。

---

 5. 流程图


---

 6. Java 代码实现

```java
class Solution {
    /**
     * 找出 s 的最长子字符串，使其可以转化为 t 中对应的子字符串，且总开销不超过 maxCost。
     * 使用滑动窗口（Sliding Window）算法。
     *
     * @param s 第一个字符串。
     * @param t 第二个字符串。
     * @param maxCost 最大预算。
     * @return 可以转化的最大长度。
     */
    public int equalSubstring(String s, String t, int maxCost) {
        int n = s.length(); // 获取字符串的长度 (s 和 t 长度相同)

        int maxLen = 0;       // 用于存储找到的最长合法子字符串的长度
        int currentCost = 0;  // 用于存储当前滑动窗口中字符转换开销的总和
        int left = 0;         // 滑动窗口的左边界指针

        // right 是滑动窗口的右边界指针，它会从字符串的开头遍历到结尾。
        for (int right = 0; right < n; right++) {
            // 计算当前右指针指向的字符对 (s[right], t[right]) 的转换开销。
            // Math.abs() 用于取绝对值，因为开销是差的绝对值。
            currentCost += Math.abs(s.charAt(right) - t.charAt(right));

            // 检查当前窗口的总开销是否超过了 maxCost。
            // 如果 currentCost > maxCost，说明当前窗口不再合法，需要收缩窗口。
            while (currentCost > maxCost) {
                // 计算左指针指向的字符对 (s[left], t[left]) 的转换开销。
                // 这个开销即将从窗口的总开销中移除。
                currentCost -= Math.abs(s.charAt(left) - t.charAt(left));
                
                // 移动左指针，收缩窗口。
                left++;
            }

            // 此时，当前滑动窗口 [left, right] 是一个合法的子字符串，
            // 因为在 `while` 循环的作用下，currentCost 已经保证小于等于 maxCost。
            
            // 计算当前合法子字符串的长度。
            int currentWindowLength = right - left + 1;
            
            // 更新 maxLen，取当前合法子字符串的长度与历史最大长度之间的较大者。
            maxLen = Math.max(maxLen, currentWindowLength);
        }

        // 遍历结束后，maxLen 即为所求的可以转化的最大长度。
        return maxLen;
    }
}
```

---

 7. 示例演练

我们以 `s = "abcd", t = "bcdf", maxCost = 3` 为例，逐步演示代码的执行过程：

*   `n = 4`, `maxLen = 0`, `currentCost = 0`, `left = 0`

| `right` | `s[right]` | `t[right]` | `cost_at_right` | `currentCost` (加后) | `while currentCost > maxCost (3)`? | `cost_at_left` (移除) | `currentCost` (减后) | `left` (更新) | `maxLen` (更新 `right-left+1`) | 窗口 `s[left...right]` | 备注 |
| :------ | :--------- | :--------- | :-------------- | :------------------- | :--------------------------------- | :-------------------- | :------------------- | :------------ | :------------------------------- | :----------------------- | :--- |
| 0       | 'a'        | 'b'        | 1               | 1                    | 否 (1 <= 3)                        | -                     | -                    | 0             | `max(0, 0-0+1)`=1                | "a"                      | `currentCost`=1 |
| 1       | 'b'        | 'c'        | 1               | 1 + 1 = 2            | 否 (2 <= 3)                        | -                     | -                    | 0             | `max(1, 1-0+1)`=2                | "ab"                     | `currentCost`=2 |
| 2       | 'c'        | 'd'        | 1               | 2 + 1 = 3            | 否 (3 <= 3)                        | -                     | -                    | 0             | `max(2, 2-0+1)`=3                | "abc"                    | `currentCost`=3 |
| 3       | 'd'        | 'f'        | 2               | 3 + 2 = 5            | 是 (5 > 3)                         | `abs('a'-'b')`=1      | 5 - 1 = 4            | 1             | -                                | "bcd"                    | `currentCost`=4, 移除 `s[0]` |
|         |            |            |                 | 4                    | 是 (4 > 3)                         | `abs('b'-'c')`=1      | 4 - 1 = 3            | 2             | -                                | "cd"                     | `currentCost`=3, 移除 `s[1]` |
|         |            |            |                 | 3                    | 否 (3 <= 3)                        | -                     | -                    | 2             | `max(3, 3-2+1)`=2                | "cd"                     | `currentCost`=3 |

循环结束。

最终 `maxLen` 为 3。与示例输出完全一致。

---

 8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入字符串 `s` 的长度。
    *   `right` 指针从头到尾遍历字符串一次，总共 `N` 次迭代。
    *   `left` 指针也只会向右移动，并且在整个过程中，`left` 指针的总移动次数不会超过 `N` 次（因为 `left` 最多从 0 移动到 `N-1`）。
    *   `Math.abs()`、加减操作都是常数时间 `O(1)`。
    *   因此，总的时间复杂度是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`n`, `maxLen`, `currentCost`, `left`, `right`)。
    *   因此，空间复杂度是常数级别的。

---

希望这个极尽详细的讲解和代码能帮助你完全理解并掌握这道算法题！









## §2.2 求最短/最小






### [力扣209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
已解答
中等

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：

输入：target = 4, nums = [1,4,4]
输出：1

示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^4













#### 双指针法之滑动窗口-Java


```Java


class Solution {
    /**
     *  解法：双指针之滑动窗口
     *  总结滑动窗口的步骤:
        1.初始化窗口: 设置 left = 0, right = 0 (或者 right = -1，根据窗口定义调整)，初始化 sum 和 result。
        2.移动右指针 (扩展窗口): 外层循环控制 right 指针的移动，将新元素加入窗口，更新 sum。
        3.判断窗口是否满足条件: 检查当前窗口的 sum 是否满足题目条件 (例如 sum >= s)。
        4.移动左指针 (收缩窗口): 如果窗口满足条件，内层循环控制 left 指针的移动，缩小窗口，同时更新 result (如果需要求最小值)。 在移动 left 的过程中，要保证窗口仍然满足条件。
        5.重复步骤 2-4 直到右指针到达数组末尾: 继续扩展和收缩窗口，寻找所有可能的解。
        6.返回结果: 根据 result 的值判断是否有解，并返回结果。
     * @param target  目标和值
     * @param nums    正整数数组
     * @return      最小子数组的长度，如果不存在则返回 0
     */
    public int minSubArrayLen(int target, int[] nums) {

        int sum = 0;          // 用于记录滑动窗口中元素的和
        int left = 0;         // 滑动窗口的左边界
        int result = Integer.MAX_VALUE; // 存储最小子数组的长度，初始化为最大值，方便后续比较最小值

        // 使用 right 指针遍历数组，扩展滑动窗口的右边界
        for (int right = 0; right < nums.length; right++) {

            sum += nums[right]; // 将右指针当前指向的元素加入滑动窗口的和

            // 当滑动窗口的和 sum 大于等于目标值 target 时，开始收缩窗口
            while (sum >= target) {
                // 找到了一个和大于等于 target 的子数组，更新 result 为当前窗口长度和之前最小长度的较小值
                // right - left + 1 计算的是当前滑动窗口的长度
                result = Math.min(result, right - left + 1);

                // 为了找到更小的满足条件的子数组，尝试缩小滑动窗口的左边界，用于下次while循环的条件判断。
                sum -= nums[left]; // 从 sum 中减去滑动窗口左边界的元素
                left++;          // 左边界右移，缩小窗口
            }
        }

        // 循环结束后，如果 result 仍然是 Integer.MAX_VALUE，说明没有找到满足条件的子数组，返回 0
        // 否则返回找到的最小长度 result
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}


```







#### 双指针法之滑动窗口-C++





```C++



class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {


        int left= 0;

        int right=0;

        int sum = 0;

        int subLength = nums.size()+1;

        for( ; right < nums.size(); right++ ) {

            
            sum += nums[right];

            while( sum >= target ) {

                subLength = min( subLength, right - left + 1 );

                
                sum -= nums[left];

                left++;

            }


            


        }



        return subLength <= nums.size() ? subLength : 0;
        

        
    }
};



```



































### 2904. 最短且字典序最小的美丽子字符串
已解答
中等
相关标签
premium lock icon
相关企业
提示
给你一个二进制字符串 s 和一个正整数 k 。

如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。

令 len 等于 最短 美丽子字符串的长度。

返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。

对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。

例如，"abcd" 的字典序大于 "abcc" ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。
 

示例 1：

输入：s = "100011001", k = 3
输出："11001"
解释：示例中共有 7 个美丽子字符串：
1. 子字符串 "100011001" 。
2. 子字符串 "100011001" 。
3. 子字符串 "100011001" 。
4. 子字符串 "100011001" 。
5. 子字符串 "100011001" 。
6. 子字符串 "100011001" 。
7. 子字符串 "100011001" 。
最短美丽子字符串的长度是 5 。
长度为 5 且字典序最小的美丽子字符串是子字符串 "11001" 。

示例 2：

输入：s = "1011", k = 2
输出："11"
解释：示例中共有 3 个美丽子字符串：
1. 子字符串 "1011" 。
2. 子字符串 "1011" 。
3. 子字符串 "1011" 。
最短美丽子字符串的长度是 2 。
长度为 2 且字典序最小的美丽子字符串是子字符串 "11" 。 

示例 3：

输入：s = "000", k = 1
输出：""
解释：示例中不存在美丽子字符串。
 

提示：

1 <= s.length <= 100
1 <= k <= s.length





#### 不定长滑动窗口，无注释


```java
class Solution {
    public String shortestBeautifulSubstring(String s, int k) {
        
        
        int n = s.length();

        int left = 0;

        int onesCount = 0;

        int minLength = Integer.MAX_VALUE;

        String result = "";

        for( int right = 0; right < n; right++ ) {

            if( s.charAt( right ) == '1' ) {

                onesCount++;

            }


            while( onesCount >= k ) {

                if( onesCount == k ) {


                    int currentLen = right - left + 1;

                    if( currentLen < minLength ) {

                        minLength = currentLen;

                        result = s.substring( left, right+1 );

                    } else if( currentLen == minLength ) {

                        String currentSubstring = s.substring( left, right+1 );

                        if( Objects.equals( result, "" ) || currentSubstring.compareTo( result ) < 0 ) {

                            result = currentSubstring;

                        }


                    }


                }



                if( s.charAt( left ) == '1' ) {

                    onesCount--;

                }


                left++;



            }

        }


        return result;


    }
}
```






#### 不定长滑动窗口，注释讲解






好的，作为一名高级软件工程师，我将极尽详细地为你讲解 LeetCode 上的“最短且字典序最小的美丽子字符串”这道算法题，并提供详细的 Java 代码实现。

---

 1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个二进制字符串 `s`，只包含 '0' 和 '1'。
    *   一个正整数 `k`。
*   **定义“美丽子字符串”**: `s` 的某个子字符串中 '1' 的个数**恰好等于 `k`**。
*   **目标**:
    *   首先，找到所有美丽子字符串中**最短**的那个长度，记为 `len`。
    *   然后，在所有长度等于 `len` 的美丽子字符串中，找到**字典序最小**的那个。
    *   返回这个子字符串。
*   **特殊情况**: 如果 `s` 中不包含任何美丽子字符串（即没有子字符串恰好有 `k` 个 '1'），则返回一个空字符串 `""`。
*   **字典序比较**: 标准的字符串比较规则。例如 "abcd" > "abcc" 因为 'd' > 'c'。

**关键点**:

*   **子字符串 (Substring)**：是原始字符串中连续的一部分。
*   **'1' 的个数恰好等于 `k`**: 这是核心条件。
*   **优先最短长度**: 长度是第一优先级，越短越好。
*   **次之字典序最小**: 在长度相同的情况下，字典序越小越好。对于二进制字符串，这意味着越多的 '0' 靠前越好，或者说第一个不同字符是 '0' (而不是 '1') 的字符串更小。

**示例分析：**

*   `s = "100011001", k = 3`
    *   我们需要找到所有包含 3 个 '1' 的子字符串。

    让我们手动找几个：
    *   `"100011"` (长度 6, 3个'1')
    *   `"00011001"` (长度 8, 3个'1')
    *   `"0011001"` (长度 7, 3个'1')
    *   `"11001"` (长度 5, 3个'1') <-- 这是一个候选的最短美丽子字符串。

    假设我们找到了几个长度为 5 的美丽子字符串：
    *   "11001"
    *   "10101"
    *   "01101"
    *   ...

    在这些长度为 5 的子字符串中，我们需要找到字典序最小的。
    "11001" 是一个长度为 5 的美丽子字符串。
    如果还有其他长度为 5 的美丽子字符串，比如 "10101"，那么 "10001" < "10101"。
    最终，示例输出 "11001"。这说明它是最短且字典序最小的。

*   `s = "000", k = 1`
    *   字符串中没有 '1'。所以不存在 '1' 的个数恰好等于 1 的子字符串。
    *   返回 `""`。

---

 2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“在满足某个条件（'1' 的数量恰好为 `k`）的情况下寻找最长/最短子字符串”问题，并且带有额外的字典序比较要求。这种问题模式非常适合使用**滑动窗口**算法。

*   **窗口定义**: 我们使用两个指针 `left` 和 `right` 来定义当前正在考虑的子字符串，即 `s[left...right]`。
*   **扩展窗口**: `right` 指针会不断向右移动，将新的字符 `s.charAt(right)` 加入到窗口中。
*   **维护条件**: 我们需要实时跟踪当前窗口内 '1' 的数量 (`onesCount`)。
*   **收缩窗口**:
    *   当 `onesCount` **大于 `k`** 时：窗口不合法，需要收缩。移动 `left` 指针向右，从窗口的左侧移除 `s.charAt(left)`，直到 `onesCount` 再次变得合法（即 `onesCount <= k`）。
    *   当 `onesCount` **恰好等于 `k`** 时：我们找到了一个美丽子字符串。此时，我们尝试进一步收缩窗口，但要确保 `onesCount` 仍然保持为 `k`。这通常意味着从左侧移除的字符必须是 '0'，这样才能在不改变 `onesCount` 的情况下缩短子字符串，从而找到更短的符合条件的子字符串。如果移除的是 '1'，`onesCount` 就会变成 `k-1`，窗口就不再美丽了。

**优化收缩逻辑以找到最短和字典序最小的：**

1.  **扩展阶段**: `right` 指针向右移动，`onesCount` 增加（如果 `s.charAt(right)` 是 '1'）。
2.  **处理 `onesCount == k` 的情况**:
    *   一旦 `onesCount` 达到 `k`，我们就找到了一个美丽子字符串 `s[left...right]`。
    *   此时，我们尝试从左侧收缩窗口，以找到**最短**的、包含 `k` 个 '1' 的子字符串。
    *   我们使用一个 `while` 循环：`while (onesCount == k)`。
        *   在这个 `while` 循环内部，我们有两个目的：
            1.  **找到最短的**: 如果 `s.charAt(left)` 是 '0'，我们可以安全地将它从窗口移除 (`left++`) 而不改变 `onesCount`。这会缩短当前子字符串的长度，可能使其成为更短的美丽子字符串。
            2.  **记录并比较候选**: 在每次 `left` 移动后（或者在 `while` 循环开始时），当前窗口 `s[left...right]` 都是一个包含 `k` 个 '1' 的美丽子字符串。我们计算其长度 `currentLen = right - left + 1`。
                *   如果 `currentLen < minLength`：这是一个更短的美丽子字符串，更新 `minLength` 和 `result`。
                *   如果 `currentLen == minLength`：这是一个与当前最短长度相同的美丽子字符串，需要进行字典序比较。如果它比当前 `result` 字典序更小，更新 `result`。
        *   当 `s.charAt(left)` 是 '1' 时，如果我们将它移出，`onesCount` 就会变成 `k-1`，窗口就不再是美丽子字符串了。所以，当遇到 '1' 时，我们记录下当前的合法窗口，然后将这个 '1' 移出，`onesCount` 变为 `k-1`，`left` 增加，`while` 循环条件 `onesCount == k` 就不满足了，循环结束，`right` 继续向右扩展。

---

 3. 数据结构选择

*   `int onesCount`: 记录当前滑动窗口中 '1' 的数量。
*   `int minLength`: 记录到目前为止找到的最短美丽子字符串的长度。初始化为 `Integer.MAX_VALUE`。
*   `String result`: 存储当前找到的最短且字典序最小的美丽子字符串。初始化为 `""`。
*   `int left`: 滑动窗口的左边界指针。

---

 4. 算法步骤详解

1.  **初始化变量**:
    *   `n = s.length()`: 字符串的长度。
    *   `left = 0`: 滑动窗口的左边界指针。
    *   `onesCount = 0`: 记录当前窗口中 '1' 的数量。
    *   `minLength = Integer.MAX_VALUE`: 存储最短美丽子字符串的长度。
    *   `result = ""`: 存储最短且字典序最小的美丽子字符串。

2.  **遍历字符串 (右指针 `right`)**:
    *   使用一个 `for` 循环，让 `right` 指针从 `0` 遍历到 `n - 1`。
    *   在每次循环迭代中，`right` 指针指向的字符 `s.charAt(right)` 被视为新加入窗口的元素。

3.  **将新字符加入窗口并更新 `onesCount`**:
    *   如果 `s.charAt(right)` 是 '1'，则 `onesCount` 加 1。

4.  **处理窗口（收缩并评估）**:
    *   使用一个 `while` 循环：`while (onesCount >= k)`。
        *   这个 `while` 循环的条件是：如果当前窗口中 `1` 的数量大于等于 `k`，说明我们可能找到了一个美丽子字符串，或者需要继续收缩。

        *   **内部检查 `onesCount == k`**:
            *   如果 `onesCount == k`，那么当前窗口 `s[left...right]` 是一个美丽子字符串。
            *   计算其长度 `currentLen = right - left + 1`。
            *   **比较并更新 `result`**:
                *   如果 `currentLen < minLength`:
                    *   `minLength = currentLen`。
                    *   `result = s.substring(left, right + 1)`。
                *   如果 `currentLen == minLength`:
                    *   获取当前子字符串 `currentSubstring = s.substring(left, right + 1)`。
                    *   如果 `result` 是空字符串（表示这是第一个最短的）或者 `currentSubstring` 在字典序上小于 `result`：
                        *   `result = currentSubstring`。

        *   **收缩窗口 (移动 `left`)**:
            *   如果 `s.charAt(left)` 是 '1'：
                *   我们必须将这个 '1' 移除，`onesCount` 会减少。
                *   `onesCount--`。
                *   `left++`。
                *   此时 `onesCount` 变为 `k-1`，`while (onesCount >= k)` 条件不满足，循环会跳出，`right` 将继续前进。
            *   如果 `s.charAt(left)` 是 '0'：
                *   我们可以安全地将这个 '0' 移除，`onesCount` 不变。
                *   `left++`。
                *   此时 `onesCount` 仍然是 `k`。`while` 循环会继续，我们可以尝试找到更短的、以当前 `right` 结尾的美丽子字符串。

5.  **返回结果**:
    *   当 `right` 指针遍历完整个字符串后，`result` 将存储最短且字典序最小的美丽子字符串。如果从未找到美丽子字符串，`result` 将保持 `""`。返回 `result`。

---

 5. 流程图


---

 6. Java 代码实现

```java
import java.util.Objects; // 导入 Objects 类，用于 Objects.equals() 比较字符串或处理 null

class Solution {
    /**
     * 找出最短且字典序最小的美丽子字符串。
     * 美丽子字符串定义为 '1' 的个数恰好等于 k 的子字符串。
     * 使用滑动窗口（Sliding Window）算法。
     *
     * @param s 输入的二进制字符串。
     * @param k 目标 '1' 的数量。
     * @return 最短且字典序最小的美丽子字符串，如果不存在则返回空字符串。
     */
    public String shortestBeautifulSubstring(String s, int k) {
        int n = s.length(); // 获取字符串的长度

        int left = 0;        // 滑动窗口的左边界指针
        int onesCount = 0;   // 记录当前滑动窗口中 '1' 的数量

        int minLength = Integer.MAX_VALUE; // 存储找到的最短美丽子字符串的长度
        String result = "";                // 存储最短且字典序最小的美丽子字符串

        // right 是滑动窗口的右边界指针，它会从字符串的开头遍历到结尾。
        for (int right = 0; right < n; right++) {
            // 如果当前右指针指向的字符是 '1'，则增加 onesCount。
            if (s.charAt(right) == '1') {
                onesCount++;
            }

            // 当窗口中 '1' 的数量大于等于 k 时，我们进入收缩阶段。
            // 目标是找到以当前 right 结尾的最短美丽子字符串。
            while (onesCount >= k) {
                // 只有当 '1' 的数量恰好等于 k 时，当前窗口才是一个美丽子字符串。
                // 此时，我们评估这个子字符串是否是满足条件的最优解。
                if (onesCount == k) {
                    int currentLen = right - left + 1; // 计算当前美丽子字符串的长度

                    // 比较当前美丽子字符串与已找到的最优解。
                    if (currentLen < minLength) {
                        // 如果当前子字符串更短，则直接更新最优解。
                        minLength = currentLen;
                        result = s.substring(left, right + 1);
                    } else if (currentLen == minLength) {
                        // 如果长度相同，则进行字典序比较。
                        String currentSubstring = s.substring(left, right + 1);
                        // 如果 result 为空（表示这是第一个最短的候选），或者当前子字符串字典序更小。
                        // Objects.equals(result, "") 用于判断 result 是否为空字符串，
                        // 避免在 result 尚未被赋值时调用 compareTo 导致 NullPointerException 或不正确的行为。
                        if (Objects.equals(result, "") || currentSubstring.compareTo(result) < 0) {
                            result = currentSubstring;
                        }
                    }
                }

                // 尝试从左侧收缩窗口。
                // 如果左指针指向的字符是 '1'，则在将其移出窗口时，减少 onesCount。
                // 如果是 '0'，onesCount 不变。
                if (s.charAt(left) == '1') {
                    onesCount--;
                }
                // 移动左指针，收缩窗口。
                left++;
                
                // 循环会继续，直到 onesCount < k (即不再是美丽子字符串)
                // 或者 left 越过 right (窗口为空或无效)
            }
        }

        // 遍历结束后，result 中存储的就是最短且字典序最小的美丽子字符串。
        // 如果从未找到，它将保持空字符串。
        return result;
    }
}
```

---

 7. 示例演练

我们以 `s = "100011001", k = 3` 为例，逐步演示代码的执行过程：

*   `n = 9`, `left = 0`, `onesCount = 0`, `minLength = MAX_INT`, `result = ""`

| `right` | `s[right]` | `onesCount` (加后) | `while onesCount >= k(3)`? | `currentLen` | `minLength` | `result` | `s[left]` (移除) | `onesCount` (减后) | `left` (更新) | 备注 |
| :------ | :--------- | :----------------- | :------------------------- | :----------- | :---------- | :------- | :--------------- | :----------------- | :------------ | :--- |
| 0       | '1'        | 1                  | 否                         | -            | MAX_INT     | ""       | -                | -                  | 0             | `ones=1` |
| 1       | '0'        | 1                  | 否                         | -            | MAX_INT     | ""       | -                | -                  | 0             | `ones=1` |
| 2       | '0'        | 1                  | 否                         | -            | MAX_INT     | ""       | -                | -                  | 0             | `ones=1` |
| 3       | '0'        | 1                  | 否                         | -            | MAX_INT     | ""       | -                | -                  | 0             | `ones=1` |
| 4       | '1'        | 2                  | 否                         | -            | MAX_INT     | ""       | -                | -                  | 0             | `ones=2` |
| 5       | '1'        | 3                  | 是 (3 >= 3)                |              |             |          |                  |                    |               | `ones=3` |
|         |            |                    | `if (onesCount == 3)` 是   | `5-0+1`=6    | MAX_INT     | ""       | -                | -                  | -             | 窗口 "100011" |
|         |            |                    | `6 < MAX_INT` 是           |              | 6           | "100011" |                  |                    |               | 更新最短 |
|         |            |                    | `s[0]`='1'                 |              |             |          | '1'              | 2                  | 1             | 移除 '1'，`ones`变2，跳出while |
| 6       | '0'        | 2                  | 否                         | -            | 6           | "100011" | -                | -                  | 1             | `ones=2` |
| 7       | '0'        | 2                  | 否                         | -            | 6           | "100011" | -                | -                  | 1             | `ones=2` |
| 8       | '1'        | 3                  | 是 (3 >= 3)                |              |             |          |                  |                    |               | `ones=3` |
|         |            |                    | `if (onesCount == 3)` 是   | `8-1+1`=8    | 6           | "100011" |                  |                    |               | 窗口 `s[1...8]` "00011001" |
|         |            |                    | `8 < 6` 否                 |              |             |          |                  |                    |               | `8 == 6` 否 |
|         |            |                    | `s[1]`='0'                 |              |             |          | '0'              | 3                  | 2             | 移除 '0'，`ones`不变 |
|         |            |                    | `if (onesCount == 3)` 是   | `8-2+1`=7    | 6           | "100011" |                  |                    |               | 窗口 `s[2...8]` "0011001" |
|         |            |                    | `7 < 6` 否                 |              |             |          |                  |                    |               | `7 == 6` 否 |
|         |            |                    | `s[2]`='0'                 |              |             |          | '0'              | 3                  | 3             | 移除 '0'，`ones`不变 |
|         |            |                    | `if (onesCount == 3)` 是   | `8-3+1`=6    | 6           | "100011" |                  |                    |               | 窗口 `s[3...8]` "011001" |
|         |            |                    | `6 < 6` 否                 |              |             |          |                  |                    |               | `6 == 6` 是 |
|         |            |                    | `currentSubstring`="011001" |              |             |          |                  |                    |               | `result`="100011" |
|         |            |                    | `"011001".compareTo("100011") < 0` 是 |              |             | "011001" |                  |                    |               | 更新为字典序更小 |
|         |            |                    | `s[3]`='0'                 |              |             |          | '0'              | 3                  | 4             | 移除 '0'，`ones`不变 |
|         |            |                    | `if (onesCount == 3)` 是   | `8-4+1`=5    | 6           | "011001" |                  |                    |               | 窗口 `s[4...8]` "11001" |
|         |            |                    | `5 < 6` 是                 |              | 5           | "11001"  |                  |                    |               | 更新为更短 |
|         |            |                    | `s[4]`='1'                 |              |             |          | '1'              | 2                  | 5             | 移除 '1'，`ones`变2，跳出while |

循环结束。

最终 `result` 为 "11001"。与示例输出完全一致。

---

 8. 复杂度分析

*   **时间复杂度**: `O(N^2)`。
    *   `N` 是输入字符串 `s` 的长度。
    *   `right` 指针从头到尾遍历字符串一次，总共 `N` 次迭代。
    *   `left` 指针也只会向右移动，并且在整个过程中，`left` 指针的总移动次数不会超过 `N` 次。
    *   `substring()` 方法在 Java 中会创建一个新的字符串对象，其时间复杂度取决于子字符串的长度，最坏情况下是 `O(N)`。
    *   `compareTo()` 方法也会遍历字符串，最坏情况下是 `O(N)`。
    *   在 `while` 循环内部，`substring` 和 `compareTo` 操作可能会被执行多次。最坏情况下，每次 `left` 移动都可能触发这些操作。因此，总的时间复杂度可能达到 `O(N^2)`。
    *   鉴于题目提示 `n <= 100`，`N^2` (100 * 100 = 10000) 的复杂度是完全可以接受的。

*   **空间复杂度**: `O(N)`。
    *   我们使用了 `result` 字符串来存储结果，在最坏情况下，它可能存储整个字符串 `s` 的一个子字符串，其长度为 `N`。
    *   其他变量 (`n`, `left`, `onesCount`, `minLength`, `right`) 都只占用常数空间。
    *   因此，空间复杂度是 `O(N)`。

---

希望这个极尽详细的讲解和代码能帮助你完全理解并掌握这道算法题！




