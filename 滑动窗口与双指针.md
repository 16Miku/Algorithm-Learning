

# 说明

本文档记录了按照灵神题单刷题的学习记录。灵神题单链接：<https://leetcode.cn/discuss/post/3578981/ti-dan-hua-dong-chuang-kou-ding-chang-bu-rzz7/>




# 一、定长滑动窗口


## §1.1 基础


### 1456. 定长子串中元音的最大数目

已解答
中等
相关标签
premium lock icon
相关企业
提示
给你字符串 s 和整数 k 。

请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。

英文中的 元音字母 为（a, e, i, o, u）。

 

示例 1：

输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。

示例 2：

输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。

示例 3：

输入：s = "leetcode", k = 3
输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。

示例 4：

输入：s = "rhythms", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。

示例 5：

输入：s = "tryhard", k = 4
输出：1
 

提示：

1 <= s.length <= 10^5
s 由小写英文字母组成
1 <= k <= s.length



#### 定长滑动窗口，无注释



```java

class Solution {


    public int maxVowels(String s, int k) {

        
        if( s == null || s.length() == 0 || k == 0 || k > s.length() ) {

            return 0;

        }


        int currentVowels = 0;

        int maxVowels = 0;

        for( int i=0; i < k; i++ ) {

            if( isVowel( s.charAt(i) ) ) {

                currentVowels++;

            }
        }


        maxVowels = currentVowels;


        for( int right = k; right < s.length(); right++ ) {


            char leftChar = s.charAt( right-k );

            char rightChar = s.charAt( right );


            if( isVowel( leftChar ) ) {

                currentVowels--;
            }


            if( isVowel( rightChar ) ) {


                currentVowels++;
            }


            maxVowels = Math.max( maxVowels, currentVowels );





        }



        return maxVowels;



    }


    public boolean isVowel( char c ) {

        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
        
    }



}

```





#### 定长滑动窗口，注释版




好的，作为一名高级软件工程师，我来一步步教你如何解决 LeetCode 上的“定长子串中元音的最大数目”这道算法题。我们将继续使用 Java 语言来实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个字符串 `s`。
    *   一个整数 `k`，表示子串的长度。
*   **目标**: 找出所有长度为 `k` 的子串中，包含元音字母（'a', 'e', 'i', 'o', 'u'）数目最多的那个子串，并返回它包含的元音字母的最大数目。
*   **关键点**:
    *   **定长子串**: 题目明确要求子串的长度必须是 `k`。
    *   **元音字母**: 明确指定为 'a', 'e', 'i', 'o', 'u' (不区分大小写，但题目通常默认小写)。
    *   **最大数目**: 我们只需要返回元音字母的最大数量，而不是子串本身。

**示例分析：**

假设 `s = "abciiidef"`, `k = 3`

*   第一个长度为 3 的子串是 "abc"：包含 'a', 'i' (2个元音)
*   第二个长度为 3 的子串是 "bci"：包含 'i' (1个元音)
*   第三个长度为 3 的子串是 "cii"：包含 'i', 'i' (2个元音)
*   第四个长度为 3 的子串是 "iii"：包含 'i', 'i', 'i' (3个元音)
*   第五个长度为 3 的子串是 "iid"：包含 'i', 'i' (2个元音)
*   第六个长度为 3 的子串是 "ide"：包含 'i', 'e' (2个元音)
*   第七个长度为 3 的子串是 "def"：包含 'e' (1个元音)

所有长度为 `k` 的子串中，元音字母最多的子串是 "iii"，包含 3 个元音。所以输出 3。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“固定大小滑动窗口”问题。由于我们需要在所有长度为 `k` 的子串中找到元音数量最多的，暴力解法是枚举所有长度为 `k` 的子串，然后对每个子串计数元音，但这会导致重复计算，效率低下。

滑动窗口在这里的优势在于：

*   **避免重复计算**: 当窗口从一个位置滑动到下一个位置时，我们不需要重新计算整个新窗口的元音数量。
*   **增量更新**: 我们只需要关注窗口最左边移出的字符和最右边移入的字符，对元音计数进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **初始化窗口**: 首先计算第一个长度为 `k` 的子串（即 `s[0...k-1]`）中的元音数量。
2.  **滑动窗口**: 然后，窗口向右滑动。
    *   当窗口从 `s[i...i+k-1]` 滑动到 `s[i+1...i+k]` 时：
        *   最左边的字符 `s[i]` 被移出窗口。
        *   最右边的字符 `s[i+k]` 被移入窗口。
    *   我们只需要根据 `s[i]` 是否是元音来减少计数，并根据 `s[i+k]` 是否是元音来增加计数。
3.  **更新最大值**: 在每次滑动后，更新当前窗口的元音数量，并与记录的最大元音数量进行比较，取较大值。

---

3. 数据结构选择

*   **`Set<Character>` 或 `boolean[]`**: 为了高效地判断一个字符是否为元音，我们可以使用 `HashSet` 存储元音字母，或者更高效地，使用一个布尔数组来标记每个字符是否为元音（如果字符集大小固定且较小，例如 ASCII 字符）。由于元音字母只有固定的几个小写字母，使用布尔数组 `boolean[26]` (对应 'a' 到 'z') 或者 `boolean[128]` (对应 ASCII 字符) 会非常高效。

我们将使用一个辅助方法 `isVowel(char c)` 来判断字符是否是元音，它内部可以通过硬编码或一个 `Set` 来实现。为了简洁和效率，直接硬编码判断会更好。

---

4. 算法步骤详解

1.  **定义辅助函数 `isVowel(char c)`**:
    *   判断传入的字符 `c` 是否是 'a', 'e', 'i', 'o', 'u' 中的一个。

2.  **初始化变量**:
    *   `currentVowels = 0`: 记录当前滑动窗口中元音的数量。
    *   `maxVowels = 0`: 记录所有长度为 `k` 的子串中元音的最大数量。

3.  **计算第一个窗口的元音数量**:
    *   遍历字符串 `s` 的前 `k` 个字符 (从索引 0 到 `k-1`)。
    *   对于每个字符，如果它是元音，则 `currentVowels` 加 1。
    *   将 `maxVowels` 初始化为 `currentVowels`。

4.  **滑动窗口**:
    *   从索引 `k` 开始，遍历字符串直到末尾 (`s.length() - 1`)。这个索引 `i` 代表当前窗口的右边界。
    *   在每次迭代中：
        *   **移出旧字符**: 检查 `s.charAt(i - k)` (即窗口最左边即将移出的字符) 是否是元音。如果是，`currentVowels` 减 1。
        *   **移入新字符**: 检查 `s.charAt(i)` (即窗口最右边新移入的字符) 是否是元音。如果是，`currentVowels` 加 1。
        *   **更新最大值**: 将 `maxVowels` 更新为 `Math.max(maxVowels, currentVowels)`。

5.  **返回结果**: 遍历结束后，`maxVowels` 就是最终答案。

---

5. 流程图
略

---

6. Java 代码实现

```java
class Solution {
    /**
     * 判断一个字符是否是元音字母。
     * 元音字母包括 'a', 'e', 'i', 'o', 'u'。
     *
     * @param c 待判断的字符
     * @return 如果是元音字母则返回 true，否则返回 false
     */
    private boolean isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }

    /**
     * 找出字符串 s 中所有长度为 k 的子串中，包含元音字母的最大数目。
     * 使用固定大小的滑动窗口算法。
     *
     * @param s 输入字符串
     * @param k 子串的固定长度
     * @return 长度为 k 的子串中元音字母的最大数目
     */
    public int maxVowels(String s, int k) {
        // 如果输入字符串为空、k为0，或者k大于字符串长度，则直接返回0
        if (s == null || s.length() == 0 || k == 0 || k > s.length()) {
            return 0;
        }

        // currentVowels 记录当前滑动窗口中元音的数量
        int currentVowels = 0;
        // maxVowels 记录到目前为止找到的，所有长度为 k 的子串中元音的最大数量
        int maxVowels = 0;

        // 1. 计算第一个长度为 k 的窗口的元音数量
        // 窗口范围：s[0] 到 s[k-1]
        for (int i = 0; i < k; i++) {
            if (isVowel(s.charAt(i))) {
                currentVowels++;
            }
        }
        // 将第一个窗口的元音数量作为初始的最大值
        maxVowels = currentVowels;

        // 2. 滑动窗口
        // right 指针从 k 开始，遍历到字符串末尾
        // 每次循环，right 指针代表当前窗口的右边界
        // 当前窗口的范围是 s[right - k + 1] 到 s[right]
        for (int right = k; right < s.length(); right++) {
            // leftChar 是当前窗口最左边即将移出的字符
            char leftChar = s.charAt(right - k);
            // rightChar 是当前窗口最右边新移入的字符
            char rightChar = s.charAt(right);

            // 检查移出的字符是否是元音，如果是，则 currentVowels 减 1
            if (isVowel(leftChar)) {
                currentVowels--;
            }

            // 检查移入的字符是否是元音，如果是，则 currentVowels 加 1
            if (isVowel(rightChar)) {
                currentVowels++;
            }

            // 更新 maxVowels，取当前窗口元音数量和历史最大值之间的较大者
            maxVowels = Math.max(maxVowels, currentVowels);
        }

        // 遍历结束后，maxVowels 即为所求的长度为 k 的子串中元音的最大数目
        return maxVowels;
    }
}
```

---

7. 示例演练

我们以 `s = "abciiidef"`, `k = 3` 为例，逐步演示代码的执行过程：

| `right` | `s.charAt(right)` | `leftChar` (`s.charAt(right - k)`) | `currentVowels` (更新前) | `isVowel(leftChar)` | `currentVowels` (移出后) | `isVowel(rightChar)` | `currentVowels` (移入后) | `maxVowels` | 备注 |
| :------ | :---------------- | :--------------------------------- | :----------------------- | :------------------ | :----------------------- | :------------------- | :----------------------- | :---------- | :--- |
| **初始化阶段 (i = 0 to k-1)** | | | | | | | | | |
| i=0     | 'a'               | -                                  | 0                        | -                   | -                        | 是                   | 1                        | -           | 窗口 "a" |
| i=1     | 'b'               | -                                  | 1                        | -                   | -                        | 否                   | 1                        | -           | 窗口 "ab" |
| i=2     | 'c'               | -                                  | 1                        | -                   | -                        | 否                   | 1                        | -           | 窗口 "abc" |
| **初始化结果** | | | | | | | **1** | **1** | 第一个窗口 "abc" 有 1 个元音 ('a') |
| **滑动阶段 (right = k to s.length() - 1)** | | | | | | | | | |
| 3       | 'i'               | 'a' (`s.charAt(0)`)                | 1                        | 是                  | 0                        | 是                   | 1                        | `max(1,1)`=1| 窗口 "bci" ('a'移出,'i'移入) |
| 4       | 'i'               | 'b' (`s.charAt(1)`)                | 1                        | 否                  | 1                        | 是                   | 2                        | `max(1,2)`=2| 窗口 "cii" ('b'移出,'i'移入) |
| 5       | 'i'               | 'c' (`s.charAt(2)`)                | 2                        | 否                  | 2                        | 是                   | 3                        | `max(2,3)`=3| 窗口 "iii" ('c'移出,'i'移入) |
| 6       | 'd'               | 'i' (`s.charAt(3)`)                | 3                        | 是                  | 2                        | 否                   | 2                        | `max(3,2)`=3| 窗口 "iid" ('i'移出,'d'移入) |
| 7       | 'e'               | 'i' (`s.charAt(4)`)                | 2                        | 是                  | 1                        | 是                   | 2                        | `max(3,2)`=3| 窗口 "ide" ('i'移出,'e'移入) |
| 8       | 'f'               | 'i' (`s.charAt(5)`)                | 2                        | 是                  | 1                        | 否                   | 1                        | `max(3,1)`=3| 窗口 "def" ('i'移出,'f'移入) |

最终 `maxVowels` 为 3。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入字符串 `s` 的长度。
    *   我们首先遍历前 `k` 个字符来初始化第一个窗口，这需要 `O(k)` 时间。
    *   然后，`right` 指针从 `k` 遍历到 `N-1`，总共 `N-k` 次迭代。每次迭代中，我们进行常数次操作（字符判断、加减、比较）。
    *   因此，总的时间复杂度是 `O(k + (N-k)) = O(N)`，是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`currentVowels`, `maxVowels`, `leftChar`, `rightChar`)。
    *   `isVowel` 方法也没有使用额外的存储空间。
    *   因此，空间复杂度是常数级别的。

---

希望这个详细的解释和代码能帮助你完全理解并掌握这道算法题！







### 643. 子数组最大平均数 I
已解答
简单
相关标签
premium lock icon
相关企业
给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。

请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。

任何误差小于 10-5 的答案都将被视为正确答案。

 

示例 1：

输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75

示例 2：

输入：nums = [5], k = 1
输出：5.00000
 

提示：

n == nums.length
1 <= k <= n <= 10^5
-10^4 <= nums[i] <= 10^4





#### 定长滑动窗口，无注释


```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        

        if( nums == null || nums.length == 0 || k == 0 ) {

            return 0.0;
        }

        long currentSum = 0;

        for( int i=0; i < k; i++ ) {

            currentSum += nums[i];
        }


        long maxSum = currentSum;


        for( int right = k; right < nums.length; right++ ) {


            int leftChar = nums[right-k];

            int rightChar = nums[right];

            currentSum += rightChar-leftChar;

            maxSum = Math.max( currentSum,maxSum );


        }


        return (double) maxSum/k;



    }
}
```









#### 定长滑动窗口，注释版




好的，作为一名高级软件工程师，我来一步步教你如何解决 LeetCode 上的“子数组最大平均数 I”这道算法题。我们将继续使用 Java 语言来实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个整数数组 `nums`。
    *   一个整数 `k`，表示子数组的长度。
*   **目标**: 找到一个长度为 `k` 的连续子数组，使得其平均值最大，并返回这个最大平均值。
*   **关键点**:
    *   **连续子数组**: 必须是数组中连续的一部分。
    *   **定长 `k`**: 子数组的长度是固定的 `k`。
    *   **最大平均值**: 我们需要返回的是平均值的最大值。

**示例分析：**

假设 `nums = [1,12,-5,-6,50,3]`, `k = 4`

*   第一个长度为 4 的子数组是 `[1, 12, -5, -6]`，和为 `1 + 12 - 5 - 6 = 2`，平均值为 `2 / 4 = 0.5`。
*   第二个长度为 4 的子数组是 `[12, -5, -6, 50]`，和为 `12 - 5 - 6 + 50 = 51`，平均值为 `51 / 4 = 12.75`。
*   第三个长度为 4 的子数组是 `[-5, -6, 50, 3]`，和为 `-5 - 6 + 50 + 3 = 42`，平均值为 `42 / 4 = 10.5`。

所有长度为 `k` 的子数组中，最大平均值是 12.75。所以输出 12.75。

**重要观察**: 因为子数组的长度 `k` 是固定的，所以要使平均值最大化 (`Sum / k`)，就等价于使子数组的**和 (Sum)** 最大化。因此，问题可以转化为：找到一个长度为 `k` 的连续子数组，使其和最大。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是“固定大小滑动窗口”问题的又一个经典应用。与上一题“定长子串中元音的最大数目”非常相似。

*   **避免重复计算**: 我们不需要每次都重新计算整个子数组的和。
*   **增量更新**: 当窗口从一个位置滑动到下一个位置时，我们只需要对和进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **初始化窗口**: 首先计算第一个长度为 `k` 的子数组（即 `nums[0...k-1]`）的元素之和。
2.  **滑动窗口**: 然后，窗口向右滑动。
    *   当窗口从 `nums[i...i+k-1]` 滑动到 `nums[i+1...i+k]` 时：
        *   最左边的元素 `nums[i]` 被移出窗口。
        *   最右边的元素 `nums[i+k]` 被移入窗口。
    *   我们只需要从当前和中减去 `nums[i]`，并加上 `nums[i+k]`，即可得到新窗口的和。
3.  **更新最大值**: 在每次滑动后，更新当前窗口的和，并与记录的最大和进行比较，取较大值。
4.  **计算平均值**: 遍历结束后，用找到的最大和除以 `k`，即为最大平均值。

---

3. 数据结构选择

对于这道题，我们只需要几个简单的变量来存储当前的和以及最大和即可，不需要复杂的数据结构。

*   `currentSum`: 记录当前滑动窗口中元素的和。
*   `maxSum`: 记录到目前为止找到的所有长度为 `k` 的子数组中的最大和。

---

4. 算法步骤详解

1.  **初始化变量**:
    *   `currentSum = 0`: 用于存储当前滑动窗口中元素的和。
    *   `maxSum = 0`: 用于存储找到的最大子数组和。需要注意的是，由于数组元素可能为负数，`maxSum` 的初始值不能简单设为 0。一种方法是先计算第一个窗口的和，然后将其作为 `maxSum` 的初始值。

2.  **计算第一个窗口的和**:
    *   遍历数组 `nums` 的前 `k` 个元素 (从索引 0 到 `k-1`)。
    *   将这些元素累加到 `currentSum` 中。
    *   将 `maxSum` 初始化为 `currentSum`。

3.  **滑动窗口**:
    *   从索引 `k` 开始，遍历数组直到末尾 (`nums.length - 1`)。这个索引 `i` 代表当前窗口的右边界。
    *   在每次迭代中：
        *   **移出旧元素**: `currentSum` 减去 `nums[i - k]` (即窗口最左边即将移出的元素)。
        *   **移入新元素**: `currentSum` 加上 `nums[i]` (即窗口最右边新移入的元素)。
        *   **更新最大和**: 将 `maxSum` 更新为 `Math.max(maxSum, currentSum)`。

4.  **返回结果**: 遍历结束后，最终结果是 `(double) maxSum / k`。注意需要强制类型转换为 `double` 以确保得到浮点数结果。

---

5. 流程图
略
---

6. Java 代码实现

```java
class Solution {
    /**
     * 找出数组中长度为 k 的连续子数组的最大平均值。
     * 使用固定大小的滑动窗口算法。
     *
     * @param nums 输入整数数组
     * @param k 子数组的固定长度
     * @return 长度为 k 的子数组的最大平均值
     */
    public double findMaxAverage(int[] nums, int k) {
        // 如果数组为空，或者 k 为 0，或者 k 大于数组长度，则无法形成有效子数组，返回 0.0
        // 题目约束 nums.length >= k，所以 k > nums.length 的情况理论上不会发生
        if (nums == null || nums.length == 0 || k == 0) {
            return 0.0;
        }

        // currentSum 用于存储当前滑动窗口中元素的和
        long currentSum = 0; // 使用 long 类型以防止整数溢出，因为 nums[i] 范围较大，k 也可能较大
        
        // 1. 计算第一个长度为 k 的窗口的元素之和
        // 窗口范围：nums[0] 到 nums[k-1]
        for (int i = 0; i < k; i++) {
            currentSum += nums[i];
        }

        // maxSum 用于记录到目前为止找到的所有长度为 k 的子数组中的最大和
        // 初始时，将第一个窗口的和作为最大和
        long maxSum = currentSum;

        // 2. 滑动窗口
        // right 指针从 k 开始，遍历到数组末尾
        // 每次循环，right 指针代表当前窗口的右边界新加入的元素
        // 当前窗口的范围是 nums[right - k + 1] 到 nums[right]
        for (int right = k; right < nums.length; right++) {
            // 窗口滑动：
            // 移出最左边的元素：currentSum 减去 nums[right - k]
            // 移入最右边的新元素：currentSum 加上 nums[right]
            currentSum = currentSum - nums[right - k] + nums[right];

            // 更新 maxSum，取当前窗口的和与历史最大和之间的较大者
            maxSum = Math.max(maxSum, currentSum);
        }

        // 遍历结束后，maxSum 即为所求的长度为 k 的子数组的最大和
        // 将最大和转换为 double 类型再除以 k，以确保得到浮点数结果
        return (double) maxSum / k;
    }
}
```

---

7. 示例演练

我们以 `nums = [1,12,-5,-6,50,3]`, `k = 4` 为例，逐步演示代码的执行过程：

| `right` | `nums[right]` | `nums[right - k]` (移出元素) | `currentSum` (更新前) | `currentSum` (更新后) | `maxSum` (更新后) | 备注 |
| :------ | :------------ | :--------------------------- | :-------------------- | :-------------------- | :---------------- | :--- |
| **初始化阶段 (i = 0 to k-1)** | | | | | | |
| i=0     | 1             | -                            | 0                     | 1                     | -                 | currentSum = 1 |
| i=1     | 12            | -                            | 1                     | 13                    | -                 | currentSum = 1 + 12 = 13 |
| i=2     | -5            | -                            | 13                    | 8                     | -                 | currentSum = 13 - 5 = 8 |
| i=3     | -6            | -                            | 8                     | 2                     | -                 | currentSum = 8 - 6 = 2 |
| **初始化结果** | | | | **2** | **2** | 第一个窗口 `[1, 12, -5, -6]` 的和是 2。`maxSum` 初始为 2。 |
| **滑动阶段 (right = k to nums.length - 1)** | | | | | | |
| 4       | 50            | `nums[0]` (1)                | 2                     | `2 - 1 + 50 = 51`     | `max(2, 51)`=51   | 窗口 `[12, -5, -6, 50]` |
| 5       | 3             | `nums[1]` (12)               | 51                    | `51 - 12 + 3 = 42`    | `max(51, 42)`=51  | 窗口 `[-5, -6, 50, 3]` |

最终 `maxSum` 为 51。
返回 `(double) 51 / 4 = 12.75`。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入数组 `nums` 的长度。
    *   我们首先遍历前 `k` 个元素来初始化第一个窗口的和，这需要 `O(k)` 时间。
    *   然后，`right` 指针从 `k` 遍历到 `N-1`，总共 `N-k` 次迭代。每次迭代中，我们进行常数次操作（加减、比较）。
    *   因此，总的时间复杂度是 `O(k + (N-k)) = O(N)`，是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`currentSum`, `maxSum`)。
    *   因此，空间复杂度是常数级别的。

---

希望这个详细的解释和代码能帮助你完全理解并掌握这道算法题！








### 1343. 大小为 K 且平均值大于等于阈值的子数组数目
已解答
中等
相关标签
premium lock icon
相关企业
提示
给你一个整数数组 arr 和两个整数 k 和 threshold 。

请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。

 

示例 1：

输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
输出：3
解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。
示例 2：

输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
输出：6
解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。
 

提示：
1 <= arr.length <= 10^5
1 <= arr[i] <= 10^4
1 <= k <= arr.length
0 <= threshold <= 10^4




#### 定长滑动窗口，无注释





```java
class Solution {
    public int numOfSubarrays(int[] arr, int k, int threshold) {
        

        int count = 0;

        long currentSum=0;

        long targetSum = (long) threshold * k;

        for( int i=0; i < k; i++ ) {

            currentSum += arr[i];

        }

        if( currentSum >= targetSum ) {

            count++;
        }


        for( int right=k; right < arr.length; right++ ) {

            
            currentSum = currentSum - arr[right-k] + arr[right];

            if( currentSum >= targetSum ) {

                count++;
            }


        }


        return count;



    }
}
```






#### 定长滑动窗口，注释版




好的，作为一名高级软件工程师，我将极尽详细地为你讲解“大小为 K 且平均值大于等于阈值的子数组数目”这道算法题，并提供详细的 Java 代码实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个整数数组 `arr`。
    *   一个整数 `k`，表示子数组的固定长度。
    *   一个整数 `threshold`，表示平均值的阈值。
*   **目标**: 统计并返回数组 `arr` 中，有多少个**长度为 `k` 的连续子数组**，其**平均值**大于等于 `threshold`。
*   **关键点**:
    *   **连续子数组**: 必须是数组中连续的一部分。
    *   **定长 `k`**: 子数组的长度是固定的 `k`。
    *   **平均值大于等于 `threshold`**: 这是判断一个子数组是否符合条件的标准。

**示例分析：**

假设 `arr = [2,2,2,2,5,5,5,8]`, `k = 3`, `threshold = 4`

我们需要找出所有长度为 3 的子数组，计算它们的平均值，然后看平均值是否 `>= 4`。

1.  子数组 `[2,2,2]`：
    *   和 = `2 + 2 + 2 = 6`
    *   平均值 = `6 / 3 = 2`
    *   `2 < 4`，不符合条件。

2.  子数组 `[2,2,5]`：
    *   和 = `2 + 2 + 5 = 9`
    *   平均值 = `9 / 3 = 3`
    *   `3 < 4`，不符合条件。

3.  子数组 `[2,5,5]`：
    *   和 = `2 + 5 + 5 = 12`
    *   平均值 = `12 / 3 = 4`
    *   `4 >= 4`，**符合条件**。计数 +1。

4.  子数组 `[5,5,5]`：
    *   和 = `5 + 5 + 5 = 15`
    *   平均值 = `15 / 3 = 5`
    *   `5 >= 4`，**符合条件**。计数 +1。

5.  子数组 `[5,5,8]`：
    *   和 = `5 + 5 + 8 = 18`
    *   平均值 = `18 / 3 = 6`
    *   `6 >= 4`，**符合条件**。计数 +1。

最终，符合条件的子数组有 3 个。

**重要观察/优化**:

题目要求 `平均值 >= threshold`，即 `子数组之和 / k >= threshold`。
由于 `k` 总是正整数 (`1 <= k <= arr.length`)，我们可以将不等式两边同乘以 `k`，得到：
`子数组之和 >= threshold * k`。

这个转换非常重要，它避免了在每次计算平均值时进行浮点数除法，从而避免了潜在的浮点数精度问题，并且可以直接比较整数，效率更高。
所以，问题可以转化为：找到有多少个长度为 `k` 的连续子数组，其**和**大于等于 `threshold * k`。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“固定大小滑动窗口”问题。由于我们需要遍历所有长度为 `k` 的子数组并计算它们的和，如果每次都重新求和，效率会非常低 (`O(N*K)`)。

滑动窗口在这里的优势在于：

*   **避免重复计算**: 当窗口从一个位置滑动到下一个位置时，我们不需要重新计算整个新窗口的和。
*   **增量更新**: 我们只需要关注窗口最左边移出的元素和最右边移入的元素，对当前窗口的总和进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **初始化窗口**: 首先计算第一个长度为 `k` 的子数组（即 `arr[0...k-1]`）的元素之和。
2.  **滑动窗口**: 然后，窗口向右滑动。
    *   当窗口从 `arr[i...i+k-1]` 滑动到 `arr[i+1...i+k]` 时：
        *   最左边的元素 `arr[i]` 被移出窗口。
        *   最右边的元素 `arr[i+k]` 被移入窗口。
    *   我们只需要从当前和中减去 `arr[i]`，并加上 `arr[i+k]`，即可得到新窗口的和。
3.  **判断条件并计数**: 在每次滑动（包括初始化第一个窗口后）后，检查当前窗口的和是否大于等于 `threshold * k`。如果是，则计数器加 1。

---

3. 数据结构选择

对于这道题，我们只需要几个简单的变量来存储当前的和、目标和以及符合条件的子数组数目。不需要复杂的数据结构。

*   `currentSum`: 记录当前滑动窗口中元素的和。
*   `count`: 记录符合条件的子数组数目。
*   `targetSum`: `threshold * k` 的结果，用于比较。

**数据类型考虑**:
`arr[i]` 的范围是 `1 <= arr[i] <= 10^4`。
`k` 的范围是 `1 <= k <= arr.length`，`arr.length` 最大是 `10^5`。
`currentSum` 在最坏情况下可能达到 `10^4 * 10^5 = 10^9`。
`threshold` 的范围是 `0 <= threshold <= 10^4`。
`targetSum = threshold * k` 在最坏情况下可能达到 `10^4 * 10^5 = 10^9`。
`int` 类型的最大值约为 `2 * 10^9`，所以 `10^9` 还在 `int` 范围内。
但是，为了更加稳健和防止任何潜在的中间计算溢出（尽管在这里直接相乘可能不会），使用 `long` 类型来存储 `currentSum` 和 `targetSum` 是一个非常好的习惯。

---

4. 算法步骤详解

1.  **初始化变量**:
    *   `count = 0`: 用于存储符合条件的子数组数目。
    *   `currentSum = 0L`: 用于存储当前滑动窗口中元素的和，使用 `long` 类型。
    *   `targetSum = (long)threshold * k`: 计算目标和，同样使用 `long` 类型以防止 `threshold * k` 溢出。

2.  **计算第一个窗口的和并检查**:
    *   遍历数组 `arr` 的前 `k` 个元素 (从索引 0 到 `k-1`)。
    *   将这些元素累加到 `currentSum` 中。
    *   完成第一个窗口的和计算后，检查 `currentSum >= targetSum`。如果为真，则 `count++`。

3.  **滑动窗口并检查**:
    *   从索引 `k` 开始，遍历数组直到末尾 (`arr.length - 1`)。这个索引 `i` 代表当前窗口的右边界新加入的元素。
    *   在每次迭代中：
        *   **移出旧元素**: `currentSum` 减去 `arr[i - k]` (即窗口最左边即将移出的元素)。
        *   **移入新元素**: `currentSum` 加上 `arr[i]` (即窗口最右边新移入的元素)。
        *   **检查条件**: 检查更新后的 `currentSum >= targetSum`。如果为真，则 `count++`。

4.  **返回结果**: 遍历结束后，`count` 就是符合条件的子数组数目。

---

5. 流程图
略

---

6. Java 代码实现

```java
class Solution {
    /**
     * 统计数组中长度为 k 且平均值大于等于阈值的子数组数目。
     * 使用固定大小的滑动窗口算法。
     *
     * @param arr 输入整数数组
     * @param k 子数组的固定长度
     * @param threshold 平均值的阈值
     * @return 长度为 k 且平均值大于等于 threshold 的子数组数目
     */
    public int numOfSubarrays(int[] arr, int k, int threshold) {
        // count 用于记录符合条件的子数组数目
        int count = 0;
        
        // currentSum 用于存储当前滑动窗口中元素的和。
        // 使用 long 类型以防止在累加过程中发生整数溢出，
        // 尽管单个 arr[i] 和 k 的乘积可能在 int 范围内，
        // 但多个 arr[i] 的和可能超出 int 范围。
        long currentSum = 0; 
        
        // targetSum 是判断条件：子数组之和 >= threshold * k。
        // 将 threshold 强制转换为 long 后再与 k 相乘，
        // 确保乘法结果不会溢出 int 范围。
        long targetSum = (long)threshold * k;

        // 1. 计算第一个长度为 k 的窗口的元素之和
        // 窗口范围：arr[0] 到 arr[k-1]
        for (int i = 0; i < k; i++) {
            currentSum += arr[i];
        }

        // 检查第一个窗口是否符合条件
        if (currentSum >= targetSum) {
            count++;
        }

        // 2. 滑动窗口
        // right 指针从 k 开始，遍历到数组末尾
        // 每次循环，right 指针代表当前窗口的右边界新加入的元素
        // 当前窗口的范围是 arr[right - k + 1] 到 arr[right]
        for (int right = k; right < arr.length; right++) {
            // 窗口滑动操作：
            // 移出最左边的元素：currentSum 减去 arr[right - k]
            // 移入最右边的新元素：currentSum 加上 arr[right]
            currentSum = currentSum - arr[right - k] + arr[right];

            // 检查当前窗口更新后的和是否符合条件
            if (currentSum >= targetSum) {
                count++;
            }
        }

        // 遍历结束后，count 即为所求的符合条件的子数组数目
        return count;
    }
}
```

---

7. 示例演练

我们以 `arr = [2,2,2,2,5,5,5,8]`, `k = 3`, `threshold = 4` 为例，逐步演示代码的执行过程：

*   `targetSum = (long)4 * 3 = 12`

| `right` | `arr[right]` | `arr[right - k]` (移出元素) | `currentSum` (更新前) | `currentSum` (更新后) | `currentSum >= targetSum` (>=12)? | `count` | 备注 |
| :------ | :----------- | :-------------------------- | :-------------------- | :-------------------- | :-------------------------------- | :------ | :--- |
| **初始化阶段 (i = 0 to k-1)** | | | | | | | |
| i=0     | 2            | -                           | 0                     | 2                     | -                                 | -       | currentSum = 2 |
| i=1     | 2            | -                           | 2                     | 4                     | -                                 | -       | currentSum = 2 + 2 = 4 |
| i=2     | 2            | -                           | 4                     | 6                     | -                                 | -       | currentSum = 4 + 2 = 6 |
| **初始化结果** | | | | **6** | `6 >= 12` 否              | **0**   | 第一个窗口 `[2,2,2]` 的和是 6。 |
| **滑动阶段 (right = k to arr.length - 1)** | | | | | | | |
| 3       | 2            | `arr[0]` (2)                | 6                     | `6 - 2 + 2 = 6`       | `6 >= 12` 否                      | 0       | 窗口 `[2,2,2]` -> `[2,2,2]` (和不变) |
| 4       | 5            | `arr[1]` (2)                | 6                     | `6 - 2 + 5 = 9`       | `9 >= 12` 否                      | 0       | 窗口 `[2,2,5]` |
| 5       | 5            | `arr[2]` (2)                | 9                     | `9 - 2 + 5 = 12`      | `12 >= 12` 是                     | 1       | 窗口 `[2,5,5]` |
| 6       | 5            | `arr[3]` (2)                | 12                    | `12 - 2 + 5 = 15`     | `15 >= 12` 是                     | 2       | 窗口 `[5,5,5]` |
| 7       | 8            | `arr[4]` (5)                | 15                    | `15 - 5 + 8 = 18`     | `18 >= 12` 是                     | 3       | 窗口 `[5,5,8]` |

最终 `count` 为 3。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入数组 `arr` 的长度。
    *   我们首先遍历前 `k` 个元素来初始化第一个窗口的和，这需要 `O(k)` 时间。
    *   然后，`right` 指针从 `k` 遍历到 `N-1`，总共 `N-k` 次迭代。每次迭代中，我们进行常数次操作（加减、比较）。
    *   因此，总的时间复杂度是 `O(k + (N-k)) = O(N)`，是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`count`, `currentSum`, `targetSum`)。
    *   因此，空间复杂度是常数级别的。

---

希望这个详细的解释和代码能帮助你完全理解并掌握这道算法题！













### 2090. 半径为 k 的子数组平均值
中等
相关标签
premium lock icon
相关企业
提示
给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。

半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。

构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。

x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。

例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。
 

示例 1：



输入：nums = [7,4,3,9,1,8,5,2,6], k = 3
输出：[-1,-1,-1,5,4,4,-1,-1,-1]
解释：
- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。
- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。
  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。
- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。
- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。
- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。


示例 2：

输入：nums = [100000], k = 0
输出：[100000]
解释：
- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。
  avg[0] = 100000 / 1 = 100000 。


示例 3：

输入：nums = [8], k = 100000
输出：[-1]
解释：
- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。
 

提示：
n == nums.length
1 <= n <= 10^5
0 <= nums[i], k <= 10^5







#### 定长滑动窗口，无注释



```java
class Solution {
    public int[] getAverages(int[] nums, int k) {
        

        int n = nums.length;

        int[] avgs = new int[n];

        Arrays.fill( avgs, -1 );

        if( k == 0 ) {

            for( int i=0; i < n; i++ ) {

                avgs[i] = nums[i];

            }

            return avgs;

        }



        long windowSize = (long) 2*k + 1;

        if( windowSize > n ) {

            return avgs;
        }


        long currentSum=0;


        for( int i=0; i < windowSize; i++ ) {

            currentSum += nums[i];

        }


        avgs[k] = (int) ( currentSum / windowSize );


        for( int center = k + 1; center <= n-1 -k; center++ ) {


            currentSum -= nums[center - k - 1];

            currentSum += nums[center + k];


            avgs[center] = (int) (currentSum / windowSize);

        }

        return avgs;



    }
}
```





#### 定长滑动窗口，注释版




好的，作为一名高级软件工程师，我将极尽详细地为你讲解 LeetCode 上的“半径为 k 的子数组平均值”这道算法题，并提供详细的 Java 代码实现。

---

 1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个下标从 0 开始的整数数组 `nums`，长度为 `n`。
    *   一个整数 `k`，表示“半径”。
*   **目标**: 构建并返回一个长度为 `n` 的数组 `avgs`，其中 `avgs[i]` 是以下标 `i` 为中心，半径为 `k` 的子数组的平均值。
*   **关键定义**:
    *   **半径为 k 的子数组**: 对于以 `i` 为中心的子数组，它包含的元素范围是 `nums[i - k]` 到 `nums[i + k]`（包含这两个边界）。
    *   **子数组长度**: 这个子数组的长度是 `(i + k) - (i - k) + 1 = 2k + 1`。
    *   **平均值计算**: `x` 个元素的平均值是 `x` 个元素相加之和除以 `x`。题目明确指出使用**截断式整数除法**，这意味着直接进行整数除法（例如 Java 中 `int` 或 `long` 类型的 `/` 运算符）即可，它会自动向下取整（截断小数部分）。例如，`11 / 4` 结果为 `2`。
    *   **无效情况**: 如果在下标 `i` 前或后不足 `k` 个元素，那么 `avgs[i]` 应该为 `-1`。

**示例分析：**

假设 `nums = [7,4,3,9,1,8,5,2,6]`, `k = 3`

`n = 9`, `k = 3`。
子数组的固定长度（窗口大小）是 `2k + 1 = 2 * 3 + 1 = 7`。

*   **对于 `avgs[0]`, `avgs[1]`, `avgs[2]`**:
    *   以 `0` 为中心：需要 `0-3 = -3` 到 `0+3 = 3`。`nums[-3]` 不存在，所以 `avgs[0] = -1`。
    *   以 `1` 为中心：需要 `1-3 = -2` 到 `1+3 = 4`。`nums[-2]` 不存在，所以 `avgs[1] = -1`。
    *   以 `2` 为中心：需要 `2-3 = -1` 到 `2+3 = 5`。`nums[-1]` 不存在，所以 `avgs[2] = -1`。
    *   **总结**: 对于中心 `i`，如果 `i - k < 0`，则为 `-1`。这意味着前 `k` 个索引 (`0` 到 `k-1`) 都会是 `-1`。

*   **对于 `avgs[3]`**:
    *   以 `3` 为中心，半径为 `3` 的子数组是 `nums[3-3]` 到 `nums[3+3]`，即 `nums[0]` 到 `nums[6]`。
    *   子数组为 `[7,4,3,9,1,8,5]`。
    *   和 = `7 + 4 + 3 + 9 + 1 + 8 + 5 = 37`。
    *   平均值 = `37 / 7 = 5` (截断)。所以 `avgs[3] = 5`。
    *   **观察**: 这是第一个可以形成完整 `2k+1` 长度子数组的中心。它的左边界是 `0` (`k - k`)，右边界是 `2k` (`k + k`)。

*   **对于 `avgs[4]`**:
    *   以 `4` 为中心，半径为 `3` 的子数组是 `nums[4-3]` 到 `nums[4+3]`，即 `nums[1]` 到 `nums[7]`。
    *   子数组为 `[4,3,9,1,8,5,2]`。
    *   和 = `4 + 3 + 9 + 1 + 8 + 5 + 2 = 32`。
    *   平均值 = `32 / 7 = 4` (截断)。所以 `avgs[4] = 4`。

*   **对于 `avgs[5]`**:
    *   以 `5` 为中心，半径为 `3` 的子数组是 `nums[5-3]` 到 `nums[5+3]`，即 `nums[2]` 到 `nums[8]`。
    *   子数组为 `[3,9,1,8,5,2,6]`。
    *   和 = `3 + 9 + 1 + 8 + 5 + 2 + 6 = 34`。
    *   平均值 = `34 / 7 = 4` (截断)。所以 `avgs[5] = 4`。

*   **对于 `avgs[6]`, `avgs[7]`, `avgs[8]`**:
    *   以 `6` 为中心：需要 `6-3 = 3` 到 `6+3 = 9`。`nums[9]` 不存在 (`n=9`，最大索引 `8`)，所以 `avgs[6] = -1`。
    *   以 `7` 为中心：需要 `7-3 = 4` 到 `7+3 = 10`。`nums[10]` 不存在，所以 `avgs[7] = -1`。
    *   以 `8` 为中心：需要 `8-3 = 5` 到 `8+3 = 11`。`nums[11]` 不存在，所以 `avgs[8] = -1`。
    *   **总结**: 对于中心 `i`，如果 `i + k >= n`，则为 `-1`。这意味着后 `k` 个索引 (`n-k` 到 `n-1`) 都会是 `-1`。

**综合有效中心索引范围**:
一个中心 `i` 能够形成完整半径为 `k` 的子数组的条件是：
1.  `i - k >= 0`
2.  `i + k < n`
结合起来就是：`k <= i <= n - 1 - k`。
如果 `k > n - 1 - k`（即 `2k + 1 > n`），那么就没有一个中心 `i` 能够满足条件，所有 `avgs[i]` 都将是 `-1`。

**特殊情况 `k = 0`**:
如果 `k = 0`，则半径为 0。
子数组的长度是 `2 * 0 + 1 = 1`。
以 `i` 为中心的子数组就是 `nums[i]`。
平均值就是 `nums[i] / 1 = nums[i]`。
在这种情况下，所有 `avgs[i]` 都等于 `nums[i]`。

**数据类型考虑**:
`nums[i]` 的范围是 `0 <= nums[i] <= 10^5`。
`k` 的范围是 `0 <= k <= 10^5`。
子数组长度 `2k + 1` 最大可以达到 `2 * 10^5 + 1 = 200001`。
子数组之和 `currentSum` 最大可以达到 `10^5 * (2 * 10^5 + 1) ≈ 2 * 10^{10}`。
Java 的 `int` 类型最大值约为 `2 * 10^9`。显然，`currentSum` 必须使用 `long` 类型来存储，以防止溢出。

---

 2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“固定大小滑动窗口”问题。我们需要计算多个固定长度子数组的和，然后求平均值。如果每次都重新计算子数组的和，效率会非常低 (`O(N * WindowSize)`)。

滑动窗口在这里的优势在于：

*   **避免重复计算**: 当窗口从一个位置滑动到下一个位置时，我们不需要重新计算整个新窗口的和。
*   **增量更新**: 我们只需要关注窗口最左边移出的元素和最右边移入的元素，对当前窗口的总和进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **确定窗口大小**: 窗口的固定大小是 `windowSize = 2k + 1`。
2.  **处理无效情况**: 先初始化结果数组 `avgs` 为 `-1`。对于无法形成完整窗口的中心 `i`，其 `avgs[i]` 保持 `-1`。
3.  **计算第一个有效窗口的和**: 找到第一个能够形成完整窗口的中心 `i`（即 `i = k`）。计算这个窗口 `nums[0]` 到 `nums[2k]` 的和。
4.  **滑动窗口**: 然后，窗口向右滑动。
    *   当中心从 `i` 移动到 `i + 1` 时，窗口的左边界从 `i - k` 移动到 `i + 1 - k`，右边界从 `i + k` 移动到 `i + 1 + k`。
    *   这意味着，`nums[i - k]` 这个元素离开了窗口。
    *   `nums[i + 1 + k]` 这个元素进入了窗口。
    *   我们只需要从当前和中减去离开的元素，并加上进入的元素，即可得到新窗口的和。
5.  **计算平均值并存储**: 在每次更新 `currentSum` 后，计算 `currentSum / windowSize`，并将结果存储到 `avgs[i]` 中。

---

 3. 数据结构选择

*   `int[] nums`: 输入数组。
*   `int[] avgs`: 结果数组，长度与 `nums` 相同。
*   `long currentSum`: 存储当前滑动窗口中元素的总和，必须是 `long` 类型。
*   `long windowSize`: 存储窗口的固定长度 `2k + 1`，使用 `long` 确保计算 `2*k` 时不会因 `k` 过大而溢出（虽然 `k` 最大 `10^5`，`2*k` 是 `2*10^5` 仍在 `int` 范围内，但保持一致性更好）。

---

 4. 算法步骤详解

1.  **初始化结果数组**:
    *   创建 `int[] avgs = new int[n]`。
    *   使用 `java.util.Arrays.fill(avgs, -1)` 将所有元素初始化为 `-1`。这样，对于那些无法形成完整半径 `k` 子数组的索引，其值自然就是 `-1`。

2.  **处理特殊情况 `k = 0`**:
    *   如果 `k` 为 `0`，则每个元素的平均值就是它本身。
    *   遍历 `nums`，将 `nums[i]` 的值直接赋给 `avgs[i]`。
    *   完成后直接返回 `avgs`。

3.  **计算窗口大小**:
    *   `long windowSize = (long)2 * k + 1;`
    *   注意这里将 `2 * k` 强制转换为 `long`，虽然对于 `k` 最大 `10^5` 来说 `2*k` 仍在 `int` 范围内，但这是个好习惯，避免潜在溢出。

4.  **处理窗口大小大于数组长度的情况**:
    *   如果 `windowSize > n`，表示没有任何一个中心能够形成完整的半径 `k` 子数组。
    *   在这种情况下，`avgs` 数组已经全部填充为 `-1` 了，直接返回 `avgs` 即可。

5.  **计算第一个有效窗口的和**:
    *   第一个有效的中心是 `k`。这个窗口的范围是 `nums[0]` 到 `nums[2k]`。
    *   `long currentSum = 0L;`
    *   从 `i = 0` 遍历到 `windowSize - 1`，将 `nums[i]` 累加到 `currentSum`。
    *   将 `(int)(currentSum / windowSize)` 的结果存储到 `avgs[k]` 中。

6.  **滑动窗口并计算后续平均值**:
    *   从下一个可能的中心 `i = k + 1` 开始，一直遍历到 `n - 1 - k`（这是最后一个能形成完整窗口的中心）。
    *   在每次循环中：
        *   **更新 `currentSum`**:
            *   减去离开窗口的元素：`currentSum -= nums[i - k - 1]`。
            *   加上进入窗口的元素：`currentSum += nums[i + k]`。
        *   **计算平均值并存储**: 将 `(int)(currentSum / windowSize)` 的结果存储到 `avgs[i]` 中。

7.  **返回结果**: 遍历结束后，`avgs` 数组就包含了所有计算好的平均值，直接返回它。

---

 5. 流程图

略

---

 6. Java 代码实现

```java
import java.util.Arrays; // 导入 Arrays 工具类，用于填充数组

class Solution {
    /**
     * 计算数组中每个位置半径为 k 的子数组的平均值。
     *
     * @param nums 输入的整数数组。
     * @param k 半径。
     * @return 包含每个位置平均值的数组，如果无法形成完整子数组则为 -1。
     */
    public int[] getAverages(int[] nums, int k) {
        int n = nums.length; // 获取数组长度
        int[] avgs = new int[n]; // 创建结果数组，长度与 nums 相同

        // 1. 初始化结果数组 avgs，所有元素默认填充为 -1。
        // 这是为了处理那些无法形成完整半径 k 子数组的索引。
        Arrays.fill(avgs, -1);

        // 2. 处理特殊情况：k = 0。
        // 如果半径 k 为 0，则每个子数组只包含其中心元素本身。
        // 平均值就是该元素的值。
        if (k == 0) {
            for (int i = 0; i < n; i++) {
                avgs[i] = nums[i];
            }
            return avgs;
        }

        // 计算滑动窗口的固定大小：中心元素 + 前 k 个元素 + 后 k 个元素。
        // 使用 long 类型以确保计算 (2 * k) 时不会因为 k 过大而溢出，虽然这里 int 足够。
        long windowSize = (long)2 * k + 1;

        // 3. 处理特殊情况：如果窗口大小大于数组长度。
        // 这意味着没有任何一个中心能够形成完整的半径 k 子数组。
        // 此时 avgs 数组已经全部是 -1，直接返回即可。
        if (windowSize > n) {
            return avgs;
        }

        // currentSum 用于存储当前滑动窗口中元素的总和。
        // 必须使用 long 类型，因为 nums[i] 和 k 都可能很大，
        // 它们的乘积 (nums[i] * windowSize) 可能超出 int 的最大值。
        long currentSum = 0;

        // 4. 计算第一个有效窗口的元素之和。
        // 第一个能够形成完整半径 k 子数组的中心是索引 k。
        // 这个窗口的范围是 [0, 2k]，即 nums[0] 到 nums[windowSize - 1]。
        for (int i = 0; i < windowSize; i++) {
            currentSum += nums[i];
        }

        // 将第一个有效窗口的平均值存储到 avgs[k]。
        // 题目要求截断式整数除法，Java 的整数除法默认就是截断的。
        avgs[k] = (int)(currentSum / windowSize);

        // 5. 滑动窗口并计算后续有效窗口的平均值。
        // 'center' 变量代表当前子数组的中心索引。
        // 它从 k + 1 开始，一直到 n - 1 - k (最后一个可以形成完整窗口的中心)。
        for (int center = k + 1; center <= n - 1 - k; center++) {
            // 滑动窗口的更新逻辑：
            // - 移除窗口最左边的元素：这个元素是上一个窗口的起始元素。
            //   对于当前中心 'center'，其窗口的左边界是 'center - k'。
            //   上一个窗口的左边界是 '(center - 1) - k'。
            //   因此，要移除的元素是 nums[(center - 1) - k]，即 nums[center - k - 1]。
            currentSum -= nums[center - k - 1];

            // - 添加窗口最右边的新元素：这个元素是当前窗口的结束元素。
            //   对于当前中心 'center'，其窗口的右边界是 'center + k'。
            currentSum += nums[center + k];

            // 计算当前窗口的平均值并存储。
            avgs[center] = (int)(currentSum / windowSize);
        }

        // 6. 返回结果数组。
        return avgs;
    }
}
```

---

 7. 示例演练

我们以 `nums = [7,4,3,9,1,8,5,2,6]`, `k = 3` 为例，逐步演示代码的执行过程：

*   `n = 9`, `k = 3`
*   `avgs` 初始化为 `[-1,-1,-1,-1,-1,-1,-1,-1,-1]`
*   `k != 0`，跳过 `k=0` 处理。
*   `windowSize = (long)2 * 3 + 1 = 7`.
*   `windowSize (7) <= n (9)`，跳过 `windowSize > n` 处理。
*   `currentSum = 0L`.

**1. 计算第一个有效窗口的和 (for i = 0 to 6)**:
*   `i=0`: `currentSum += nums[0]` (7) -> `currentSum = 7`
*   `i=1`: `currentSum += nums[1]` (4) -> `currentSum = 11`
*   `i=2`: `currentSum += nums[2]` (3) -> `currentSum = 14`
*   `i=3`: `currentSum += nums[3]` (9) -> `currentSum = 23`
*   `i=4`: `currentSum += nums[4]` (1) -> `currentSum = 24`
*   `i=5`: `currentSum += nums[5]` (8) -> `currentSum = 32`
*   `i=6`: `currentSum += nums[6]` (5) -> `currentSum = 37`
*   `avgs[k]` (即 `avgs[3]`) = `(int)(37 / 7) = 5`.
*   此时 `avgs` 为 `[-1,-1,-1,5,-1,-1,-1,-1,-1]`。

**2. 滑动窗口 (for center = k + 1 to n - 1 - k)**:
   即 `center` 从 `4` 到 `9 - 1 - 3 = 5`。所以 `center` 将为 `4, 5`。

*   **`center = 4`**:
    *   移除 `nums[center - k - 1]` = `nums[4 - 3 - 1]` = `nums[0]` (7)。
        `currentSum = 37 - 7 = 30`.
    *   添加 `nums[center + k]` = `nums[4 + 3]` = `nums[7]` (2)。
        `currentSum = 30 + 2 = 32`.
    *   `avgs[4] = (int)(32 / 7) = 4`.
    *   此时 `avgs` 为 `[-1,-1,-1,5,4,-1,-1,-1,-1]`。

*   **`center = 5`**:
    *   移除 `nums[center - k - 1]` = `nums[5 - 3 - 1]` = `nums[1]` (4)。
        `currentSum = 32 - 4 = 28`.
    *   添加 `nums[center + k]` = `nums[5 + 3]` = `nums[8]` (6)。
        `currentSum = 28 + 6 = 34`.
    *   `avgs[5] = (int)(34 / 7) = 4`.
    *   此时 `avgs` 为 `[-1,-1,-1,5,4,4,-1,-1,-1]`。

循环结束。

**3. 返回 `avgs`**: `[-1,-1,-1,5,4,4,-1,-1,-1]`，与示例输出完全一致。

---

 8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `Arrays.fill()` 操作需要 `O(N)` 时间。
    *   `k = 0` 的特殊处理循环需要 `O(N)` 时间。
    *   计算第一个有效窗口的和的循环需要 `O(windowSize)` 或 `O(k)` 时间。
    *   滑动窗口的主循环执行 `(n - 1 - k) - (k + 1) + 1 = n - 2k - 1` 次。每次迭代执行常数个操作（加法、减法、除法）。因此这部分是 `O(N - 2k)` 时间。
    *   综合来看，所有操作都是线性的，所以总的时间复杂度是 `O(N)`。

*   **空间复杂度**: `O(N)`。
    *   我们创建了一个新的 `avgs` 数组来存储结果，其大小为 `N`。
    *   其他变量（`n`, `k`, `windowSize`, `currentSum`, `center`）都只占用常数空间。
    *   因此，总的空间复杂度是 `O(N)`。

---

希望这个极尽详细的讲解和代码能帮助你完全理解并掌握这道算法题！








### 2379. 得到 K 个黑块的最少涂色次数
已解答
简单
相关标签
premium lock icon
相关企业
提示
给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 'W' 要么是 'B' ，表示第 i 块的颜色。字符 'W' 和 'B' 分别表示白色和黑色。

给你一个整数 k ，表示想要 连续 黑色块的数目。

每一次操作中，你可以选择一个白色块将它 涂成 黑色块。

请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。

 

示例 1：

输入：blocks = "WBBWWBBWBW", k = 7
输出：3
解释：
一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。
得到 blocks = "BBBBBBBWBW" 。
可以证明无法用少于 3 次操作得到 7 个连续的黑块。
所以我们返回 3 。

示例 2：

输入：blocks = "WBWBBBW", k = 2
输出：0
解释：
不需要任何操作，因为已经有 2 个连续的黑块。
所以我们返回 0 。
 

提示：

n == blocks.length
1 <= n <= 100
blocks[i] 要么是 'W' ，要么是 'B' 。
1 <= k <= n








#### 定长滑动窗口，无注释


```java
class Solution {
    public int minimumRecolors(String blocks, int k) {



        int n = blocks.length();

        int minRecolors = Integer.MAX_VALUE;

        int currentWhites=0;

        for( int i=0; i < k; i++ ) {

            if( blocks.charAt(i) == 'W' ) {

                currentWhites++;
            }
        }

        minRecolors = currentWhites;


        for( int right = k; right < n; right++ ) {


            if( blocks.charAt( right-k ) == 'W' ) {

                currentWhites--;

            }

            if( blocks.charAt(right) == 'W' ) {

                currentWhites++;

            }

            minRecolors = Math.min( minRecolors,currentWhites );

        }

        return minRecolors;
        
    }
}
```






#### 定长滑动窗口，注释讲解




好的，作为一名高级软件工程师，我将极尽详细地为你讲解 LeetCode 上的“得到 K 个黑块的最少涂色次数”这道算法题，并提供详细的 Java 代码实现。

---

1. 理解问题

首先，我们来仔细理解一下题目要求：

*   **输入**:
    *   一个长度为 `n` 的字符串 `blocks`，由 'W'（白色）和 'B'（黑色）组成。
    *   一个整数 `k`，表示我们想要得到的连续黑色块的数目。
*   **操作**: 每一次操作，你可以选择一个白色块 ('W') 将其涂成黑色块 ('B')。
*   **目标**: 返回至少出现一次连续 `k` 个黑色块的**最少操作次数**。

**关键点**:

*   **连续 `k` 个黑色块**: 我们关注的是一个长度恰好为 `k` 的子字符串，并且这个子字符串中的所有字符都必须是 'B'。
*   **最少操作次数**: 这意味着我们需要找到一个长度为 `k` 的子字符串，其中包含的 'W' 字符数量最少。因为每个 'W' 都需要一次操作才能变成 'B'。

**示例分析：**

假设 `blocks = "WBBWWBBWBW"`, `k = 7`

我们需要找到所有长度为 7 的连续子串，计算每个子串中 'W' 的数量，然后找出最小的那个数量。

*   子串 `blocks[0...6]` = `"WBBWWBB"`
    *   'W' 的数量：3 个 (blocks[0], blocks[3], blocks[4])。
    *   操作次数：3

*   子串 `blocks[1...7]` = `"BBWWBBW"`
    *   'W' 的数量：3 个 (blocks[3], blocks[4], blocks[7])。
    *   操作次数：3

*   子串 `blocks[2...8]` = `"BWWBBWB"`
    *   'W' 的数量：3 个 (blocks[3], blocks[4], blocks[7])。
    *   操作次数：3

*   子串 `blocks[3...9]` = `"WWBBWBW"`
    *   'W' 的数量：4 个 (blocks[3], blocks[4], blocks[7], blocks[9])。
    *   操作次数：4

在所有长度为 7 的子串中，最少的操作次数是 3。

---

2. 核心思想：滑动窗口 (Sliding Window)

这道题是典型的“固定大小滑动窗口”问题。我们需要在所有长度为 `k` 的子串中，找到 'W' 数量最少的那个。

*   **避免重复计算**: 我们不需要每次都重新遍历整个子串来计数 'W'。
*   **增量更新**: 当窗口从一个位置滑动到下一个位置时，我们只需要关注窗口最左边移出的字符和最右边移入的字符，对当前窗口中 'W' 的数量进行增量或减量更新。

**滑动窗口的工作原理如下：**

1.  **确定窗口大小**: 窗口的固定大小是 `k`。
2.  **初始化窗口**: 首先计算第一个长度为 `k` 的子串（即 `blocks[0...k-1]`）中 'W' 的数量。这个数量就是我们当前的最少操作次数的候选值。
3.  **滑动窗口**: 然后，窗口向右滑动。
    *   当窗口从 `blocks[i...i+k-1]` 滑动到 `blocks[i+1...i+k]` 时：
        *   最左边的字符 `blocks[i]` 被移出窗口。
        *   最右边的字符 `blocks[i+k]` 被移入窗口。
    *   我们只需要根据 `blocks[i]` 是否是 'W' 来减少计数，并根据 `blocks[i+k]` 是否是 'W' 来增加计数。
4.  **更新最小操作次数**: 在每次滑动后，更新当前窗口中 'W' 的数量，并与记录的最小操作次数进行比较，取较小值。

---

3. 数据结构选择

对于这道题，我们只需要几个简单的变量来存储当前的 'W' 数量以及最小的 'W' 数量。不需要复杂的数据结构。

*   `currentWhites`: 记录当前滑动窗口中 'W' 的数量。
*   `minRecolors`: 记录到目前为止找到的，所有长度为 `k` 的子串中 'W' 的最小数量。

---

4. 算法步骤详解

1.  **初始化变量**:
    *   `n = blocks.length()`: 字符串的长度。
    *   `minRecolors = Integer.MAX_VALUE`: 用于存储找到的最少操作次数。初始化为最大整数值，以便第一次比较时能被任何有效值更新。
    *   `currentWhites = 0`: 用于存储当前滑动窗口中 'W' 的数量。

2.  **计算第一个窗口的 'W' 数量**:
    *   遍历字符串 `blocks` 的前 `k` 个字符 (从索引 0 到 `k-1`)。
    *   对于每个字符，如果它是 'W'，则 `currentWhites` 加 1。
    *   将 `minRecolors` 初始化为 `currentWhites`。

3.  **滑动窗口**:
    *   从索引 `k` 开始，遍历字符串直到末尾 (`n - 1`)。这个索引 `i` 代表当前窗口的右边界新加入的字符。
    *   在每次迭代中：
        *   **移出旧字符**: 检查 `blocks.charAt(i - k)` (即窗口最左边即将移出的字符) 是否是 'W'。如果是，`currentWhites` 减 1。
        *   **移入新字符**: 检查 `blocks.charAt(i)` (即窗口最右边新移入的字符) 是否是 'W'。如果是，`currentWhites` 加 1。
        *   **更新最小操作次数**: 将 `minRecolors` 更新为 `Math.min(minRecolors, currentWhites)`。

4.  **返回结果**: 遍历结束后，`minRecolors` 就是最终答案。

---

5. 流程图


---

6. Java 代码实现

```java
class Solution {
    /**
     * 计算得到 k 个连续黑块的最少涂色次数。
     * 使用固定大小的滑动窗口算法。
     *
     * @param blocks 输入的字符串，由 'W' 和 'B' 组成。
     * @param k 想要得到的连续黑色块的数目。
     * @return 至少出现一次连续 k 个黑色块的最少操作次数。
     */
    public int minimumRecolors(String blocks, int k) {
        int n = blocks.length(); // 获取字符串的长度

        // minRecolors 用于记录到目前为止找到的，所有长度为 k 的子串中 'W' 的最小数量。
        // 初始化为 Integer.MAX_VALUE，确保任何有效值都能更新它。
        int minRecolors = Integer.MAX_VALUE;
        
        // currentWhites 用于记录当前滑动窗口中 'W' 的数量。
        int currentWhites = 0;

        // 1. 计算第一个长度为 k 的窗口的 'W' 数量。
        // 窗口范围：blocks[0] 到 blocks[k-1]
        for (int i = 0; i < k; i++) {
            if (blocks.charAt(i) == 'W') {
                currentWhites++;
            }
        }
        // 将第一个窗口的 'W' 数量作为初始的最小操作次数。
        minRecolors = currentWhites;

        // 2. 滑动窗口。
        // 'i' 代表当前窗口的右边界新加入的字符的索引。
        // 循环从 'k' 开始，直到 'n - 1'（字符串的最后一个字符）。
        // 每次循环，窗口的起始索引是 'i - k + 1'，结束索引是 'i'。
        for (int i = k; i < n; i++) {
            // 窗口滑动操作：
            // - 检查即将移出窗口的字符 (blocks[i - k])。
            //   如果它是 'W'，则 currentWhites 减 1。
            if (blocks.charAt(i - k) == 'W') {
                currentWhites--;
            }

            // - 检查新进入窗口的字符 (blocks[i])。
            //   如果它是 'W'，则 currentWhites 加 1。
            if (blocks.charAt(i) == 'W') {
                currentWhites++;
            }

            // 更新 minRecolors，取当前窗口的 'W' 数量与历史最小操作次数之间的较小者。
            minRecolors = Math.min(minRecolors, currentWhites);
        }

        // 遍历结束后，minRecolors 即为所求的最少操作次数。
        return minRecolors;
    }
}
```

---

7. 示例演练

我们以 `blocks = "WBBWWBBWBW"`, `k = 7` 为例，逐步演示代码的执行过程：

*   `n = 10`, `k = 7`
*   `minRecolors = Integer.MAX_VALUE`
*   `currentWhites = 0`

**1. 计算第一个窗口的 'W' 数量 (for i = 0 to 6)**:
   子串是 `blocks[0...6]` = `"WBBWWBB"`
*   `i=0`, `blocks[0] = 'W'`: `currentWhites = 1`
*   `i=1`, `blocks[1] = 'B'`: `currentWhites = 1`
*   `i=2`, `blocks[2] = 'B'`: `currentWhites = 1`
*   `i=3`, `blocks[3] = 'W'`: `currentWhites = 2`
*   `i=4`, `blocks[4] = 'W'`: `currentWhites = 3`
*   `i=5`, `blocks[5] = 'B'`: `currentWhites = 3`
*   `i=6`, `blocks[6] = 'B'`: `currentWhites = 3`
*   **初始化结果**: `minRecolors = currentWhites = 3`。

**2. 滑动窗口 (for i = k to n - 1)**:
   即 `i` 从 `7` 到 `9`。

*   **`i = 7`**:
    *   移除 `blocks[i - k]` = `blocks[7 - 7]` = `blocks[0]` ('W')。
        `currentWhites = 3 - 1 = 2`.
    *   添加 `blocks[i]` = `blocks[7]` ('W')。
        `currentWhites = 2 + 1 = 3`.
    *   `minRecolors = Math.min(3, 3) = 3`.
    *   当前窗口: `blocks[1...7]` = `"BBWWBBW"`，'W' 数量为 3。

*   **`i = 8`**:
    *   移除 `blocks[i - k]` = `blocks[8 - 7]` = `blocks[1]` ('B')。
        `currentWhites` 不变，仍为 3.
    *   添加 `blocks[i]` = `blocks[8]` ('B')。
        `currentWhites` 不变，仍为 3.
    *   `minRecolors = Math.min(3, 3) = 3`.
    *   当前窗口: `blocks[2...8]` = `"BWWBBWB"`，'W' 数量为 3。

*   **`i = 9`**:
    *   移除 `blocks[i - k]` = `blocks[9 - 7]` = `blocks[2]` ('B')。
        `currentWhites` 不变，仍为 3.
    *   添加 `blocks[i]` = `blocks[9]` ('W')。
        `currentWhites = 3 + 1 = 4`.
    *   `minRecolors = Math.min(3, 4) = 3`.
    *   当前窗口: `blocks[3...9]` = `"WWBBWBW"`，'W' 数量为 4。

循环结束。

**3. 返回 `minRecolors`**: 3。与示例输出完全一致。

---

8. 复杂度分析

*   **时间复杂度**: `O(N)`。
    *   `N` 是输入字符串 `blocks` 的长度。
    *   我们首先遍历前 `k` 个字符来初始化第一个窗口的 'W' 数量，这需要 `O(k)` 时间。
    *   然后，主循环（滑动窗口）从 `i = k` 遍历到 `N-1`，总共 `N-k` 次迭代。每次迭代中，我们进行常数次操作（字符比较、加减、取最小值）。
    *   因此，总的时间复杂度是 `O(k + (N-k)) = O(N)`，是线性的，非常高效。

*   **空间复杂度**: `O(1)`。
    *   我们只使用了几个常数级别的变量 (`n`, `minRecolors`, `currentWhites`, `i`)。
    *   因此，空间复杂度是常数级别的。

---

希望这个极尽详细的讲解和代码能帮助你完全理解并掌握这道算法题！






---







